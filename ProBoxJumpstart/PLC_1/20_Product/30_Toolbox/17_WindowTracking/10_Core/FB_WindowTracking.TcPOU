<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_WindowTracking" Id="{587d5bf3-e64f-4583-bce1-15727290ddd2}" SpecialFunc="None">
    <Declaration><![CDATA[/// Function block can manage multiple transport units of different lengths
FUNCTION_BLOCK FB_WindowTracking IMPLEMENTS I_WindowTracking
(************************************************************************************** 
* 	Application 		: BoxControl Framework 
* 	Revision 			: $Revision: 408723 $ 
* 	Revision date 		: $Date: 2018-06-27 13:49:08 +0200 (Wed, 27 Jun 2018) $ 
* 	Last changed by 	: $Author: b7bolm $ 
* 	URL 				: $URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/21_Projects/BCF_2.0/trunk/BCF/BCF/JumpStart/20_Product/10_App/12_E_Functions/10_Lib/10_Conv/FB_FunctionList.TcPOU $ 
* ------------------------------------------------------------------------------------ 
* 	© Swisslog AG 
* 	Swisslog is not liable for any usage of this source code that is not agreed 
* 	on between Swisslog and the other party. The mandatory legal liability remains 
* 	unaffected. 
* ------------------------------------------------------------------------------------ 
* 	Revision History: 
* 
* 	VERSION 		DATE 			INITIALS 			DESCRIPTION 
* 	0.1 			22.08.2018 		herzig 				First implementation
*	0.2				23.08.2018		mbo					Review
*	0.3				02.11.2018		mbo					Zone begin + end added
*														+ Listener extended
* 
**************************************************************************************)
VAR_INPUT
	EncoderValueInc			: UDINT; (* Current encoder value [inc] Ascending = forward *)
END_VAR
VAR_OUTPUT
	TrackingPosition		: UDINT; // Internal tracking position [mm]
	ZoneCount				: INT; // Number of allocated zones
	TU_Count				: INT; // Number of TUs on tracking
	WindowSize				: UINT := 100; // Size of windows [mm] Remark: Needs to be smaller than smallest transport unit
	TrackingLength			: UDINT; // Length of tracking segment [mm] (e.g. conveyor length)
	Initialized				: BOOL; // Module is initialized
END_VAR
VAR
	fbDebugMsg				: FB_DebugMsg; // Debug instance
	DebugMsg				: T_MAXSTRING; // Debug msg
	TrackingEncoderValue	: UDINT; // Internal tracking value
	RateIncPerMM			: LREAL; // Rate between increments and mm (How many increments represent one mm)
	MaxEncoderValueInc		: UDINT; // Max value of input "EncoderValue" [increments] Remark: Used to detect overflow
	TotalTrackingLength		: UDINT; // Complete tracking length
	TrackingAddition		: UDINT; // Tracking addition
	
	DeltaEncoderValue		: DINT; // Delta encoder value 
	DeleteZoneTrackingEnd	: BOOL := TRUE; // All zones get deleted on tracking end
	MaxWindowIndex			: UINT; // Max window index
	LastEncoderValueInc		: UDINT; // Encoder value of last cycle [increment]
	EndZoneIndex			: UINT; // Currently available zone index at conveyor end
	EndZoneStartPosition	: UDINT; // Start zone position of zone at conveyor end
	EndZoneEndPosition		: UDINT; // End zone position of zone at conveyor end
	EndWindowIndex			: UINT; // Window index at end of conveyor
	iEventListener			: I_WindowTrackingListener; // Tracking zone listener (0 = not used)
	LastDeletedEndZoneIndex	: UINT; // Last deleted index at tracking end, used for report
END_VAR

VAR CONSTANT
	MAX_MOVE_WINDOWS		: UINT := 200; // Maximum windows which can be stored temporarly
	TRANSFER_TABLE_SIZE		: UINT := 100; // Transfer table size
	MAX_NUMBER_OF_WINDOWS 	: UINT := WindowTracking.MAX_NUMBER_OF_WINDOWS;
	MAX_NUMBER_OF_ZONES		: UINT := MAX_NUMBER_OF_WINDOWS/2;
	DELAY_ZONE_LEFT_TRACKING	: UDINT := 5; //Small delay on deletion of the zones to ensure HandoverTracking deletes its TUs & zones first.
END_VAR

VAR PERSISTENT
	WindowTable				: ARRAY[1..MAX_NUMBER_OF_WINDOWS] OF ST_WindowTrackingWindow; // List of all windows
	ZoneTable				: ARRAY[1..MAX_NUMBER_OF_ZONES] OF ST_WindowTrackingZone; // List of all zones
	OngoingTransferList		: ARRAY[1..TRANSFER_TABLE_SIZE] OF ST_WindowTrackingTransfer; // TUs which are in transfer state to the tracking
	PTL_Zones				: ARRAY[1..MAX_NUMBER_OF_ZONES] OF UINT; // Zone to be monitored because of PositionToLive value
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Module needs to be initialized with required values
IF NOT Initialized THEN
	RETURN;
END_IF

// Generate encoder value
// ----------------------------------------------------
DeltaEncoderValue := UDINT_TO_DINT(EncoderValueInc) - UDINT_TO_DINT(LastEncoderValueInc);

IF ABS(DeltaEncoderValue) > UDINT_TO_DINT(MaxEncoderValueInc/2) THEN
	// Correction with + 1 is to include the 0 in MaxEncoderValue
	IF DeltaEncoderValue < 0 THEN
		DeltaEncoderValue := DeltaEncoderValue + UDINT_TO_DINT(MaxEncoderValueInc) + 1;
	ELSE
		DeltaEncoderValue := UDINT_TO_DINT(EncoderValueInc) - (UDINT_TO_DINT(LastEncoderValueInc) + UDINT_TO_DINT(MaxEncoderValueInc)) - 1;
	END_IF
END_IF

TrackingEncoderValue := DINT_TO_UDINT(UDINT_TO_DINT(TrackingEncoderValue) + DeltaEncoderValue);
 
LastEncoderValueInc := EncoderValueInc;

TrackingPosition := LREAL_TO_UDINT(UDINT_TO_LREAL(TrackingEncoderValue) / RateIncPerMM) MOD TotalTrackingLength;

// Manages ongoing transfers
// ----------------------------------------------------
M_ManageOngoingTransfers();

 // Manages position to live zones
// ----------------------------------------------------
M_MonitorZonesPTL();

// Delete all zones when they left the tracking length
// ----------------------------------------------------
IF DeleteZoneTrackingEnd THEN	
	IF EndZoneIndex > 0 THEN
		EndZoneStartPosition := M_GetZoneStartPosition(EndZoneIndex);
		EndZoneEndPosition := M_GetZoneEndPosition(EndZoneIndex);
		
		IF EndZoneStartPosition < TrackingLength + DELAY_ZONE_LEFT_TRACKING THEN
			EndZoneIndex := 0;
			
		ELSIF EndZoneEndPosition >= TrackingLength + DELAY_ZONE_LEFT_TRACKING THEN
			LastDeletedEndZoneIndex := EndZoneIndex;
			
			IF M_DeleteZone(EndZoneIndex) THEN
				// Zone deleted
				DebugMsg := CONCAT('Zone left tracking, zone deleted. ZoneIndex: ',UINT_TO_STRING(LastDeletedEndZoneIndex));;
				fbDebugMsg.M_SendInfoMsg(DebugMsg);
			ELSE
				DebugMsg := CONCAT('Zone left tracking, but could not be deleted. ZoneIndex: ',UINT_TO_STRING(LastDeletedEndZoneIndex));
				fbDebugMsg.M_SendErrorMsg(DebugMsg);
			END_IF
			
			EndZoneIndex := 0;
		END_IF
	ELSE
		EndZoneIndex := M_GetZoneIndex(TrackingLength);
		
		IF EndZoneIndex > 0 THEN
			DebugMsg := CONCAT('Zone index found at Tracking end. ZoneIndex: ',UINT_TO_STRING(EndZoneIndex));
			fbDebugMsg.M_SendInfoMsg(DebugMsg);
		END_IF
	END_IF
	
	// Delete all unassigned windows when they left the tracking length
	// ---------------------------------------------------- 
	EndWindowIndex := M_GetWindowIndex(TrackingLength);
	
	IF EndWindowIndex > 0 THEN
		IF WindowTable[EndWindowIndex].State <> E_WindowTrackingWindowState.IDLE THEN
			// Window has a valid ZoneIndex
			IF WindowTable[EndWindowIndex].ZoneIndex > 0 THEN
				// Check if its zone is still valid
				IF NOT ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].Used THEN
					// Delete window
					M_ClearWindow(EndWindowIndex);
					
				// Check if window is inside zone start and end	
				ELSE
					IF ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneEndWindowIndex >= ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneStartWindowIndex THEN
						IF EndWindowIndex < ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneStartWindowIndex OR
				   		   EndWindowIndex > ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneEndWindowIndex THEN
						   	// Delete window
							M_ClearWindow(EndWindowIndex);
						END_IF		
					ELSE
						IF EndWindowIndex < ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneStartWindowIndex AND
				   		   EndWindowIndex > ZoneTable[WindowTable[EndWindowIndex].ZoneIndex].ZoneEndWindowIndex THEN
						   	// Delete window
							M_ClearWindow(EndWindowIndex);
						END_IF
					END_IF
				END_IF
			ELSE
				// Delete window
				M_ClearWindow(EndWindowIndex);
			END_IF
		END_IF
	END_IF
END_IF
]]></ST>
    </Implementation>
    <Method Name="M_AddTU" Id="{cde32322-776f-4203-9221-f32669cbbba5}">
      <Declaration><![CDATA[/// Adds a TU to the beginning of the zone
METHOD M_AddTU : BOOL // Returns true successfully, otherwise false (Zone not found, Zone to small or already occupied)
VAR_INPUT
	mZoneIndex				: UINT;	// Zone index 
	mTU_Index				: DINT; // Index of TU to add
	mLength					: UINT; // Length of TU to be added [mm] Remark: Needs to be > than WindowSize
	mTU_Offset				: UINT; // Relative TU offset position in zone [mm]
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mWindowIndex			: UINT; // Window index interator
	mNumberLengthWindows	: UINT; // Number of windows to allocate
	mRelWindowPositionFE	: UDINT; // Relative position in first window
	mRelWindowPositionRE	: UDINT; // Relative position in last window
	mFullLength				: UINT; // Complete length which is required from window begin
	mTU_OffsetWindows		: UINT; // TU offset in number of windows
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AddTU := FALSE;

// Validate inputs
IF mZoneIndex = 0 OR 
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   mLength = 0 OR 
   mLength > TrackingLength OR
   mLength <= WindowSize OR
   WindowSize = 0 THEN
	RETURN;
END_IF

// When zone is not used, already occupied or too small, abort
IF NOT ZoneTable[mZoneIndex].Used OR
   ZoneTable[mZoneIndex].TU_Present OR
   mLength > ZoneTable[mZoneIndex].ZoneLength THEN
   RETURN;
END_IF

// Calculate relative position in first zone window
IF ZoneTable[mZoneIndex].ZoneStartPosition + mTU_Offset <= TotalTrackingLength THEN
	mRelWindowPositionFE := (ZoneTable[mZoneIndex].ZoneStartPosition + mTU_Offset) MOD WindowSize;
ELSE
	mRelWindowPositionFE := (ZoneTable[mZoneIndex].ZoneStartPosition + mTU_Offset - TotalTrackingLength) MOD WindowSize;
END_IF

// The relative position in the first window is added to the length, 
// in order to get the amount of windows which are allocated for that TU finally
mFullLength := mLength + UDINT_TO_UINT(mRelWindowPositionFE);

// Convert length into number of windows
mNumberLengthWindows := mFullLength / WindowSize;
// If not the full length could be mapped in windows
// add an additional window
IF (mFullLength MOD WindowSize) > 0 THEN
	mNumberLengthWindows := mNumberLengthWindows + 1;
END_IF

// Convert TU_Offset into number of windows
mTU_OffsetWindows := mTU_Offset / WindowSize;

mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;

ZoneTable[mZoneIndex].TU_Present := TRUE;
ZoneTable[mZoneIndex].TU_Index := mTU_Index;
TU_Count := TU_Count + 1;

// First, the whole TU is added to the beginning of the window of the front edge window
FOR mIdx := 1 TO mNumberLengthWindows + mTU_OffsetWindows DO
	// Set start edge of TU to zone begin
	IF mIdx = mTU_OffsetWindows + 1 THEN
		WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.FRONT_EDGE;
		WindowTable[mWindowIndex].TU_FrontEdgePosition := ZoneTable[mZoneIndex].ZoneStartPosition + mTU_Offset;
		
		ZoneTable[mZoneIndex].TU_StartWindowIndex := mWindowIndex;

	ELSIF mIdx = mNumberLengthWindows + mTU_OffsetWindows THEN
		// Length -1 is correction of window 
		// Example: Window1 has the following range 0..WindowSize-1
		mRelWindowPositionRE := (mFullLength - 1) MOD WindowSize;
		WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.REAR_EDGE;
		
		ZoneTable[mZoneIndex].TU_EndWindowIndex := mWindowIndex;
		
		WindowTable[mWindowIndex].TU_RearEdgePosition := mRelWindowPositionRE + (mWindowIndex - 1) * WindowSize;
		
	ELSIF mIdx > mTU_OffsetWindows + 1 THEN
		WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.OCCUPIED;
	END_IF
	
	mWindowIndex := mWindowIndex + 1;

	// Correct window border overflow
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
END_FOR

// Inform listener
IF iEventListener <> 0 THEN
	iEventListener.M_TrackingTU_AddedEvent(mZoneIndex, ZoneTable[mZoneIndex]);
END_IF

// Notify listener about change of TU state
IF ZoneTable[mZoneIndex].iActionListener <> 0 THEN
	ZoneTable[mZoneIndex].iActionListener.M_ActionZoneChangedEvent(mZoneIndex, ZoneTable[mZoneIndex]);
END_IF

M_AddTU := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AddTU_FE" Id="{60b231e4-640a-4b56-b940-2b211cb1d291}">
      <Declaration><![CDATA[/// Adds a TU to the tracking by creating a Zone and setting the front edge.
/// The add process is completed by triggering M_AddTU_RearEdge
METHOD M_AddTU_FE : UINT // Returns ZoneIndex > 0 if successfully, otherwise 0
VAR_INPUT
	mTU_Index				: DINT; // Index of TU to add
	mAbsolutePosition		: UDINT; // Position where a TU should be added
	miActionListener		: I_TrackingActionListener; // Action listener of the created zone
END_VAR
VAR_INST
	ZoneIndex				: UINT; // New zone index
	WindowIndex				: UINT; // Actual window index
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mFreeOK					: BOOL; // Shift operation successful
	mShortenOK				: BOOL; // Shorten operation successful
	mTrackingPosition		: UDINT; // Position of TU on tracking
	mZoneLength				: UDINT; // Allocated zone length
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initialize
ZoneIndex := 0;
M_AddTU_FE := 0;
mShortenOK := FALSE;

// Get window of absolute position
WindowIndex := M_GetWindowIndex(mAbsolutePosition);

IF WindowIndex > 0 AND WindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN	
	// Is on intended window index already part of a zone, try to shift
	IF WindowTable[WindowIndex].ZoneIndex > 0 THEN
		// Make space
		mFreeOK := M_MakeSpaceByWindows(mAbsolutePosition, 1, TRUE);
	END_IF
	
	// Get a free zone index
	ZoneIndex := M_InsertNewZoneIndex();
	
	IF ZoneIndex > 0 THEN
		// Clear window
		MEMSET(ADR(WindowTable[WindowIndex]), 0, SIZEOF(WindowTable[WindowIndex]));
		
		// Get position on tracking
		mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);
	
		// Fill out window of front edge
		WindowTable[WindowIndex].State := E_WindowTrackingWindowState.FRONT_EDGE;
		WindowTable[WindowIndex].TU_FrontEdgePosition := mTrackingPosition;
		WindowTable[WindowIndex].ZoneIndex := ZoneIndex;
		
		TU_Count := TU_Count + 1;
		
		// TU gets inserted in a "transfer list" to keep assigning
		// upcoming windows until transport is completed.
		FOR mIdx := 1 TO TRANSFER_TABLE_SIZE DO
			// Search an empty slot
			IF NOT OngoingTransferList[mIdx].Active THEN
				OngoingTransferList[mIdx].Active := TRUE;
				OngoingTransferList[mIdx].AbsoluteInsertPosition := mAbsolutePosition;
				OngoingTransferList[mIdx].ZoneIndex := ZoneIndex;
				OngoingTransferList[mIdx].LastWindowIndex := WindowIndex;
				EXIT;
			END_IF
		END_FOR
		
		// Get used zone length from start point to end of first window
		mZoneLength := WindowSize - (mTrackingPosition MOD WindowSize);
		
		// Update zone information
		ZoneTable[ZoneIndex].TU_Present := TRUE;
		ZoneTable[ZoneIndex].TU_Index := mTU_Index;
		ZoneTable[ZoneIndex].iActionListener := miActionListener;
		ZoneTable[ZoneIndex].ZoneStartWindowIndex := WindowIndex;
		ZoneTable[ZoneIndex].TU_StartWindowIndex := WindowIndex;
		ZoneTable[ZoneIndex].ZoneStartPosition := mTrackingPosition;
		ZoneTable[ZoneIndex].ZoneEndWindowIndex := WindowIndex;
		ZoneTable[ZoneIndex].TU_EndWindowIndex := WindowIndex;
		ZoneTable[ZoneIndex].ZoneEndPosition := WindowIndex * WindowSize - 1;
		
		ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(mZoneLength);
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneAddedEvent(ZoneIndex,ZoneTable[ZoneIndex]);
		END_IF
		
		M_AddTU_FE := ZoneIndex;
	ELSE
		// Error no free zones anymore
		fbDebugMsg.M_SendErrorMsg('M_AddTU_FE - Could not allocated new zone');
		M_AddTU_FE := 0;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AddTU_RE" Id="{d814d3c2-4ca0-4441-97f9-54672d98a6e9}">
      <Declaration><![CDATA[/// Completes an AddTU process which was initiated by M_AddTU_FrontEdge
/// Remark: Founds between FE and RE would be deleted automatically
METHOD M_AddTU_RE : UINT // Returns ZoneIndex > 0 if successfully, otherwise 0
VAR_INPUT
	mAbsolutePosition		: UDINT; // Position where a TU should be added
	mZoneIndex				: UINT;	// Zone index to be completed
END_VAR
VAR_INST
	WindowIndex				: UINT; // Window index of absolute position
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mFreeOk					: BOOL; // Shift operation successful
	mTrackingPosition		: UDINT; // Position of TU on tracking
	mZoneFound				: BOOL; // Zone is part of transfer list
	mWindowLength			: UINT; // Windows length
	mWindowIndex			: UINT; // Window index interator
	mDeletedOnTransferList	: BOOL; // Zone was found and deleted on transfer list
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AddTU_RE := 0;

// Validate inputs
IF mZoneIndex = 0 OR 
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

// Ensure that Zone index is available
FOR mIdx := 1 TO TRANSFER_TABLE_SIZE DO
	IF OngoingTransferList[mIdx].Active THEN	
		IF OngoingTransferList[mIdx].ZoneIndex = mZoneIndex THEN 
			mZoneFound := TRUE;
		END_IF
	ELSE
		// No entries available
		EXIT;
	END_IF
END_FOR

// When zone is part of transfer list, update rear edge
IF mZoneFound THEN
	// Calculate window index of absolute position
	WindowIndex := M_GetWindowIndex(mAbsolutePosition);
	
	IF WindowIndex > 0 AND WindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
		// Is on intended window index already part of a zone, try to shift
		IF WindowTable[WindowIndex].ZoneIndex > 0 AND 
		   WindowTable[WindowIndex].ZoneIndex <> mZoneIndex THEN
			// Shift reserved zones
			mFreeOK := M_MakeSpaceByWindows(mAbsolutePosition, 1, TRUE);
		END_IF
		
		// Ensure rear edge window is no front edge window, otherwise invalid -> Abort and delete
		IF WindowTable[WindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
			IF M_DeleteZone(mZoneIndex) THEN
				DebugMsg := CONCAT('M_AddTU_RE - Front edge window found -> Invalid. Zone deleted. Zone index: ',UINT_TO_STRING(mZoneIndex));
				fbDebugMsg.M_SendInfoMsg(DebugMsg);
			ELSE
				DebugMsg := CONCAT('M_AddTU_RE - Front edge window found -> Invalid. Deleting of zone failed . Zone index: ',UINT_TO_STRING(mZoneIndex));
				fbDebugMsg.M_SendErrorMsg(DebugMsg);
			END_IF	
			M_AddTU_RE := 0;
			RETURN;
		END_IF
		
		// Clear window
		MEMSET(ADR(WindowTable[WindowIndex]), 0, SIZEOF(WindowTable[WindowIndex]));
	
		// Get position on tracking
		mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);
		
		// Update window
		WindowTable[WindowIndex].ZoneIndex := mZoneIndex;
		WindowTable[WindowIndex].State := E_WindowTrackingWindowState.REAR_EDGE;
		WindowTable[WindowIndex].TU_RearEdgePosition := mTrackingPosition;
		
		// Clean entry in transfer list and close gaps in list
		mDeletedOnTransferList := M_RemoveZoneFromTransferList(mZoneIndex);
		
		// Update zone data
		ZoneTable[mZoneIndex].ZoneEndWindowIndex := WindowIndex;
		ZoneTable[mZoneIndex].TU_EndWindowIndex := WindowIndex;
		ZoneTable[mZoneIndex].ZoneEndPosition := mTrackingPosition;
		
		IF ZoneTable[mZoneIndex].ZoneEndPosition >= ZoneTable[mZoneIndex].ZoneStartPosition THEN
			ZoneTable[mZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[mZoneIndex].ZoneEndPosition - ZoneTable[mZoneIndex].ZoneStartPosition);
		ELSE
			ZoneTable[mZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[mZoneIndex].ZoneEndPosition + TotalTrackingLength - ZoneTable[mZoneIndex].ZoneStartPosition);
		END_IF
		
		// Check if all windows between Start and Endwindow are occupied and assigned to this zone index
		mWindowIndex := ZoneTable[mZoneIndex].TU_StartWindowIndex;
		
		IF ZoneTable[mZoneIndex].TU_EndWindowIndex >= ZoneTable[mZoneIndex].TU_StartWindowIndex THEN
			mWindowLength :=ZoneTable[mZoneIndex].TU_EndWindowIndex - ZoneTable[mZoneIndex].TU_StartWindowIndex + 1;
		ELSE
			mWindowLength :=ZoneTable[mZoneIndex].TU_EndWindowIndex + MaxWindowIndex  - ZoneTable[mZoneIndex].TU_StartWindowIndex + 1;
		END_IF
		
		FOR mIdx := 1 TO mWindowLength DO
			IF WindowTable[mWindowIndex].ZoneIndex = 0 THEN
				// Update window
				WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.OCCUPIED;
				WindowTable[mWindowIndex].ZoneIndex := mZoneIndex;
							
			ELSIF WindowTable[mWindowIndex].ZoneIndex <> mZoneIndex THEN 
				// Something went wrong, other zone found between start and end window
				DebugMsg := CONCAT('M_AddTU_RE - Other zone found between start and end window of zone:',UINT_TO_STRING(mZoneINdex));
				fbDebugMsg.M_SendErrorMsg(DebugMsg);
			END_IF
			
			mWindowIndex := mWindowIndex + 1;
			
			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR
	
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingTU_AddedEvent(mZoneIndex,ZoneTable[mZoneIndex]);
		END_IF
		
		M_AddTU_RE := mZoneIndex;
	END_IF
// Zone is not part of transfer  list
ELSE
	fbDebugMsg.M_SendErrorMsg('M_AddTU_RE - Zone is not in transfer (not part of ongoing transfers)');
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AddZoneToPTL" Id="{029071cc-66ac-4eb5-8079-f6c131fc43de}">
      <Declaration><![CDATA[/// Adds a zone to the PTL list, so the zone PTL gets monitored
METHOD PROTECTED M_AddZoneToPTL : BOOL // Returns true if successfully added, otherwise false
VAR_INPUT
	mZoneIndex			: UINT; // Zone index to add
END_VAR
VAR
	mIdx				: UINT; // Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AddZoneToPTL := FALSE;

// Validate inputs
IF mZoneIndex = 0 OR 
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

// When zone is not in used or already occupied, abort
IF NOT ZoneTable[mZoneIndex].Used OR
   ZoneTable[mZoneIndex].TU_Present THEN
   RETURN;
END_IF

// TU gets inserted in a list to be monitored PTL
FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
	// Search an empty slot or same
	IF PTL_Zones[mIdx] = 0 OR 
       PTL_Zones[mIdx] = mZoneIndex THEN
		PTL_Zones[mIdx] := mZoneIndex;
		M_AddZoneToPTL := TRUE;
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AdjustFE" Id="{90ac2b5f-1a03-4f0b-b7ec-03fd6714b6f4}">
      <Declaration><![CDATA[/// Adjust front edge position inside a front edge window and aligns rear edge accordingly. 
/// Remark: TU Length stays the same, but its possible that number of used windows is changing.
/// Remark: Found zones at target get shifted or deleted according configuration
METHOD PROTECTED M_AdjustFE : BOOL // Returns true if successfully adjusted, otherwise false (e.g. no front edge window)
VAR_INPUT
	mWindowIndexFE			: UINT; // Window index of front edge
	mNewTrackingPosition	: UDINT; // Tracking position to which the edge should be moved to [mm]
	mDeleteTargetZones  	: BOOL; // Zones at target destination gets deleted, otherwise shifted
END_VAR
VAR
	mZoneDeleted 			: BOOL; // Zone at target was deleted successfully
	mZoneOk 				: BOOL; // Zone at target was shifted successfully
END_VAR
VAR_INST
	UpdateZoneEndWindowIndex: BOOL; // UpdateZoneEndWindowIndex
	ZoneIndex 				: UINT; // Found zone index
	ZoneWindowLength 		: UINT; // Length of zone in windows
	MovePossible 			: BOOL; // Move valid
	MaxWindowPosition 		: UDINT; // Input check for required poition MAX
	MinWindowPosition 		: UDINT; // Input check for required poition MIN
	OldRelWindowPositionFE 	: UDINT; // Old relative window position front edge
	OldRelWindowPositionRE 	: UDINT; // Old relative window position rear edge
	WindowIndexRE			: UINT; // Window index rear edge
	NewWindowIndexRE 		: UINT; // New window index rear edge
	NewRelWindowPositionFE 	: UDINT; // New relative window position front edge
	NewRelWindowPositionRE 	: DINT; // New relative window position rear edge
	NewAbsWindowPositionRE 	: UDINT; // New absolute window position rear edge
	DeltaWindowPositionFE 	: DINT; // Delte distance of edge movement
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initialize
M_AdjustFE := FALSE;
UpdateZoneEndWindowIndex := FALSE;
ZoneIndex := 0;
ZoneWindowLength := 0;
WindowIndexRE := 0;

// Validate inputs
IF mWindowIndexFE = 0 OR
   mWindowIndexFE > MaxWindowIndex  THEN
   RETURN;
END_IF

// Get max and min tracking position of front edge window
MaxWindowPosition := (mWindowIndexFE) * WindowSize;
MinWindowPosition := (mWindowIndexFE-1) * WindowSize;

// Ensure that new tracking position is in range of window
IF mNewTrackingPosition < MinWindowPosition OR 
   mNewTrackingPosition >= MaxWindowPosition THEN
   RETURN;
END_IF

// Try to get the corresponding zone and ensure its valid
IF WindowTable[mWindowIndexFE].State <> E_WindowTrackingWindowState.FRONT_EDGE OR 
   WindowTable[mWindowIndexFE].ZoneIndex = 0 THEN
	RETURN;
END_IF

ZoneIndex := WindowTable[mWindowIndexFE].ZoneIndex;

// Calculate length of zone in windows
IF ZoneTable[ZoneIndex].ZoneEndWindowIndex > ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
	ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
ELSE
	ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
END_IF

// Update front edge position
OldRelWindowPositionFE := WindowTable[mWindowIndexFE].TU_FrontEdgePosition MOD WindowSize;
WindowTable[mWindowIndexFE].TU_FrontEdgePosition := mNewTrackingPosition;

// When Zone begin is same as Frontedge window
IF ZoneTable[ZoneIndex].ZoneStartWindowIndex = mWindowIndexFE THEN
	// Check if adjustment of TU front edge would enlarge zone
	IF ZoneTable[ZoneIndex].ZoneStartPosition > mNewTrackingPosition THEN
		// Adjust zone begin
		ZoneTable[ZoneIndex].ZoneStartPosition := mNewTrackingPosition;
	END_IF
END_IF

//Get rear edge window index
WindowIndexRE := ZoneTable[ZoneIndex].TU_EndWindowIndex;

// When no rear edge could be found
IF WindowIndexRE = 0 THEN
	// Failed
	M_AdjustFE := FALSE;
	RETURN;
END_IF

// Get difference between old and new position in window
NewRelWindowPositionFE := mNewTrackingPosition MOD WindowSize;

DeltaWindowPositionFE := UDINT_TO_DINT(NewRelWindowPositionFE) 
						 - UDINT_TO_DINT(OldRelWindowPositionFE);

OldRelWindowPositionRE := WindowTable[WindowIndexRE].TU_RearEdgePosition MOD WindowSize;

// Calculate relative TU position in new window
NewRelWindowPositionRE := UDINT_TO_DINT(OldRelWindowPositionRE) + DeltaWindowPositionFE;

MovePossible := TRUE;

// When new position in window is more than one window -> additional window required
IF NewRelWindowPositionRE >= WindowSize THEN
	NewWindowIndexRE := WindowIndexRE + 1;
	
	IF NewWindowIndexRE > MaxWindowIndex THEN
		NewWindowIndexRE := NewWindowIndexRE - MaxWindowIndex;
	END_IF
	
	// Check if this window consists already of a zone
	IF WindowTable[NewWindowIndexRE].ZoneIndex > 0 THEN
		IF WindowTable[NewWindowIndexRE].ZoneIndex <> ZoneIndex THEN
		   // A new window is required which was not part of this zone before (No window with reservation state)
		   UpdateZoneEndWindowIndex := TRUE;
		   
			// If another zone is found, try to shift / delete it
		   IF mDeleteTargetZones THEN
				mZoneDeleted := M_DeleteZone(WindowTable[NewWindowIndexRE].ZoneIndex);
				
				IF NOT mZoneDeleted THEN
					// Error, zone could not be deleted -> abort
					MovePossible := FALSE;
				END_IF
			ELSE
				// Otherwise make space
				mZoneOk :=	M_MakeSpace(
								mStartWindowIndex 	:= NewWindowIndexRE, 
								mWindowsToFree 		:= 1,
								mAllowZoneDelete 	:= TRUE);
												
				IF NOT mZoneOk THEN
					// Error, zone could not be shifted -> abort
					MovePossible := FALSE;
				END_IF
			END_IF
		END_IF
	ELSE
		// A new window is required which was not part of this zone before (No window with reservation state)
		UpdateZoneEndWindowIndex := TRUE;
	END_IF
	
	// If zone of new needed window can not be moved, edge can not be adjusted
	IF NOT MovePossible THEN
		// Move not possible, adjustment failed
		M_AdjustFE := FALSE;
		RETURN;
	END_IF
	
	// If a new window was required to be allocated, update end window index
	IF UpdateZoneEndWindowIndex THEN
		ZoneTable[ZoneIndex].ZoneEndWindowIndex := NewWindowIndexRE;
	END_IF 
	
	// Copy window
	WindowTable[NewWindowIndexRE] := WindowTable[WindowIndexRE];
	
	ZoneTable[ZoneIndex].TU_EndWindowIndex := NewWindowIndexRE;
	
	// Clear exiting rear edge window
	M_ClearWindow(WindowIndexRE);
	
	// Assign window between occupied and takeover same flags
	WindowTable[WindowIndexRE].State := E_WindowTrackingWindowState.OCCUPIED;
	WindowTable[WindowIndexRE].ZoneIndex := ZoneIndex;
	WindowTable[WindowIndexRE].Flush := ZoneTable[ZoneIndex].Flush;

// When new position in window is less than 0 -> one window can be removed
ELSIF NewRelWindowPositionRE < 0 THEN
	NewWindowIndexRE := WindowIndexRE - 1;
	
	IF NewWindowIndexRE <= 0 THEN
		NewWindowIndexRE := NewWindowIndexRE + MaxWindowIndex;
	END_IF
	
	// Copy window
	WindowTable[NewWindowIndexRE] := WindowTable[WindowIndexRE];
	
	ZoneTable[ZoneIndex].TU_EndWindowIndex := NewWindowIndexRE;
	
	// If old window was end of zone, clear window, otherwise mark as reserved 
	// beacuse it is still part of the zone but not of the TU anymore
	IF WindowIndexRE = ZoneTable[ZoneIndex].ZoneEndWindowIndex THEN
		// Clear window
		M_ClearWindow(WindowIndexRE);
		
		ZoneTable[ZoneIndex].ZoneEndWindowIndex := NewWindowIndexRE;
	ELSE
		WindowTable[WindowIndexRE].TU_RearEdgePosition := 0;
		WindowTable[WindowIndexRE].State := E_WindowTrackingWindowState.RESERVED;
	END_IF
		
// Window index stays the same
ELSE
	NewWindowIndexRE := WindowIndexRE;
END_IF 

// Correct rear edge and update window and zone
NewAbsWindowPositionRE := DINT_TO_UDINT(NewRelWindowPositionRE) MOD WindowSize + 
					  	  (NewWindowIndexRE -1)*WindowSize;

WindowTable[NewWindowIndexRE].TU_RearEdgePosition := NewAbsWindowPositionRE;

// If rear edge window is last in zone, check position inside window
IF NewWindowIndexRE = ZoneTable[ZoneIndex].ZoneEndWindowIndex THEN
	// Check if adjustment of TU rear edge would enlarge zone and adapt
	// REMARK: Reduce the length of zone is not allowed, because this could have influence to 
    // minimum gaps between zones
	IF ZoneTable[ZoneIndex].ZoneEndPosition < WindowTable[NewWindowIndexRE].TU_RearEdgePosition THEN
		// Adjust zone end
		ZoneTable[ZoneIndex].ZoneEndPosition := WindowTable[NewWindowIndexRE].TU_RearEdgePosition;
	END_IF
END_IF

// Calculate new length
IF ZoneTable[ZoneIndex].ZoneEndPosition >= ZoneTable[ZoneIndex].ZoneStartPosition THEN
	ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition 
															   - ZoneTable[ZoneIndex].ZoneStartPosition);
ELSE
	ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition 
															  + TotalTrackingLength 
															  - ZoneTable[ZoneIndex].ZoneStartPosition);
END_IF

M_AdjustFE := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AdjustRE" Id="{b8803c21-0d1d-470d-9b12-1b36daff3674}">
      <Declaration><![CDATA[/// Adjust rear edge position inside a rear edge window and aligns front edge accordingly. 
/// Remark: TU Length stays the same, but its possible that number of used windows is changing.
/// Remark: Found zones at target get shifted or deleted according configuration
METHOD PROTECTED M_AdjustRE : BOOL // Returns true if successfully adjusted, otherwise false (e.g. no rear edge window)
VAR_INPUT
	mWindowIndexRE				: UINT; // Window index of rear edge
	mNewTrackingPosition		: UDINT; // Tracking position to which the edge should be moved to [mm]
	mDeleteTargetZones  		: BOOL; // Zones at target destination gets deleted, otherwise shifted
END_VAR
VAR_INST
	ZoneIndex 					: UINT; // Found zone index
	ZoneWindowLength 			: UINT; // Length of zone in windows
	UpdateZoneStartWindowIndex 	: BOOL; // Adjustment required an additional window
	MovePossible 				: BOOL; // Move valid
	MaxWindowPosition 			: UDINT; // Input check for required poition MAX
	MinWindowPosition	    	: UDINT; // Input check for required poition MIN
	OldRelWindowPositionFE 		: UDINT; // Old relative window position front edge
	OldRelWindowPositionRE 		: UDINT; // Old relative window position rear edge
	WindowIndexFE				: UINT; // Window index front edge
	NewWindowIndexFE 			: UINT; // New window index rear edge
	NewRelWindowPositionRE 		: UDINT; // New relative window position rear edge
	NewRelWindowPositionFE 		: DINT; // New relative window position front edge
	NewAbsWindowPositionFE 		: UDINT; // New absolute window position front edge
	DeltaWindowPositionRE 		: DINT; // Delte distance of edge movement
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initialize
M_AdjustRE := FALSE;
UpdateZoneStartWindowIndex := FALSE;
ZoneIndex := 0;
ZoneWindowLength := 0;
WindowIndexFE := 0;

// Validate inputs
IF mWindowIndexRE = 0 OR
   mWindowIndexRE > MaxWindowIndex  THEN
   RETURN;
END_IF

// Get max and min tracking position of front edge window
MaxWindowPosition := (mWindowIndexRE) * WindowSize;
MinWindowPosition := (mWindowIndexRE-1) * WindowSize;

// Ensure that new tracking position is in range of window
IF mNewTrackingPosition < MinWindowPosition OR 
   mNewTrackingPosition >= MaxWindowPosition THEN
   RETURN;
END_IF

// Try to get the corresponding zone and ensure its valid
IF WindowTable[mWindowIndexRE].State <> E_WindowTrackingWindowState.REAR_EDGE OR 
   WindowTable[mWindowIndexRE].ZoneIndex = 0 THEN
	RETURN;
END_IF

ZoneIndex := WindowTable[mWindowIndexRE].ZoneIndex;

// Calculate length of zone in windows
IF ZoneTable[ZoneIndex].ZoneEndWindowIndex > ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
	ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
ELSE
	ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
END_IF

// Update rear edge position
OldRelWindowPositionRE := WindowTable[mWindowIndexRE].TU_RearEdgePosition MOD WindowSize;
WindowTable[mWindowIndexRE].TU_RearEdgePosition := mNewTrackingPosition;

// When Zone end is same as Rearedge window
IF ZoneTable[ZoneIndex].ZoneEndWindowIndex = mWindowIndexRE THEN
	// Check if adjustment of TU rear edge would enlarge zone
	IF ZoneTable[ZoneIndex].ZoneEndPosition < mNewTrackingPosition THEN
		// Adjust zone end
		ZoneTable[ZoneIndex].ZoneEndPosition := mNewTrackingPosition;
	END_IF
END_IF

// Get window index of front edge
WindowIndexFE := ZoneTable[ZoneIndex].TU_StartWindowIndex;

// When no front edge could be found
IF WindowIndexFE = 0 THEN
	// Failed
	M_AdjustRE := FALSE;
	RETURN;
END_IF

// Get difference between old and new position in window
NewRelWindowPositionRE := mNewTrackingPosition MOD WindowSize;
DeltaWindowPositionRE := UDINT_TO_DINT(NewRelWindowPositionRE) 
						 - UDINT_TO_DINT(OldRelWindowPositionRE);

OldRelWindowPositionFE := WindowTable[WindowIndexFE].TU_FrontEdgePosition MOD WindowSize;

// Calculate relative TU position in new window
NewRelWindowPositionFE := UDINT_TO_DINT(OldRelWindowPositionFE) + DeltaWindowPositionRE;

// When new position in window is more than one window -> one window can be removed
IF NewRelWindowPositionFE >= WindowSize THEN
	NewWindowIndexFE := WindowIndexFE + 1;
	
	IF NewWindowIndexFE > MaxWindowIndex THEN
		NewWindowIndexFE := NewWindowIndexFE - MaxWindowIndex;
	END_IF
	
	// Copy window
	WindowTable[NewWindowIndexFE] := WindowTable[WindowIndexFE];
	
	ZoneTable[ZoneIndex].TU_StartWindowIndex := NewWindowIndexFE;
	
	// If old window was start of zone, clear window, otherwise mark as reserved 
	// because it is still part of the zone but not of the TU anymore
	IF WindowIndexFE = ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
		// Clear window
		M_ClearWindow(WindowIndexFE);
		
		ZoneTable[ZoneIndex].ZoneStartWindowIndex := NewWindowIndexFE;
	ELSE
		WindowTable[WindowIndexFE].TU_FrontEdgePosition := 0;
		WindowTable[WindowIndexFE].State := E_WindowTrackingWindowState.RESERVED;
	END_IF
	
// When new position in window is less than 0 -> additional window required
ELSIF NewRelWindowPositionFE < 0 THEN	
	NewWindowIndexFE := WindowIndexFE - 1;
		
	IF NewWindowIndexFE <= 0 THEN
		NewWindowIndexFE := NewWindowIndexFE + MaxWindowIndex;
	END_IF
	
	MovePossible := TRUE;

	// Check if this window consists already of a zone
	IF WindowTable[NewWindowIndexFE].ZoneIndex > 0 THEN
		IF WindowTable[NewWindowIndexFE].ZoneIndex <> ZoneIndex THEN
			// A new window is required which was not part of this zone before (No window with reservation state)
		   UpdateZoneStartWindowIndex := TRUE;

			MovePossible := M_MakeSpace(
								mStartWindowIndex 	:= NewWindowIndexFE,
								mWindowsToFree 		:= 1,
								mAllowZoneDelete 	:= mDeleteTargetZones);
		END_IF
	ELSE
		// A new window is required which was not part of this zone before (No window with reservation state)
		UpdateZoneStartWindowIndex := TRUE;
	END_IF
	
	// If zone of new needed window can not be moved, edge can not be adjusted
	IF NOT MovePossible THEN
		// Move not possible, adjustment failed
		M_AdjustRE := FALSE;
		RETURN;
	END_IF
	
	// If a new window was required to be allocated, update end window index
	IF UpdateZoneStartWindowIndex THEN
		ZoneTable[ZoneIndex].ZoneStartWindowIndex := NewWindowIndexFE;
	END_IF 
	
	// Copy window
	WindowTable[NewWindowIndexFE] := WindowTable[WindowIndexFE];
	
	ZoneTable[ZoneIndex].TU_StartWindowIndex := NewWindowIndexFE;
	
	// Clear exiting rear edge window
	M_ClearWindow(WindowIndexFE);
	
	// Assign window between occupied and takeover same flags
	WindowTable[WindowIndexFE].State := E_WindowTrackingWindowState.OCCUPIED;
	WindowTable[WindowIndexFE].ZoneIndex := ZoneIndex;
	WindowTable[WindowIndexFE].Flush := ZoneTable[ZoneIndex].Flush;

// Window index stays the same
ELSE
	NewWindowIndexFE := WindowIndexFE;
END_IF 

// Correct rear edge and update window and zone
NewAbsWindowPositionFE := DINT_TO_UDINT(NewRelWindowPositionFE) MOD WindowSize + 
					  	  (NewWindowIndexFE -1)*WindowSize;

WindowTable[NewWindowIndexFE].TU_FrontEdgePosition := NewAbsWindowPositionFE;

// If front edge window is first in zone, check position inside window
IF NewWindowIndexFE = ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
	// Check if adjustment of TU front edge would enlarge zone
	IF ZoneTable[ZoneIndex].ZoneStartPosition > WindowTable[NewWindowIndexFE].TU_FrontEdgePosition THEN
		// Adjust zone start
		// REMARK: Reduce the length OF zone is NOT allowed, because THIS could have influence TO 
    	// minimum gaps between zones
		ZoneTable[ZoneIndex].ZoneStartPosition := WindowTable[NewWindowIndexFE].TU_FrontEdgePosition;
	END_IF
END_IF

// Calculate new length
IF ZoneTable[ZoneIndex].ZoneEndPosition >= ZoneTable[ZoneIndex].ZoneStartPosition THEN
	ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition 
															   - ZoneTable[ZoneIndex].ZoneStartPosition);
ELSE
	ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition 
															  + TotalTrackingLength 
															  - ZoneTable[ZoneIndex].ZoneStartPosition);
END_IF

M_AdjustRE := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AllocateFixedZone" Id="{1449a464-e5d4-49bd-a669-1b641b28291e}">
      <Declaration><![CDATA[/// Allocates a fixed zone (Can not be shifted)
/// at a specific position. Position needs to be free. 
METHOD M_AllocateFixedZone : UINT; // > 0 Allocated successfully, otherwise 0
VAR_INPUT
	mActionId				: INT; (* ID of action requests zone - 
								     (0 = Only allocation, but free to be used by other actions) *)
	mAbsolutePosition		: UDINT; // Absolute position on tracking [mm]
	mLength					: UINT; // Length of Zone to be allocated [mm]
	miActionListener		: I_TrackingActionListener; // Action listener of the created zone
	mPositionToLive			: UDINT; // Absolute position until allocation gets deleted automatically if not used (0 = disabled)
END_VAR
VAR
	mStartWindowIndex		: UINT; // Start window index at position
	mTrackingPosition		: UDINT; // Absolute position on tracking
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AllocateFixedZone := 0;

// Validate inputs
IF mLength <= 0 THEN
	RETURN;
END_IF

// Get window index of absolute position
mStartWindowIndex := M_GetWindowIndex(mAbsolutePosition);

// When a possible location was found
IF mStartWindowIndex > 0 THEN
	mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);	

	// Allocate zone
	M_AllocateFixedZone := M_ReserveZone(
								mActionId 				:= mActionId,
								mLength					:= mLength, 
								mStartWindowIndex		:= mStartWindowIndex,
								mStartTrackingPosition 	:= mTrackingPosition,
								mInhibitShifting 		:= TRUE,
								miActionListener 		:= miActionListener,
								mPositionToLive 		:= mPositionToLive);				
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AllocateNextFreeZone" Id="{eab9f650-b68c-4bde-842a-abec02129d7e}">
      <Declaration><![CDATA[/// Looks from position ascending for enough space to allocate a new Zone.
METHOD M_AllocateNextFreeZone : UINT; // >0 Index of allocated zone, otherwise 0
VAR_INPUT
	mActionId						: INT; (* ID of action which requests zone - 
								     		(0 = Only allocation, but free to be used by other actions) *)
	mAbsolutePosition				: UDINT; // Absolute position on tracking [mm]
	mLength							: UINT; // Length of Zone to be allocated [mm]
	mMaxDistance					: UDINT; (* Max distance in which begin of a zone is allowed to be allocated (0=Complete distance) 
												Remark: Multiple of windowsize *)
	miActionListener				: I_TrackingActionListener; // Action listener of the created zone
	mPositionToLive					: UDINT; // Absolute position until allocation gets deleted automatically if not used (0 = disabled)
END_VAR
VAR
	mStartWindowIndex				: UINT; // Start Window index to search for enough space
	mNumberLengthWindows			: UINT; // Lenght represented as windows
	RemainingWindowLength 			: INT; // Remaining length on tracking, before reaching startpoint [windows]
	mWindowsTrackingEnd 			: UDINT; // Number of windows from a requesting position to the end of tracking length 
	mWindowIndex 					: UINT; // Iterating window index
	mCounterFreeWindows 			: UINT; // Counter of free windows in a row
	mFreeStartWindowIndex 			: UINT; // Found start window index
	mFreeStartTrackingPosition		: UDINT; // Position in start window index
	mIdx							: DINT; // Loop iterator
	mTrackingPosition				: UDINT; // Absolute position on tracking
	mRelWindowPositionZoneStart		: UDINT; // Relative window position of zone start
	mFullLength						: UINT; // Full required length for allocation
	mMaxDistanceWindows				: INT; // Max windows to be checked if distance is limited
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AllocateNextFreeZone := 0;

// Get window index of absolute position
mStartWindowIndex := M_GetWindowIndex(mAbsolutePosition);
mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);	

// Validate inputs
IF mLength <= 0 OR 
   mStartWindowIndex = 0 THEN
	RETURN;
END_IF

// Convert length into number of windows
IF WindowSize > 0 THEN
	// Calculate relative position in first zone window
	mRelWindowPositionZoneStart := mTrackingPosition MOD WindowSize;
	
	// The relative position in the first window is added to the length, 
	// in order to get the amount of windows which are allocated for that TU finally
	mFullLength := mLength + UDINT_TO_UINT(mRelWindowPositionZoneStart);
	
	// Convert length into number of windows
	mNumberLengthWindows := mFullLength / WindowSize;
	// If not the full length could be mapped in windows
	// add an additional window
	IF (mFullLength MOD WindowSize) > 0 THEN
		mNumberLengthWindows := mNumberLengthWindows + 1;
	END_IF
ELSE
	// Error
	mNumberLengthWindows := 0;
	RETURN;
END_IF

// When zones get deleted on tracking end, the valid tracking distance for allocaition
// is limited to the windows up to the absolute positions and the trackinglength backwards.
// Therefore from the whole distance all windows of TrackingLength - AbsolutePosition have
// to be removed from the allowed shifting distance.
IF DeleteZoneTrackingEnd THEN
	IF WindowSize > 0 THEN
		mWindowsTrackingEnd := (TrackingLength - mAbsolutePosition) / WindowSize + 1;	
	ELSE
		// Configuration error
		mWindowsTrackingEnd := 0;
	END_IF
	
	RemainingWindowLength := UINT_TO_INT(MaxWindowIndex) - UDINT_TO_INT(mWindowsTrackingEnd) - 1;
ELSE
	RemainingWindowLength := UINT_TO_INT(MaxWindowIndex) - 1;
END_IF
	
// When no limitations are given for allocation
IF mMaxDistance = 0 THEN
	mMaxDistanceWindows := UINT_TO_INT(MaxWindowIndex);
// Otherwise limit windows to be checked
ELSE
	// Convert length into number of windows
	mMaxDistanceWindows := UDINT_TO_INT(mMaxDistance / WindowSize);
	// If not the full length could be mapped in windows
	// add an additional window
	IF (mMaxDistance MOD WindowSize) > 0 THEN
		mMaxDistanceWindows := mMaxDistanceWindows + 1;
	END_IF
END_IF

mWindowIndex := mStartWindowIndex;
mFreeStartTrackingPosition := mTrackingPosition;
mCounterFreeWindows := 0;

// Search ascending for enough window space
FOR mIdx := 1 TO WindowTracking.MAX_NUMBER_OF_WINDOWS DO
	// No space available for allocaiton, request failed
	IF RemainingWindowLength <= 0 THEN
		mFreeStartWindowIndex := 0;
		M_AllocateNextFreeZone := 0;
		EXIT;
		
	// Max distance expired and still no zone found
	ELSIF mMaxDistanceWindows <= 0 AND 
          mCounterFreeWindows = 0 THEN
		mFreeStartWindowIndex := 0;
		M_AllocateNextFreeZone := 0;
		EXIT;
		
	// When window is not attached to a zone and not
	// marked to be flushed, its a valid free window
	ELSIF WindowTable[mWindowIndex].ZoneIndex = 0 AND 
       NOT WindowTable[mWindowIndex].Flush THEN
	   
	    IF mCounterFreeWindows = 0 THEN
			// If start window is different than found window index, 
			// set to begin of zone
			IF mWindowIndex <> mStartWindowIndex THEN 
				mFreeStartTrackingPosition := (mWindowIndex - 1) * WindowSize;
			END_IF
			
			mFreeStartWindowIndex := mWindowIndex;
		END_IF
		
		mCounterFreeWindows := mCounterFreeWindows + 1;
		
		// When enough free windows are found, 
		// leave loop to allocate 
		IF mCounterFreeWindows >= mNumberLengthWindows THEN
			EXIT;
		END_IF
	ELSE
		// Reset counter and startposition of free windows in a row
		mCounterFreeWindows := 0;
		mFreeStartWindowIndex := 0;
	END_IF
	
	mWindowIndex := mWindowIndex + 1;
	
	// Correct window border overflow
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
	
	// Calculate remaining possible windows wich can be used
	// for allocation
	RemainingWindowLength := RemainingWindowLength - 1;
	
	// Decrease amount of windows in which a zone needs to found for allocation
	mMaxDistanceWindows := mMaxDistanceWindows - 1;
END_FOR

// When a possible location was found
IF mFreeStartWindowIndex > 0 THEN
	// Allocate zone
	M_AllocateNextFreeZone := M_ReserveZone(
								mActionId 				:= mActionId,
								mLength					:= mLength, 
								mStartWindowIndex 		:= mFreeStartWindowIndex,
								mStartTrackingPosition 	:= mFreeStartTrackingPosition,
								mInhibitShifting 		:= FALSE,
								miActionListener 		:= miActionListener,
								mPositionToLive 		:= mPositionToLive);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_AssignNextFreeZone" Id="{7a98cebf-1bd0-48b7-8336-0cab1fb97179}">
      <Declaration><![CDATA[// Assigns an already allocated but free zone, beginning at absolute position upstream
// Remark: No zones are allocated, only existing zones are considered.
METHOD M_AssignNextFreeZone : UINT // Returns index of assigned zone if successful, otherwise 0
VAR_INPUT
	mActionId				: INT; // ID of action which requests zone (<>0)
	mAbsolutePosition		: UDINT; // Absolute Start position on the tracking [mm]
	mMaxDistance			: UDINT; // Max distance in which begin of a zone is allowed to be for assignment (0=Complete distance) 
	mLength					: UINT; // Length of Zone to be allocated [mm]
	miActionListener		: I_TrackingActionListener; // Action listener of the created zone
	mPositionToLive			: UDINT; // Absolute position until allocation gets deleted automatically if not used (0 = disabled)
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mZoneIndex				: UINT; // Zone index
	mZoneCounter 			: INT; // Amount of already considerd zones
	mFoundZoneIndex			: UINT; // Possible zone index
	mDistanceToLastFoundZone: UDINT; // Distance from Abspoint to last found zone
	mDistanceToCurrentZone	: UDINT; // Distance from abspoint to current found zone
	mMaxAssignDistance		: UDINT; // Max distance which is covered to assign a zone
	mTrackingPosition		: UDINT; // Abs position on tracking
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_AssignNextFreeZone := 0;
mZoneIndex := 0;

// Validate inputs
IF mLength <= 0 OR
   mActionId = 0 THEN
	RETURN;
END_IF

// Abort if no zones available at all
IF ZoneCount = 0 THEN
	RETURN;
END_IF

IF mMaxDistance = 0 THEN	
	mMaxAssignDistance := TotalTrackingLength;
ELSE
	mMaxAssignDistance := mMaxDistance;
END_IF

// Translate requesting position into tracking position
mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);

mZoneCounter := 0;
mFoundZoneIndex := 0;
mDistanceToLastFoundZone := TotalTrackingLength;

// Check all allocated zones to determine the nearest possible to AbsPosition
// Remark: As a reason of performance no scan through all windows upstream is initiated.
FOR mIdx := 1 TO WindowTracking.MAX_NUMBER_OF_ZONES DO
	// When all zones are considered, stop
	IF mZoneCounter = ZoneCount THEN
		EXIT;
		
	// Only enabled zones are considered
	ELSIF ZoneTable[mIdx].Used THEN
		// Only empty zones are considered and not marked to be flushed
		IF NOT ZoneTable[mIdx].TU_Present AND NOT ZoneTable[mIdx].Flush THEN
			// A zone candidate needs to provide the right length and is not reserver already
			IF ZoneTable[mIdx].ActionId = 0 AND
               ZoneTable[mIdx].ZoneLength >=  mLength THEN
				// When start position of zone is higher, the position is in front of the requested position
				// All others are after overflow point
				IF ZoneTable[mIdx].ZoneStartPosition >= mTrackingPosition THEN
					mDistanceToCurrentZone := ZoneTable[mIdx].ZoneStartPosition - mTrackingPosition;
					
					// Check if distance in a valid range for assignment
					IF mDistanceToCurrentZone <= mMaxAssignDistance THEN
						IF mDistanceToLastFoundZone > mDistanceToCurrentZone THEN
							mDistanceToLastFoundZone := mDistanceToCurrentZone;
							mFoundZoneIndex := mIdx;
						END_IF
					END_IF
				ELSE
					mDistanceToCurrentZone := ZoneTable[mIdx].ZoneStartPosition + TotalTrackingLength - mTrackingPosition;
				
					// Check if distance in a valid range for assignment
					IF mDistanceToCurrentZone <= mMaxAssignDistance THEN
						IF mDistanceToLastFoundZone > mDistanceToCurrentZone THEN
							mDistanceToLastFoundZone := mDistanceToCurrentZone;
							mFoundZoneIndex := mIdx;
						END_IF
					END_IF
				END_IF
			END_IF
		END_IF
		
		mZoneCounter := mZoneCounter + 1;
	END_IF	
END_FOR

// Reserve zone
IF mFoundZoneIndex > 0 THEN
	ZoneTable[mFoundZoneIndex].ActionId := mActionId;
	ZoneTable[mFoundZoneIndex].iActionListener := miActionListener;
	ZoneTable[mFoundZoneIndex].PositionToLive := mPositionToLive;
	
	// When a position to live is configured, ensure zone gets monitored
	IF mPositionToLive > 0 THEN
		M_AddZoneToPTL(mFoundZoneIndex);
	ELSE
		// It is possible that found zone had already a PTL
		// If new one is 0, means no monitoring
		M_RemoveZoneFromPTL(mFoundZoneIndex);
	END_IF
END_IF

M_AssignNextFreeZone := mFoundZoneIndex;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CalculateTotalTrackingLength" Id="{144ec777-0eb0-4a17-8a02-53eb336cb8ca}">
      <Declaration><![CDATA[/// Calculates full tracking distance and ensure its a multiple of windowsize.
/// Additional it adds the tracking addition distance to allow more space for reservations.
METHOD PROTECTED M_CalculateTotalTrackingLength : UDINT // Returns complete tracking distance 
VAR_INPUT
	mTrackingLength			: UDINT; // Length of tracking segment [mm] (e.g. conveyor length)
	mTrackingAddition		: UDINT; // Additional tracking length [mm]
	mWindowSize				: UINT; // Window size [mm]
END_VAR
VAR
	mLength					: UDINT; // Tracking length with out taking care of window size
	mRest					: UDINT; // Missing value between Length and next integer
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* Calculation is based on the following:
	+ 2 * Tracking length
	+ Tracking addition
	+ supplement to ensure its a multiple of window size
*)

mLength := mTrackingLength * 2 + TrackingAddition;
mRest := mLength MOD mWindowSize;

IF mRest > 0 THEN
	M_CalculateTotalTrackingLength := mLength + (mWindowSize-mRest);
ELSE
	M_CalculateTotalTrackingLength := mLength;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ClearTables" Id="{93e3ebd3-49ec-4edc-8e35-8aa72f839642}">
      <Declaration><![CDATA[/// Clears all windows, zones and ongoing transfers. Notifies all listeners.
/// Remark: This method is executed immediately and can therefore influence
///         ongoing operations.
METHOD M_ClearTables : BOOL // Returns true if successful, otherwise false
VAR
	mZoneCounter		: INT;
	mIdx				: UINT;
END_VAR
VAR_INST
	AllTablesCleared	: BOOL;
	OldZoneTable		: ARRAY[1..MAX_NUMBER_OF_ZONES] OF ST_WindowTrackingZone; // List of all zones
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ClearTables := FALSE;

// Store old zone table
OldZoneTable := ZoneTable;

// Clear all tables
AllTablesCleared := MEMSET(ADR(WindowTable), 0, SIZEOF(WindowTable)) > 0 AND
				    MEMSET(ADR(ZoneTable), 0, SIZEOF(ZoneTable)) > 0 AND
				    MEMSET(ADR(OngoingTransferList), 0, SIZEOF(OngoingTransferList)) > 0 AND
				    MEMSET(ADR(PTL_Zones), 0, SIZEOF(PTL_Zones)) > 0;

// Inform listener
IF AllTablesCleared THEN
	mZoneCounter := 0;
	// Notify listeners
	FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
		// When number of present zone is reached
		IF mZoneCounter >= ZoneCount THEN
			EXIT;
			
		ELSIF OldZoneTable[mIdx].Used THEN
			// Check if zone had a registred action lister and notify
			IF OldZoneTable[mIdx].iActionListener <> 0 THEN
				OldZoneTable[mIdx].iActionListener.M_ActionZoneDeletedEvent(mIdx,OldZoneTable[mIdx]);
			END_IF
			
			// Inform window tracking listener
			IF iEventListener <> 0 THEN
				IF OldZoneTable[mIdx].TU_Present THEN
					iEventListener.M_TrackingTU_DeletedEvent(mIdx,OldZoneTable[mIdx]);
				END_IF
				
				iEventListener.M_TrackingZoneDeletedEvent(mIdx,OldZoneTable[mIdx]);
			END_IF
	
			mZoneCounter := mZoneCounter + 1;	
		END_IF
	END_FOR
	
	// Clean internal counters
	ZoneCount := 0;
	TU_Count := 0;
	
	M_ClearTables := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ClearWindow" Id="{f2025eb8-c615-4476-9dfa-fd43c0d6fbe2}">
      <Declaration><![CDATA[/// Clears window and initialize with default values
METHOD PROTECTED M_ClearWindow : BOOL // returns true if successfull cleared, otherwise false
VAR_INPUT
	mWindowIndex	: UINT; // Window index to clear
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ClearWindow := FALSE;

// Validate inputs
IF mWindowIndex <= 0 OR
   mWindowIndex > MaxWindowIndex THEN
   RETURN;
END_IF

M_ClearWindow := MEMSET(ADR(WindowTable[mWindowIndex]), 0, SIZEOF(WindowTable[mWindowIndex])) > 0;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DeleteZone" Id="{5220ccb4-4fa0-48d6-a82d-9481c1a12da1}">
      <Declaration><![CDATA[/// Delete a zone and all related windows
/// Remark: Including zones with physical TUs 
METHOD M_DeleteZone : BOOL // Returns true if successful, otherwise false
VAR_INPUT
	mZoneIndex 				: UINT; // Zone index to delete
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mZoneWindowLength 		: UINT; // Length of zone to be moved
	mWindowIndex			: UINT; // Start window index
	mDeletedOnTransferList	: BOOL; // Zone was found and deleted on transfer list
	mDeletedOnPTL			: BOOL; // Zone was found and deleted in PTL list
END_VAR
VAR_INST
	OldZoneData				: ST_WindowTrackingZone; // Old deleted zone data
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_DeleteZone := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
   RETURN;
END_IF

// Check if zone is complete
IF ZoneTable[mZoneIndex].ZoneEndWindowIndex > 0 AND
   ZoneTable[mZoneIndex].ZoneStartWindowIndex > 0 THEN
	
	// Calculate length of zone to move
	IF ZoneTable[mZoneIndex].ZoneEndWindowIndex >= ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		mZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		mZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex + MaxWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
		
// Otherwise scan all windows
ELSE
	mZoneWindowLength := MaxWindowIndex;
END_IF

// When start is known, start deleting of windows
IF ZoneTable[mZoneIndex].ZoneStartWindowIndex > 0 THEN
	mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
	// Store zone data for report
	OldZoneData := ZoneTable[mZoneIndex];
	
	// Loop through all windows and delete them
	FOR mIdx := 1 TO mZoneWindowLength DO
		// Ensure that window is part of requested zone
		IF WindowTable[mWindowIndex].ZoneIndex = mZoneIndex THEN
			// Delete window
			M_ClearWindow(mWindowIndex);
		// Otherwise stop deleting
		ELSE
			EXIT;
		END_IF
		
		mWindowIndex := mWindowIndex + 1;
		 
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
END_IF

// When zone had a TU present, update counter values
IF ZoneTable[mZoneIndex].TU_Present THEN
	TU_Count := TU_Count - 1;
	
	IF TU_Count < 0 THEN
		TU_Count := 0;
	END_IF
	
	// Inform listener
	IF iEventListener <> 0 THEN
		iEventListener.M_TrackingTU_DeletedEvent(mZoneIndex,OldZoneData);
	END_IF
END_IF

// Clean entry in transfer list and close gaps in list
mDeletedOnTransferList := M_RemoveZoneFromTransferList(mZoneIndex);
mDeletedOnPTL := M_RemoveZoneFromPTL(mZoneIndex);

// Delete Zone Index
MEMSET(ADR(ZoneTable[mZoneIndex]),0,SIZEOF(ZoneTable[mZoneIndex]));

ZoneCount := ZoneCount - 1;

IF ZoneCount < 0 THEN
	ZoneCount := 0;
END_IF

// Inform listener
IF iEventListener <> 0 THEN
	iEventListener.M_TrackingZoneDeletedEvent(mZoneIndex,OldZoneData);
END_IF

// Check if zone had a registred action listener and notify
IF OldZoneData.iActionListener <> 0 THEN
	OldZoneData.iActionListener.M_ActionZoneDeletedEvent(mZoneIndex,OldZoneData);
END_IF

// If the currently monitored index is same as the deleted one, reset monitoring
IF EndZoneIndex = mZoneIndex THEN
	EndZoneIndex := 0;
END_IF

M_DeleteZone := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_EnlargeZone" Id="{c49b1261-8958-4b76-beec-b7d48a56b3f7}">
      <Declaration><![CDATA[/// Enlarges a zone by given value in up- or downstream direction
METHOD M_EnlargeZone : BOOL// Returns TRUE if successful,
VAR_INPUT
	mZoneIndex 				: UINT; // Zone index to enlarge
	mAdditionalLength		: UINT; // Add this length to existing zone [mm]
	mShiftFrontEdge			: BOOL; // Shift front edge for enlargement
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mWindowIndex			: UINT; // Start window index
	mAdditionalWindowLength	: UINT; // Zone length in windows
	mEnlargementAllowed 	: BOOL; // Enlargement valid (e.g. free space available)
	mZoneEndWindowIndex		: UINT; // Zone end window index
	mZoneStartWindowIndex	: UINT; // Zone start window index
	mFreeOK					: BOOL; // Free operation successful
	mZoneEndPositionNew		: UDINT; // Zone end position after enlargement
	mZoneStartPositionNew	: UDINT; // Zone start position after enlargement
END_VAR
VAR_INST
	OldZoneData				: ST_WindowTrackingZone; // Old tracking zone data
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_EnlargeZone := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   WindowSize = 0 THEN
   RETURN;
END_IF

IF NOT mShiftFrontEdge THEN
	// Calculate new zone end position
	IF ZoneTable[mZoneIndex].ZoneEndPosition + mAdditionalLength > TotalTrackingLength THEN
		mZoneEndPositionNew := ZoneTable[mZoneIndex].ZoneEndPosition + mAdditionalLength - TotalTrackingLength;
		mAdditionalWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(mZoneEndPositionNew)) - M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneEndPosition)) + MaxWindowIndex;
	ELSE
		mZoneEndPositionNew := ZoneTable[mZoneIndex].ZoneEndPosition + mAdditionalLength;
		mAdditionalWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(mZoneEndPositionNew)) - M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneEndPosition));
	END_IF

	mWindowIndex := ZoneTable[mZoneIndex].ZoneEndWindowIndex;
	mEnlargementAllowed := TRUE;
	
	// Ensure reservation is possible
	FOR mIdx := 1 TO mAdditionalWindowLength DO
		mWindowIndex := mWindowIndex + 1;
	 
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
		
		// Is on intended window index already part of a zone, try to shift
		IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
			// Shift reserved zones
			mFreeOK := M_MakeSpace(mWindowIndex, 1, FALSE);
			
			IF NOT mFreeOK THEN
			   // Cancel reservation
			   mEnlargementAllowed := FALSE;
			   M_EnlargeZone := FALSE;
		   
				// Error
				fbDebugMsg.M_SendErrorMsg('M_EnlargeZone - Enlargement not possible, no available space.');	
				RETURN;
			END_IF
		END_IF	
	END_FOR
ELSE
	// Calculate new zone start position
	IF mAdditionalLength > ZoneTable[mZoneIndex].ZoneStartPosition THEN
		mZoneStartPositionNew := ZoneTable[mZoneIndex].ZoneStartPosition - mAdditionalLength + TotalTrackingLength;
		mAdditionalWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneStartPosition)) - M_GetWindowIndex(M_GetAbsolutePosition(mZoneStartPositionNew)) + MaxWindowIndex;
	ELSE
		mZoneStartPositionNew := ZoneTable[mZoneIndex].ZoneStartPosition + mAdditionalLength;
		mAdditionalWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneStartPosition)) - M_GetWindowIndex(M_GetAbsolutePosition(mZoneStartPositionNew));
	END_IF
	
	mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
	mEnlargementAllowed := TRUE;
	
	// Ensure reservation is possible
	FOR mIdx := 1 TO mAdditionalWindowLength DO
		mWindowIndex := mWindowIndex - 1;
	 
		// Correct border overflow
		IF mWindowIndex = 0 THEN
			mWindowIndex := MaxWindowIndex;
		END_IF
		
		// Is on intended window index already part of a zone, try to shift
		IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
			// Cancel reservation
			mEnlargementAllowed := FALSE;
			M_EnlargeZone := FALSE;
		   
			// Error
			fbDebugMsg.M_SendErrorMsg('M_EnlargeZone - Enlargement not possible, no available space.');	
			RETURN;
		END_IF	
	END_FOR
END_IF

// When enlargement is possible to be executed
IF mEnlargementAllowed THEN
	
	OldZoneData := ZoneTable[mZoneIndex];

	IF NOT mShiftFrontEdge THEN
		mWindowIndex := ZoneTable[mZoneIndex].ZoneEndWindowIndex;
		// Init
		mZoneEndWindowIndex := mWindowIndex;
		
		// Loop through all windows and assign new zone
		FOR mIdx := 1 TO mAdditionalWindowLength DO
			mWindowIndex := mWindowIndex + 1;
		 
			// Correct border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
			
		   // Clear window
			MEMSET(ADR(WindowTable[mWindowIndex]), 0, SIZEOF(WindowTable[mWindowIndex]));
			
			WindowTable[mWindowIndex].ZoneIndex := mZoneIndex;
			WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.RESERVED;
							
			mZoneEndWindowIndex := mWindowIndex;
		END_FOR	
		
		// Update zone table
		ZoneTable[mZoneIndex].ZoneEndWindowIndex := mZoneEndWindowIndex;
		ZoneTable[mZoneIndex].ZoneEndPosition := mZoneEndPositionNew;
		ZoneTable[mZoneIndex].ZoneLength := ZoneTable[mZoneIndex].ZoneLength + mAdditionalLength;
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneEnlargedEvent(
				mTrackingZoneIndex 		:= mZoneIndex,
                mOldTrackingZoneData 	:= OldZoneData,
                mNewTrackingZoneDAta 	:= ZoneTable[mZoneIndex]);
		END_IF
		
		M_EnlargeZone := TRUE;
	ELSE
		mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
			
		// Loop through all windows and assign new zone
		// Init
		mZoneStartWindowIndex := mWindowIndex;
		
		FOR mIdx := 1 TO mAdditionalWindowLength DO
			mWindowIndex := mWindowIndex - 1;
		 
			// Correct border overflow
			IF mWindowIndex = 0 THEN
				mWindowIndex := MaxWindowIndex;
			END_IF
			
		   // Clear window
			MEMSET(ADR(WindowTable[mWindowIndex]), 0, SIZEOF(WindowTable[mWindowIndex]));
			
			WindowTable[mWindowIndex].ZoneIndex := mZoneIndex;
			WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.RESERVED;
							
			mZoneStartWindowIndex := mWindowIndex;
		END_FOR		
		
		// Update zone table
		ZoneTable[mZoneIndex].ZoneStartWindowIndex := mZoneStartWindowIndex;
		ZoneTable[mZoneIndex].ZoneStartPosition := mZoneStartPositionNew;
		ZoneTable[mZoneIndex].ZoneLength := ZoneTable[mZoneIndex].ZoneLength + mAdditionalLength;
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneEnlargedEvent(
				mTrackingZoneIndex 		:= mZoneIndex,
                mOldTrackingZoneData 	:= OldZoneData,
                mNewTrackingZoneDAta 	:= ZoneTable[mZoneIndex]);
		END_IF
		
		M_EnlargeZone := TRUE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_FlushDistance" Id="{9d553746-93ac-4eb4-86cd-df210fe81771}">
      <Declaration><![CDATA[/// Marks all windows and zones in an area to be flushed.
/// (e.g. because of an error the TU position is not reliable anymore)
/// Remark: This includes empty windows as well
METHOD M_FlushDistance : BOOL // Returns true if successful, otherwise false
VAR_INPUT
	mAbsoluteStartPosition		: UDINT; // Position to start marking [mm]
	mAbsoluteEndPosition		: UDINT; // Position to stop marking [mm]
END_VAR
VAR
	mStartWindowIndex			: UINT; // Start window index
	mEndWindowIndex				: UINT; // End window index
	mWindowLength				: UINT; // Window length
	mWindowIndex				: UINT; // Window index iterator
	mZoneIndex					: UINT; // Zone index of window
	mIdx						: UINT; // Loop iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_FlushDistance := FALSE;

mEndWindowIndex := M_GetWindowIndex(mAbsoluteStartPosition);
mStartWindowIndex := M_GetWindowIndex(mAbsoluteEndPosition);

IF mEndWindowIndex > mStartWindowIndex THEN
	mWindowLength := mEndWindowIndex - mStartWindowIndex + 1;
ELSE
	mWindowLength := mEndWindowIndex + MaxWindowIndex - mStartWindowIndex + 1;
END_IF

mWindowIndex := mStartWindowIndex;

FOR mIdx := 1 TO mWindowLength DO
	WindowTable[mWindowIndex].Flush := TRUE;
	
	// If window is part of zone, mark full zone as to be flushed
	IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
		mZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
		
		ZoneTable[mZoneIndex].Flush := TRUE;
	END_IF

	mWindowIndex := mWindowIndex + 1;
	
	// Correct window border overflow
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
END_FOR

M_FlushDistance := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetAbsolutePosition" Id="{128fd462-103b-46d2-b1da-feef9d46088f}">
      <Declaration><![CDATA[/// Converts a tracking position into the absolute position regarding tracking length
METHOD M_GetAbsolutePosition : UDINT // Absolute position releated to Tracking length [mm]
VAR_INPUT
	mTrackingPosition			: UDINT; // Tracking position on tracking 
END_VAR
VAR
	mCurrentEncoderPosition		: UDINT; // Current tracking position [mm]
	mRequestingTrackingPosition : UDINT; // Requesting position on tracking [mm]
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[mCurrentEncoderPosition := (TrackingPosition MOD TotalTrackingLength);
mRequestingTrackingPosition := (mTrackingPosition MOD TotalTrackingLength);

IF mRequestingTrackingPosition < mCurrentEncoderPosition THEN
	M_GetAbsolutePosition := mCurrentEncoderPosition - mRequestingTrackingPosition;
ELSE
	M_GetAbsolutePosition := mCurrentEncoderPosition - mRequestingTrackingPosition + TotalTrackingLength;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetDistanceToTU_End" Id="{dddf1dcf-3adf-4d1f-a800-63fca8c7a466}">
      <Declaration><![CDATA[/// Returns distance to end of tu from observation point. 
/// Position 0 = observation point, Position Max = Observation point plus half tracking length.
/// Remark: In order to reduce the area use M_IsZoneInRange.
METHOD M_GetDistanceToTU_End : DINT // Returns distance to tu end. x < 0 Zone has already passed by x
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position to watch
	mZoneIndex				: UINT; // Index to be measured
END_VAR
VAR
	mTrackingPosition		: DINT; // Current position on tracking
	mTU_EndPosition			: DINT; // TU end tracking position
	mEndWindowIndex			: UINT; // End window index
	mDistanceAhead			: DINT; // Distance to zone ahead
	mDistanceAfter			: DINT; // Distance to zone after
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetDistanceToTU_End := 0;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

IF NOT ZoneTable[mZoneIndex].Used OR
  ZoneTable[mZoneIndex].TU_EndWindowIndex = 0 THEN
	RETURN;
END_IF

// Get position of observation point on tracking (=0)
mTrackingPosition := UDINT_TO_DINT(M_GetTrackingPosition(mAbsolutePosition));
mEndWindowIndex := ZoneTable[mZoneIndex].TU_EndWindowIndex;

mTU_EndPosition := UDINT_TO_DINT(WindowTable[mEndWindowIndex].TU_RearEdgePosition);

// Calculate distance in both directions, Zone is ahead to observation point or after
mDistanceAhead := (mTU_EndPosition - mTrackingPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);
mDistanceAfter := (mTrackingPosition - mTU_EndPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);

// Definition range: Ahead = + / After = -
// Ahead = Max -1 -> Observation
// After = Observation -> Max
IF mDistanceAfter <= mDistanceAhead THEN
	M_GetDistanceToTU_End := mDistanceAfter * (-1);
ELSE
	M_GetDistanceToTU_End := mDistanceAhead;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetDistanceToTU_Start" Id="{59b019ca-0cb9-48d4-bb7b-66b7d0cab66b}">
      <Declaration><![CDATA[/// Returns distance to begin of TU from observation point. 
/// Position 0 = observation point, Position Max = Observation point plus half tracking length.
/// Remark: In order to reduce the area use M_IsZoneInRange.
METHOD M_GetDistanceToTU_Start : DINT // Returns distance to tu start. x < 0 Zone has already passed by x
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position to watch
	mZoneIndex				: UINT; // Index to be measured
END_VAR
VAR
	mTrackingPosition		: DINT; // Current position on tracking
	mTU_StartPosition		: DINT; // TU start tracking position
	mStartWindowIndex		: UINT; // Start window index
	mDistanceAhead			: DINT; // Distance to zone ahead
	mDistanceAfter			: DINT; // Distance to zone after
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetDistanceToTU_Start := 0;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

IF NOT ZoneTable[mZoneIndex].Used OR
  ZoneTable[mZoneIndex].TU_StartWindowIndex = 0 THEN
	RETURN;
END_IF

// Get position of observation point on tracking (=0)
mTrackingPosition := UDINT_TO_DINT(M_GetTrackingPosition(mAbsolutePosition));
mStartWindowIndex := ZoneTable[mZoneIndex].TU_StartWindowIndex;

mTU_StartPosition := UDINT_TO_DINT(WindowTable[mStartWindowIndex].TU_FrontEdgePosition);

// Calculate distance in both directions, Zone is ahead to observation point or after
mDistanceAhead := (mTU_StartPosition - mTrackingPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);
mDistanceAfter := (mTrackingPosition - mTU_StartPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);

// Definition range: Ahead = + / After = -
// Ahead = Max -1 -> Observation
// After = Observation -> Max
IF mDistanceAfter <= mDistanceAhead THEN
	M_GetDistanceToTU_Start := mDistanceAfter * (-1);
ELSE
	M_GetDistanceToTU_Start := mDistanceAhead;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetDistanceToZoneEnd" Id="{2733d983-dc18-42dc-a3b0-91be96617f09}">
      <Declaration><![CDATA[/// Returns distance to end of zone from observation point. 
/// Position 0 = observation point, Position Max = Observation point plus half tracking length.
/// Remark: In order to reduce the area use M_IsZoneInRange.
METHOD M_GetDistanceToZoneEnd : DINT // Returns distance to zone end. x < 0 Zone has already passed by x
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position to watch
	mZoneIndex				: UINT; // Index to be measured
END_VAR
VAR
	mTrackingPosition		: DINT; // Current position on tracking
	mZoneEndPosition		: DINT; // Zone end tracking position
	mDistanceAhead			: DINT; // Distance to zone ahead
	mDistanceAfter			: DINT; // Distance to zone after
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetDistanceToZoneEnd := 0;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

IF NOT ZoneTable[mZoneIndex].Used THEN
	RETURN;
END_IF

// Get position of observation point on tracking (=0)
mTrackingPosition := UDINT_TO_DINT(M_GetTrackingPosition(mAbsolutePosition));
mZoneEndPosition := UDINT_TO_DINT(ZoneTable[mZoneIndex].ZoneEndPosition);

// Calculate distance in both directions, Zone is ahead to observation point or after
mDistanceAhead := (mZoneEndPosition - mTrackingPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);
mDistanceAfter := (mTrackingPosition - mZoneEndPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);

// Definition range: Ahead = + / After = -
// Ahead = Max -1 -> Observation
// After = Observation -> Max
IF mDistanceAfter <= mDistanceAhead THEN
	M_GetDistanceToZoneEnd := mDistanceAfter * (-1);
ELSE
	M_GetDistanceToZoneEnd := mDistanceAhead;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetDistanceToZoneStart" Id="{e8fcc9a7-abdd-4e09-ba21-88371a6dc389}">
      <Declaration><![CDATA[/// Returns distance to begin of zone from observation point. 
/// Position 0 = observation point, Position Max = Observation point plus half tracking length.
/// Remark: In order to reduce the area use M_IsZoneInRange.
METHOD M_GetDistanceToZoneStart : DINT // Returns distance [mm] to zone start. x < 0 Zone has already passed by x
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position to watch
	mZoneIndex				: UINT; // Index to be measured
END_VAR
VAR
	mTrackingPosition		: DINT; // Current position on tracking
	mZoneStartPosition		: DINT; // Zone start tracking position
	mDistanceAhead			: DINT; // Distance to zone ahead
	mDistanceAfter			: DINT; // Distance to zone after
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetDistanceToZoneStart := 0;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES THEN
	RETURN;
END_IF

IF NOT ZoneTable[mZoneIndex].Used THEN
	RETURN;
END_IF

// Get position of observation point on tracking (=0)
mTrackingPosition := UDINT_TO_DINT(M_GetTrackingPosition(mAbsolutePosition));
mZoneStartPosition := UDINT_TO_DINT(ZoneTable[mZoneIndex].ZoneStartPosition);

// Calculate distance in both directions, Zone is ahead to observation point or after
mDistanceAhead := (mZoneStartPosition - mTrackingPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);
mDistanceAfter := (mTrackingPosition - mZoneStartPosition + UDINT_TO_DINT(TotalTrackingLength)) MOD UDINT_TO_DINT(TotalTrackingLength);

// Definition range: Ahead = + / After = -
// Ahead = Max -1 -> Observation
// After = Observation -> Max
IF mDistanceAfter <= mDistanceAhead THEN
	M_GetDistanceToZoneStart := mDistanceAfter * (-1);
ELSE
	M_GetDistanceToZoneStart := mDistanceAhead;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetFirstZoneIndex" Id="{e5e4973c-2e72-445e-8ad4-e263073a3f35}">
      <Declaration><![CDATA[/// Returns first zone index that can be found between start and end position, direction according windows ascending
/// REMARK: Size of area to be checked has influence to performance of method
METHOD M_GetFirstZoneIndex : UINT // Returns ZoneIndex > 0, otherwise 0
VAR_INPUT
	mAbsoluteStartPosition	: UDINT; // Start position on the tracking [mm]
	mAbsoluteEndPosition	: UDINT; // End position on the tracking [mm]
	mOnlyZonesWithTU		: BOOL; // Check only zones with physical TU
END_VAR
VAR
	mIdx					: UINT; // Iterator
	mStartWindowIndex		: UINT; // Window index at start position
	mEndWindowIndex			: UINT; // Window index at end position
	mWindowLength 			: UINT; // Length of are to be checked in windows
	mWindowIndex 			: UINT; // Window interator
	mTrackingPositionEnd	: UDINT; // Tracking position end
	mTrackingPositionStart	: UDINT; // Tracking position start
	mZoneIndex				: UINT; // Tracking zone index
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetFirstZoneIndex := 0;

// Get window index of window start position
mStartWindowIndex := M_GetWindowIndex(mAbsoluteStartPosition);
// Get window index of window end position
mEndWindowIndex := M_GetWindowIndex(mAbsoluteEndPosition);

// Remark:
// Absolute view is unequal to tracking view
// ABS:  500mm 505mm .....1000mm
//    Startpos			 EndPos
//       |                  |
//  --------------------------------------      FlowDirection ->
// Win:  54  53  52 ....  43 42 ...
// Window index of end is normally lower than start (except overflow)     

// Ensure both window index are in a valid range
IF mStartWindowIndex > 0 AND mStartWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS AND
   mEndWindowIndex > 0 AND mEndWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	
   	mTrackingPositionStart := M_GetTrackingPosition(mAbsoluteStartPosition);
   	mTrackingPositionEnd := M_GetTrackingPosition(mAbsoluteEndPosition);
   
	// Calculate windows to check
	IF mStartWindowIndex >= mEndWindowIndex THEN
		mWindowLength := mStartWindowIndex - mEndWindowIndex + 1;
	ELSE
		mWindowLength := mStartWindowIndex + MaxWindowIndex - mEndWindowIndex + 1;
	END_IF
	
	mWindowIndex := mStartWindowIndex;

	FOR mIdx := 1 TO mWindowLength DO
		mZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
		// Search for zone
		IF mZoneIndex > 0 THEN
			// If search is limited to physically occupied zone
			IF mOnlyZonesWithTU THEN
				// When the currently checked window is the start window (EndWindowIndex) of the checked
				// range and at the same time the rear edge of a TU, check exact position
				// in window
				IF mWindowIndex = mEndWindowIndex AND
				   WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
				   // Check exact position of zone end
				   IF WindowTable[mWindowIndex].TU_RearEdgePosition >= mTrackingPositionEnd THEN
					   M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When the currently checked window is the end window (StartWindowIndex) of the checked
				// range and at the same time the front edge of a TU, check exact position
				// in window
				ELSIF mWindowIndex = mStartWindowIndex AND
					  WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
					// Check exact position of zone end
				   IF WindowTable[mWindowIndex].TU_FrontEdgePosition <= mTrackingPositionStart THEN
					   M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When window is occupied, its completly part of the TU
				ELSIF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.OCCUPIED THEN
					// Check begin of zone
					M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					RETURN;
				END_IF
			ELSE
				// When the currently checked window is the start window (EndWindowIndex) of the checked
				// range and at the same time the end window of a zone, check exact position
				// in window
				IF mWindowIndex = mEndWindowIndex AND
				   mWindowIndex = ZoneTable[mZoneIndex].ZoneEndWindowIndex THEN
				   // Check exact position of zone end
				   IF ZoneTable[mZoneIndex].ZoneEndPosition >= mTrackingPositionEnd THEN
					   M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When the currently checked window is the end window (StartWindowIndex) of the checked
				// range and at the same time the start window of a zone, check exact position
				// in window
				ELSIF mWindowIndex = mStartWindowIndex AND
					  mWindowIndex = ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
					// Check exact position of zone end
				   IF ZoneTable[mZoneIndex].ZoneStartPosition <= mTrackingPositionStart THEN
					   M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// Otherwise the zone uses the whole window
				ELSE
					M_GetFirstZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					RETURN;
				END_IF
			END_IF
		END_IF	
		
		mWindowIndex := mWindowIndex - 1;
			
		// Correct border overflow
		IF mWindowIndex <= 0 THEN
			mWindowIndex := mWindowIndex + MaxWindowIndex;
		END_IF
	END_FOR
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetLastZoneIndex" Id="{3226c821-2878-49c4-89bd-6e7e6a3b3a33}">
      <Declaration><![CDATA[/// Returns last zone index that can be found between start and end position, direction according windows ascending
/// REMARK: Size of area to be checked has influence to performance of method
METHOD M_GetLastZoneIndex : UINT // Returns ZoneIndex > 0, otherwise 0
VAR_INPUT
	mAbsoluteStartPosition	: UDINT; // Start position on the tracking [mm]
	mAbsoluteEndPosition	: UDINT; // End position on the tracking [mm]
	mOnlyZonesWithTU		: BOOL; // Check only zones with physical TU in range
END_VAR
VAR
	mIdx					: UINT; // Iterator
	mStartWindowIndex		: UINT; // Window index at start position
	mEndWindowIndex			: UINT; // Window index at end position
	mWindowLength 			: UINT; // Length of are to be checked in windows
	mWindowIndex 			: UINT; // Window interator
	mTrackingPositionEnd	: UDINT; // Tracking position end
	mTrackingPositionStart	: UDINT; // Tracking position start
	mZoneIndex				: UINT; // Tracking zone index
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetLastZoneIndex := 0;

// Get window index of window start position
mStartWindowIndex := M_GetWindowIndex(mAbsoluteStartPosition);
// Get window index of window end position
mEndWindowIndex := M_GetWindowIndex(mAbsoluteEndPosition);

// Remark:
// Absolute view is unequal to tracking view
// ABS:  500mm 505mm .....1000mm
//    Startpos			 EndPos
//       |                  |
//  --------------------------------------      FlowDirection ->
// Win:  54  53  52 ....  43 42 ...
// Window index of end is normally lower than start (except overflow)     

// Ensure both window index are in a valid range
IF mStartWindowIndex > 0 AND mStartWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS AND
   mEndWindowIndex > 0 AND mEndWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	
	mTrackingPositionStart := M_GetTrackingPosition(mAbsoluteStartPosition);
   	mTrackingPositionEnd := M_GetTrackingPosition(mAbsoluteEndPosition);
   
	// Calculate windows to check
	IF mStartWindowIndex >= mEndWindowIndex THEN
		mWindowLength := mStartWindowIndex - mEndWindowIndex + 1;
	ELSE
		mWindowLength := mStartWindowIndex + MaxWindowIndex - mEndWindowIndex + 1;
	END_IF
	
	mWindowIndex := mEndWindowIndex;

	FOR mIdx := 1 TO mWindowLength DO
		mZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
		// Search for zone
		IF mZoneIndex > 0 THEN
			// If search is limited to physically occupied zone
			IF mOnlyZonesWithTU THEN
				// When the currently checked window is the start window (EndWindowIndex) of the checked
				// range and at the same time the rear edge of a TU, check exact position
				// in window
				IF mWindowIndex = mEndWindowIndex AND
				   WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
				   // Check exact position of zone end
				   IF WindowTable[mWindowIndex].TU_RearEdgePosition  >= mTrackingPositionEnd THEN
					   M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When the currently checked window is the end window (StartWindowIndex) of the checked
				// range and at the same time the front edge of a TU, check exact position
				// in window
				ELSIF mWindowIndex = mStartWindowIndex AND
					  WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
					// Check exact position of zone end
				   IF WindowTable[mWindowIndex].TU_FrontEdgePosition  <= mTrackingPositionStart THEN
					   M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When window is occupied, its completly part of the TU
				ELSIF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.OCCUPIED THEN
					// Check begin of zone
					M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					RETURN;
				END_IF
			ELSE
				// When the currently checked window is the start window (EndWindowIndex) of the checked
				// range and at the same time the end window of a zone, check exact position
				// in window
				IF mWindowIndex = mEndWindowIndex AND
				   mWindowIndex = ZoneTable[mZoneIndex].ZoneEndWindowIndex THEN
				   // Check exact position of zone end
				   IF ZoneTable[mZoneIndex].ZoneEndPosition >= mTrackingPositionEnd THEN
					   M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// When the currently checked window is the end window (StartWindowIndex) of the checked
				// range and at the same time the start window of a zone, check exact position
				// in window
				ELSIF mWindowIndex = mStartWindowIndex AND
					  mWindowIndex = ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
					// Check exact position of zone end
				   IF ZoneTable[mZoneIndex].ZoneStartPosition <= mTrackingPositionStart THEN
					   M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					   RETURN;
				   END_IF
				   
				// Otherwise the zone uses the whole window
				ELSE
					M_GetLastZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					RETURN;
				END_IF
			END_IF
		END_IF	
		
		mWindowIndex := mWindowIndex + 1;
			
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetPendingAssignments" Id="{a85c7b51-02a3-4bd6-bc9a-d5e2d24a16e8}">
      <Declaration><![CDATA[/// Searches through all available zones and add all zone index of ActionId to pData
/// Remark: Amount of available zones has influence to performance.
/// Remark: Existing entries in pData get overwritten.
METHOD M_GetPendingAssignments : BOOL // Returns true if all found zones could be added to pData, otherwise false
VAR_INPUT
	mActionId				: INT; // ID of action which requests zone (<>0)
	mpData 					: POINTER TO UINT; // Address of Value or Array to store the result
	mDataLen				: UINT; // Size of data
END_VAR
VAR_OUTPUT
	mCount					: UINT; // Number of entries added to pData
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mZoneIndex				: UINT; // Zone index
	mZoneCounter 			: INT; // Amount of already considerd zones
	mPendingAssignments 	: UINT; // Pending assignments for action id
	mMaxEntries				: UINT; // Max possible entries in offered pData
	mStepSize				: UINT; // Step size between two indexes
	mErrorNoFreeData 		: BOOL; // Error, was not able to add found index to pData
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetPendingAssignments := 0;
mZoneIndex := 0;
mCount := 0;
mErrorNoFreeData := FALSE;

// Validate inputs
IF mActionId = 0 OR
   mpData = 0 OR
   mDataLen = 0 THEN
	RETURN;
END_IF

// Abort if no zones available at all
IF ZoneCount = 0 THEN
	M_GetPendingAssignments := 0;
	RETURN;
END_IF

// Calculate max amount of entries that can be assigned of pData
mStepSize := SIZEOF(UINT);
mMaxEntries := mDataLen / mStepSize;

// Clear existing entries
MEMSET(mpData, 0, mDataLen);

mZoneCounter := 0;
mPendingAssignments := 0;

// Check all allocated zones for action id
// Remark: As a reason of performance no scan through all windows upstream is initiated.
FOR mIdx := 1 TO WindowTracking.MAX_NUMBER_OF_ZONES DO
	// When all zones are considered, stop,
	IF mZoneCounter >= ZoneCount THEN
		EXIT;
		
	// Only enabled zones are considered
	ELSIF ZoneTable[mIdx].Used THEN
		// Only empty zones are considered 
		IF NOT ZoneTable[mIdx].TU_Present THEN
			// A zone candidate needs to have required action id
			IF ZoneTable[mIdx].ActionId = mActionId THEN
				// Ensure available memory has still space to be allocated
      			IF mPendingAssignments < mMaxEntries THEN
					// Update value and recalculate next position in pData
					mpData^:= mIdx;
					mpData := mpData + mStepSize;
			
					mPendingAssignments := mPendingAssignments + 1;
				ELSE
					mErrorNoFreeData := TRUE;
					EXIT;
				END_IF
			END_IF
		END_IF
		
		mZoneCounter := mZoneCounter + 1;
	END_IF	
END_FOR

mCount := mPendingAssignments;
M_GetPendingAssignments := NOT mErrorNoFreeData;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetTrackingPosition" Id="{451239b8-aecc-4af8-8dcd-79ac997b0c57}">
      <Declaration><![CDATA[/// Converts an absolute position into the current position on the tracking
METHOD M_GetTrackingPosition : UDINT // Converted position on tracking [mm]
VAR_INPUT
	mAbsolutePosition	: UDINT; // Absolute position 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF TrackingPosition > mAbsolutePosition THEN
	M_GetTrackingPosition := (TrackingPosition - mAbsolutePosition) MOD TotalTrackingLength;
ELSE
	M_GetTrackingPosition := (TrackingPosition + TotalTrackingLength - mAbsolutePosition) MOD TotalTrackingLength;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetTU_EndPosition" Id="{5069c6a2-a844-47af-bbcc-81246e106620}">
      <Declaration><![CDATA[/// Returns TU end position of a zone on tracked distance
/// Remark: User needs to make sure zone is valid
/// Remark: When no TU available the return value is 0, but is notfied with output "NoTuAvailable"
METHOD M_GetTU_EndPosition : UDINT // Returns position of TU end [mm]
VAR_INPUT
	mZoneIndex			: UINT; // Index of zone
END_VAR
VAR_OUTPUT
	mNoTU_Available		: BOOL; // No TU Available
END_VAR
VAR
	mEndWindowIndex		: UINT; // Zone end window index
	mPositionOnTracking	: UDINT; // Position on tracking length
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetTU_EndPosition := 0;
mNoTU_Available := FALSE;
mEndWindowIndex := 0;

// Get window index from zone table
IF mZoneIndex > 0 AND mZoneIndex <= MAX_NUMBER_OF_ZONES THEN
	IF ZoneTable[mZoneIndex].TU_Present THEN
		mEndWindowIndex := ZoneTable[mZoneIndex].TU_EndWindowIndex;
	ELSE
		mNoTU_Available := TRUE;
		RETURN;
	END_IF
END_IF

// Check if window index was found
IF mEndWindowIndex > 0 THEN
	// Get position on tracking
	mPositionOnTracking := (TrackingPosition MOD TotalTrackingLength);
	
	IF WindowTable[mEndWindowIndex].TU_RearEdgePosition < mPositionOnTracking THEN
		M_GetTU_EndPosition := mPositionOnTracking - WindowTable[mEndWindowIndex].TU_RearEdgePosition;
	ELSE
		M_GetTU_EndPosition := mPositionOnTracking - WindowTable[mEndWindowIndex].TU_RearEdgePosition + TotalTrackingLength;
	END_IF
ELSE
	;// Window not found
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetTU_StartPosition" Id="{8035e856-6be3-441a-b14c-2028d644d3c8}">
      <Declaration><![CDATA[/// Returns TU start position of a zone on tracked distance
/// Remark: User needs to make sure zone is valid
/// Remark: When no TU available the return value is 0, but is notfied with output "NoTuAvailable"
METHOD M_GetTU_StartPosition : UDINT // Start position of TU [mm]
VAR_INPUT
	mZoneIndex			: UINT; // Index of zone
END_VAR
VAR_OUTPUT
	mNoTU_Available		: BOOL; // No TU Available
END_VAR
VAR
	mStartWindowIndex	: UINT; // Zone end window index
	mPositionOnTracking	: UDINT; // Position on tracking length
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetTU_StartPosition := 0;
mStartWindowIndex := 0;
mNoTU_Available := FALSE;

// Get window index from zone table
IF mZoneIndex > 0 AND mZoneIndex <= MAX_NUMBER_OF_ZONES THEN
	IF ZoneTable[mZoneIndex].TU_Present THEN
		mStartWindowIndex := ZoneTable[mZoneIndex].TU_StartWindowIndex;
	ELSE
		mNoTU_Available := TRUE;
		RETURN;
	END_IF
END_IF

// Check if window index was found
IF mStartWindowIndex > 0 THEN
	// Get position on tracking
	mPositionOnTracking := (TrackingPosition MOD TotalTrackingLength);
	
	IF WindowTable[mStartWindowIndex].TU_FrontEdgePosition < mPositionOnTracking THEN
		M_GetTU_StartPosition := mPositionOnTracking - WindowTable[mStartWindowIndex].TU_FrontEdgePosition;
	ELSE
		M_GetTU_StartPosition := mPositionOnTracking - WindowTable[mStartWindowIndex].TU_FrontEdgePosition + TotalTrackingLength;
	END_IF
ELSE
	;// Window not found
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetWindowIndex" Id="{db807389-4f66-4298-9fcc-481d457369df}">
      <Declaration><![CDATA[/// Returns window index of an abolsute position
METHOD M_GetWindowIndex : UINT // Returns the Index of the Window if successful, otherwise 0 = No window
VAR_INPUT
	mAbsolutePosition	: UDINT; // Position on the tracking [mm]
END_VAR
VAR
	mTrackingPosition	: UDINT; // Current position on tracking
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Translate absolute position into position on tracking
mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);

IF WindowSize > 0 THEN
	M_GetWindowIndex := UDINT_TO_UINT(mTrackingPosition / WindowSize + 1);
ELSE
	M_GetWindowIndex := 0;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetZoneEndPosition" Id="{ab871644-5af0-4f5b-a7e8-1e55b88d127a}">
      <Declaration><![CDATA[/// Returns position of Zone end on tracked distance
/// Remark: User needs to make sure zone is valid
METHOD M_GetZoneEndPosition : UDINT // Position of Zone end [mm]
VAR_INPUT
	mZoneIndex			: UINT; // Index of zone
END_VAR
VAR
	mEndWindowIndex		: UINT; // Zone end window index
	mPositionOnTracking	: UDINT; // Position on tracking length
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetZoneEndPosition := 0;
mEndWindowIndex := 0;

// Check inputs
IF mZoneIndex = 0 THEN
	RETURN;
END_IF

// Get window index from zone table
IF mZoneIndex > 0 AND mZoneIndex <= MAX_NUMBER_OF_ZONES THEN
	mEndWindowIndex := ZoneTable[mZoneIndex].ZoneEndWindowIndex;
END_IF

// Check if window index was found
IF mEndWindowIndex > 0 THEN
	// Get position on tracking
	mPositionOnTracking := (TrackingPosition MOD TotalTrackingLength);
	
	IF ZoneTable[mZoneIndex].ZoneEndPosition < mPositionOnTracking THEN
		M_GetZoneEndPosition := mPositionOnTracking - ZoneTable[mZoneIndex].ZoneEndPosition;
	ELSE
		M_GetZoneEndPosition := mPositionOnTracking - ZoneTable[mZoneIndex].ZoneEndPosition + TotalTrackingLength;
	END_IF
ELSE
	;// Window not found
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetZoneIndex" Id="{e7409bb3-72bd-4e6d-9217-37f942d4a3bb}">
      <Declaration><![CDATA[/// Returns ZoneIndex at AbsolutePosition
METHOD M_GetZoneIndex : UINT // Returns ZoneIndex > 0, otherwise 0
VAR_INPUT
	mAbsolutePosition	: UDINT; // Position on the tracking [mm]
END_VAR
VAR
	mWindowIndex		: UINT; // Window index at position
	mZoneIndex			: UINT; // Zone index of window
	mTrackingPosition	: UDINT; // Abs position on tracking
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetZoneIndex := 0;

// Get window index of window position
mWindowIndex := M_GetWindowIndex(mAbsolutePosition);

// Return zone index
IF mWindowIndex > 0 AND mWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	mZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
	
	IF mZoneIndex > 0 THEN
		mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);
		// When zone is allocated not over overflow position, range can be checked normally
		IF ZoneTable[mZoneIndex].ZoneEndPosition >= ZoneTable[mZoneIndex].ZoneStartPosition THEN
			// When requested tracking position is between start and end zone
			IF mTrackingPosition >= ZoneTable[mZoneIndex].ZoneStartPosition AND
			   mTrackingPosition <= ZoneTable[mZoneIndex].ZoneEndPosition THEN
			   M_GetZoneIndex := mZoneIndex;
			END_IF
			
		// When zone allocation is over overflow position, this needs to be considered
		ELSE
			// If request is between zone start and total tracking length
			IF mTrackingPosition >= ZoneTable[mZoneIndex].ZoneStartPosition THEN
				// Consider overflow and check range
				IF mTrackingPosition >= ZoneTable[mZoneIndex].ZoneStartPosition AND
				   mTrackingPosition <= (ZoneTable[mZoneIndex].ZoneStartPosition + ZoneTable[mZoneIndex].ZoneLength) THEN
				   M_GetZoneIndex := mZoneIndex;
				END_IF
				
			// Otherwise request was between tracking 0 to zone end
			ELSIF mTrackingPosition <= ZoneTable[mZoneIndex].ZoneEndPosition THEN
				// Correct request point upwards (Because of unsigned value)
				mTrackingPosition := mTrackingPosition + TotalTrackingLength;
			
				// Consider overflow and check range
				IF mTrackingPosition >= ZoneTable[mZoneIndex].ZoneStartPosition AND
				   mTrackingPosition <= (ZoneTable[mZoneIndex].ZoneStartPosition + ZoneTable[mZoneIndex].ZoneLength) THEN
				   M_GetZoneIndex := mZoneIndex;
				END_IF
			END_IF
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetZoneStartPosition" Id="{23a80f7e-32e9-48d6-b83e-a5e9a1e01229}">
      <Declaration><![CDATA[/// Returns position of Zone start on tracked distance
/// Remark: User needs to make sure zone is valid
METHOD M_GetZoneStartPosition : UDINT // Position of Zone start [mm]
VAR_INPUT
	mZoneIndex			: UINT; // Index of zone
END_VAR
VAR
	mStartWindowIndex	: UINT; // Zone end window index
	mPositionOnTracking	: UDINT; // Position on tracking length
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetZoneStartPosition := 0;
mStartWindowIndex := 0;

// Check inputs
IF mZoneIndex = 0 THEN
	RETURN;
END_IF

// Get window index from zone table
IF mZoneIndex > 0 AND mZoneIndex <= MAX_NUMBER_OF_ZONES THEN
	mStartWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
END_IF

// Check if window index was found
IF mStartWindowIndex > 0 THEN
	// Get position on tracking
	mPositionOnTracking := (TrackingPosition MOD TotalTrackingLength);
	
	IF ZoneTable[mZoneIndex].ZoneStartPosition < mPositionOnTracking THEN
		M_GetZoneStartPosition := mPositionOnTracking - ZoneTable[mZoneIndex].ZoneStartPosition;
	ELSE
		M_GetZoneStartPosition := mPositionOnTracking - ZoneTable[mZoneIndex].ZoneStartPosition + TotalTrackingLength;
	END_IF
ELSE
	;// Window not found
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InhibitShifting" Id="{26a226be-b2de-4cf9-b49b-40059a703657}">
      <Declaration><![CDATA[/// Inhibits shifting on a specific zone
METHOD M_InhibitShifting : BOOL // Returns true if successfully, otherwise false (e.g. Zone not found or not in use)
VAR_INPUT
	mZoneIndex		: UINT; // Zone index
	mInhibit		: BOOL; // True = Inhibit shifting
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_InhibitShifting := FALSE;

// Get window index from zone table
IF mZoneIndex > 0 AND mZoneIndex <= MAX_NUMBER_OF_ZONES THEN
	IF ZoneTable[mZoneIndex].Used THEN
		ZoneTable[mZoneIndex].InhibitShifting := mInhibit;
		M_InhibitShifting := TRUE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{31e6e445-2730-4f9c-9aab-9f9a8eda721c}">
      <Declaration><![CDATA[// Initialize module - (e.g. calculates parameters)
// Remark: Does not delete anything on the tracking
METHOD M_Init : BOOL // Returns true if successful, otherwise false
VAR_INPUT
	mWindowSize				: UINT; // Size of windows [mm] Remark: Needs to be smaller than smallest transport unit
	mTrackingLength			: UDINT; // Length of tracking segment [mm] (e.g. conveyor length)
	mCurrentEncoderValue	: UDINT; // Current encoder value [inc]
	mMaxEncoderValueInc		: UDINT; // Max value of input "EncoderValue" [increments] Remark: Used to detect overflow
	mRateIncPerMM			: LREAL; // Ratio - How many increments represent one mm
	miEventListener			: I_WindowTrackingListener; // Tracking zone listener (0 = not used)
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_Init := FALSE;
Initialized := FALSE;

// Validate inputs
IF mWindowSize = 0 OR
   mTrackingLength = 0 OR 
   mRateIncPerMM = 0 OR 
   mMaxEncoderValueInc = 0 THEN
   RETURN;
END_IF

WindowSize := mWindowSize;
TrackingLength := mTrackingLength;
iEventListener := miEventListener;
RateIncPerMM := mRateIncPerMM;
MaxEncoderValueInc := mMaxEncoderValueInc;

TotalTrackingLength := M_CalculateTotalTrackingLength(
							 mTrackingLength 	:= TrackingLength,
							 mTrackingAddition 	:= TrackingAddition,
							 mWindowSize 		:= WindowSize);

MaxWindowIndex := UDINT_TO_UINT(TotalTrackingLength / WindowSize);

// Set start value
LastEncoderValueInc := mCurrentEncoderValue;

// Check window borders
IF MaxWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	Initialized := TRUE;						 
	M_Init := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InsertNewZoneIndex" Id="{948b1b40-460d-43fd-a302-f458265185cb}">
      <Declaration><![CDATA[// Allocates a new zone slot and returns index
METHOD PROTECTED M_InsertNewZoneIndex : UINT // Returns zone index
VAR
	mIdx	: UINT; // Loop iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Search free zone index
FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
	IF NOT ZoneTable[mIdx].Used THEN
		// Initialize Zone
		MEMSET(ADR(ZoneTable[mIdx]), 0, SIZEOF(ZoneTable[mIdx]));
		
		ZoneTable[mIdx].Used := TRUE;

		ZoneCount := ZoneCount + 1;	
	
		M_InsertNewZoneIndex := mIdx;
		RETURN;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsShiftable" Id="{7beaad1c-246f-428e-8dbe-ae6759d8f438}">
      <Declaration><![CDATA[/// Checks wheter a shift is possible or not
METHOD PROTECTED M_IsShiftable : BOOL // Returns true if possible, otherwise false
VAR_INPUT
	mStartWindowIndex		: UINT; // Start window index of a zone to be shifted
	mWindowsToShift			: UINT; // Windows to shift
	mExcludeTUs				: BOOL; // Exclude physical occupied zones, otherwise shifting will fail due to a physical TU
	mAllowOverrun			: BOOL; // Allow to throw out zones which cannot be place on the tracking anymore because of reallocations
END_VAR
VAR_OUTPUT
	mZoneOverrun			: BOOL; // Overrun happening, zones availale which could not be placed on tracking
	mZoneOverrunWindowIndex	: UINT; // Window index where overrun started
END_VAR
VAR_IN_OUT
	mfbRelocator 			: FB_WindowRelocator; // Windows relocator
END_VAR
VAR_INST
	ResStartWindowIndex		: UINT; // Start window index where clean up starts
	MinShiftWindowIndex		: UINT; // Minimum window index until space has to be free 
	ResWindowsToShift		: UINT; // Result how many windows to be shifted 
	RemainingWindowLength 	: INT; // Remaining length on tracking, before reaching startpoint [windows]
	RelocScheduled 			: BOOL; // Reallocation processed successfully
	BlockingZoneIndex 		: UINT; // Index of a zone which was not permitted to be shifted (e.g. with physical TU inside)
	BlockingEndWindowIndex 	: UINT; // Last window index of blocking zone
	ErrorId 				: UINT; // Error id of reallocation process
	StartTrackingPosition	: UDINT; // Start position on tracking
	WindowsFromBegin		: UINT; // Amount of windows from beginning to the start position
	WindowsTrackingLength	: UINT; // Tracking length + Addition as windows
END_VAR
VAR
	mWindowIndex			: UINT; // Window index iterator
	mIdx 					: DINT; // Loop iterator
	mWindowLengthBlocking 	: UINT; // Length [windows] from start position to end of blocking zone
	mNextTargetWindow 		: UINT; // Next window index, where a Zone should be moved to
	mWindowLength 			: UINT; // Length [windows] of a zone
	mZoneIndexReloc 		: UINT; // Index of zone which should be reallocated
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsShiftable := FALSE;
mZoneOverrun := FALSE;
mZoneOverrunWindowIndex := 0;

// Validate inputs
IF mStartWindowIndex = 0 OR
   mStartWindowIndex > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   mWindowsToShift = 0 OR
   mWindowsToShift > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   WindowSize = 0 THEN
	RETURN;
END_IF

// Check start window index for an already available zone
// If there is one found align start window index to the start window index of this zone
IF WindowTable[mStartWindowIndex].ZoneIndex > 0 THEN
	ResStartWindowIndex := ZoneTable[WindowTable[mStartWindowIndex].ZoneIndex].ZoneStartWindowIndex;
ELSE
	ResStartWindowIndex := mStartWindowIndex;
END_IF

// Calculate minimum window index which has to be free 
//                  |-------------->
// Window     53 | 52 | 51 | 50 | 49
MinShiftWindowIndex := mStartWindowIndex + mWindowsToShift;
	
// Correct window border overflow
IF MinShiftWindowIndex > MaxWindowIndex THEN
	MinShiftWindowIndex := MinShiftWindowIndex - MaxWindowIndex;
END_IF

// Calculate windows which need to be shifted
// - From Startindex of Zone at Position X to the minimum distance to free
IF mStartWindowIndex >= ResStartWindowIndex THEN
	ResWindowsToShift := mWindowsToShift + mStartWindowIndex - ResStartWindowIndex;
ELSE
	ResWindowsToShift := mWindowsToShift + (mStartWindowIndex + MaxWindowIndex) - ResStartWindowIndex;
END_IF
	
// Go through all windows which need to be shifted mandatory
// and try to schedule a reallocation after the shifting distance.
mWindowIndex := ResStartWindowIndex;
mNextTargetWindow := MinShiftWindowIndex;
	
// Calculate available space on tracking which can be used for reallocations

// When zones get deleted on tracking end, the remaining distance to move reserved zones
// is limited to the windows up to the absolute window positions and the trackinglength backwards.
// Therefore from all windows of a TrackingLength - Startwindow is the distance 
// to be removed from the allowed shifting distance.
StartTrackingPosition := M_GetTrackingPosition((mStartWindowIndex-1)*WindowSize);
WindowsFromBegin := UDINT_TO_UINT(StartTrackingPosition / WindowSize);
WindowsTrackingLength := UDINT_TO_UINT((TrackingLength + TrackingAddition) / WindowSize);

IF WindowsFromBegin MOD WindowSize > 0 THEN
	WindowsFromBegin := WindowsFromBegin + 1;
END_IF

IF WindowsTrackingLength MOD WindowSize > 0 THEN
	WindowsTrackingLength := WindowsTrackingLength + 1;
END_IF

IF DeleteZoneTrackingEnd THEN	
	RemainingWindowLength := UINT_TO_INT(WindowsFromBegin) + UINT_TO_INT(WindowsTrackingLength) - UINT_TO_INT(ResWindowsToShift) - 1;
ELSE
	RemainingWindowLength := UINT_TO_INT(MaxWindowIndex) - UINT_TO_INT(ResWindowsToShift) - 1;
END_IF
	
FOR mIdx := 1 TO WindowTracking.MAX_NUMBER_OF_WINDOWS DO
	// Correct window border overflow
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
	
	IF mNextTargetWindow > MaxWindowIndex THEN
		mNextTargetWindow := mNextTargetWindow - MaxWindowIndex;
	END_IF
	
	// Relocation is done, if all zones in the shifting distance
	// and all interfering zones are relocated properly
	IF mIdx > ResWindowsToShift THEN
		M_IsShiftable := TRUE;
		EXIT;

	// If window is part of zone, try to schedule relocation
	ELSIF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
		// Calculate Window Length of Zone which should be relocated
		mZoneIndexReloc := WindowTable[mWindowIndex].ZoneIndex;
		
		IF ZoneTable[mZoneIndexReloc].TU_Present THEN
			// Skip all occupied zones, because they are not allowed for re-allocation, otherwise fail
			IF mExcludeTUs THEN
				mWindowIndex := mWindowIndex + 1;
				RemainingWindowLength := RemainingWindowLength - 1;
				CONTINUE;
			ELSE
				M_IsShiftable := FALSE;
				EXIT;
			END_IF
		END_IF

		IF ZoneTable[mZoneIndexReloc].ZoneEndWindowIndex > ZoneTable[mZoneIndexReloc].ZoneStartWindowIndex THEN
			mWindowLength := ZoneTable[mZoneIndexReloc].ZoneEndWindowIndex - ZoneTable[mZoneIndexReloc].ZoneStartWindowIndex + 1;
		ELSE
			mWindowLength := ZoneTable[mZoneIndexReloc].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[mZoneIndexReloc].ZoneStartWindowIndex + 1;
		END_IF

		// Check if reallocation would overwrite start point
		IF RemainingWindowLength - UINT_TO_INT(mWindowLength) > 0 THEN
			RelocScheduled := mfbRelocator.M_ScheduleRelocation(
									mZoneIndex				:= mZoneIndexReloc, 
									mTargetWindow			:= mNextTargetWindow, 
									mMaxWindowIndex			:= MaxWindowIndex, 
									mrWindowTable			:= WindowTable, 
									mrZoneTable				:= ZoneTable, 
									mBlockingZoneIndex		=> BlockingZoneIndex, 
									mBlockingEndWindowIndex => BlockingEndWindowIndex,
									mErrorId				=> ErrorId);
									
			// If relocation could be scheduled properly
			// set next window to the window after the relocated zone
			IF RelocScheduled THEN
				mNextTargetWindow := mNextTargetWindow + mWindowLength;
				
				// Adjust index of next window to check if relocation was successful
				mWindowIndex := mWindowIndex + mWindowLength;
				
				// Each found zone on the shifting distance requires one additional shift iteration
				// Because the location where it was moved to, may contains as well a zone which needs to be shifted
				ResWindowsToShift := ResWindowsToShift + 1;
				
				// Ensure that reallocation does not overwrite start point
				RemainingWindowLength := RemainingWindowLength - UINT_TO_INT(mWindowLength);
			ELSE
				// Relocation was not possible because of a Zone which is not allowed
				// to be shifted, try again with window after the blocking zone
				IF BlockingZoneIndex > 0 THEN
					// Each found zone on the shifting distance requires one additional shift iteration
					ResWindowsToShift := ResWindowsToShift + 1;
					
					// Calc length of blocking zone
					IF ZoneTable[BlockingZoneIndex].ZoneEndWindowIndex >= ZoneTable[BlockingZoneIndex].ZoneStartWindowIndex THEN
						mWindowLengthBlocking := ZoneTable[BlockingZoneIndex].ZoneEndWindowIndex - ZoneTable[BlockingZoneIndex].ZoneStartWindowIndex;
					ELSE
						mWindowLengthBlocking := ZoneTable[BlockingZoneIndex].ZoneEndWindowIndex + MaxWindowIndex - ZoneTable[BlockingZoneIndex].ZoneStartWindowIndex;
					END_IF
					
					mNextTargetWindow := BlockingEndWindowIndex + 1;
					
					RemainingWindowLength := RemainingWindowLength - UINT_TO_INT(mWindowLengthBlocking);
				END_IF
			END_IF
		ELSE
			// The found zone could not be placed on the tracking because there is no space left.
			// Mark overrun and leave
			mZoneOverrun := TRUE;
			mZoneOverrunWindowIndex := mWindowIndex;
			M_IsShiftable := mAllowOverrun;
			EXIT;
		END_IF
	ELSE
		mWindowIndex := mWindowIndex + 1;
		RemainingWindowLength := RemainingWindowLength - 1;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsTU_InRange" Id="{f9283e40-2538-4614-9dcf-907e141bb5fb}">
      <Declaration><![CDATA[/// Checks if a TU or a part of it, is found in a certain range.
METHOD M_IsTU_InRange : BOOL; // Returns true if present, otherwise false
VAR_INPUT
	mZoneIndex				: UINT; // Tracking zone index
	mAbsoluteStartRange		: UDINT; // Start range position on the tracking [mm]
	mAbsoluteEndRange		: UDINT; // End range position on the tracking [mm]
END_VAR
VAR
	mStartWindowIndex		: UINT; // Window index at start position
	mEndWindowIndex			: UINT; // Window index at end position
	mTrackingRangeEnd		: UDINT; // Tracking range position end
	mTrackingRangeStart		: UDINT; // Tracking range position start
	mTrackingTU_End			: UDINT; // Tracking range position end
	mTrackingTU_Start		: UDINT; // Tracking range position start
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsTU_InRange := FALSE;

// Check inputs
IF mZoneIndex = 0 THEN
	RETURN;
END_IF

IF NOT ZoneTable[mZoneIndex].TU_Present THEN
	RETURN;
END_IF

// Get window index of window start position
mStartWindowIndex := M_GetWindowIndex(mAbsoluteStartRange);
// Get window index of window end position
mEndWindowIndex := M_GetWindowIndex(mAbsoluteEndRange);

// Remark:
// Absolute view is unequal to tracking view
// ABS:  500mm 505mm .....1000mm
//   AbsStartpos		AbsEndPos
//       |                  |
//    TrackingEnd       TrackingStart
//
//  --------------------------------------      FlowDirection ->
// Win:  54  53  52 ....  43 42 ...
// Window index of end is normally lower than start (except overflow)     

// Ensure both window index are in a valid range
IF mStartWindowIndex > 0 AND mStartWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS AND
   mEndWindowIndex > 0 AND mEndWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	
	// Ensure that Zone consists of start and end tu window index
	IF ZoneTable[mZoneIndex].TU_StartWindowIndex > 0 AND
	   ZoneTable[mZoneIndex].TU_EndWindowIndex > 0 THEN
	   
		//    TrackingEnd       TrackingStart
		//         |-----------------|
		//  --------------------------------------      FlowDirection ->
	   	mTrackingTU_End := WindowTable[ZoneTable[mZoneIndex].TU_EndWindowIndex].TU_RearEdgePosition;
	   	mTrackingTU_Start :=  WindowTable[ZoneTable[mZoneIndex].TU_StartWindowIndex].TU_FrontEdgePosition;
	   
		//    TrackingRangeEnd  TrackingRangeStart
		//      |----------------------|
		//  --------------------------------------      FlowDirection ->
		mTrackingRangeEnd := M_GetTrackingPosition(mAbsoluteStartRange);
   		mTrackingRangeStart := M_GetTrackingPosition(mAbsoluteEndRange);
	   
		// When range does not consists of the overflow point
		IF mTrackingRangeEnd >= mTrackingRangeStart THEN 
			// Check if TU End edge is between range
			IF mTrackingTU_End >= mTrackingRangeStart AND
               mTrackingTU_End <= mTrackingRangeEnd THEN
				M_IsTU_InRange := TRUE;
				RETURN;
				
			// Check if TU start edge is between range
			ELSIF mTrackingTU_Start >= mTrackingRangeStart AND
                  mTrackingTU_Start <= mTrackingRangeEnd THEN
				M_IsTU_InRange := TRUE;
				RETURN;
				
			// Check if TU is overlapping full range
			ELSIF mTrackingTU_End >= mTrackingRangeEnd AND
                  mTrackingTU_Start <= mTrackingRangeStart THEN
				M_IsTU_InRange := TRUE;
				RETURN; 
			END_IF
		// If range is overlapping overflow point
		ELSE
			// Check if TU End edge is between range
			IF mTrackingTU_End >= mTrackingRangeStart OR  
               mTrackingTU_End <= mTrackingRangeEnd THEN
				M_IsTU_InRange := TRUE;
				RETURN;
				
			// Check if TU start edge is between range
			ELSIF mTrackingTU_Start >= mTrackingRangeStart OR  
               mTrackingTU_Start <= mTrackingRangeEnd THEN
				M_IsTU_InRange := TRUE;
				RETURN;
				
			// Check if TU is overlapping full range
			ELSIF mTrackingTU_End >= mTrackingRangeEnd AND
                  mTrackingTU_Start <= mTrackingRangeStart THEN
				M_IsTU_InRange := TRUE;
				RETURN; 
			END_IF
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsTU_Present" Id="{b714aff5-1e37-4620-96ee-24635cd48a86}">
      <Declaration><![CDATA[/// Returns if a physical TU is present at mAbsolutePosition
METHOD M_IsTU_Present : BOOL; // Returns true if present, otherwise false
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position on tracking length
END_VAR
VAR
	mWindowIndex			: UINT; // Window index at absolute position
	mTrackingPosition		: UDINT; // Current position on tracking
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsTU_Present := FALSE;

// Get window index of position
mWindowIndex := M_GetWindowIndex(mAbsolutePosition);

IF mWindowIndex > 0 AND mWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	// Get position on tracking
	mTrackingPosition := M_GetTrackingPosition(mAbsolutePosition);

	// Get TU state
	CASE WindowTable[mWindowIndex].State OF
		E_WindowTrackingWindowState.IDLE:
			M_IsTU_Present := FALSE;
			
		E_WindowTrackingWindowState.FRONT_EDGE:
			IF WindowTable[mWindowIndex].TU_FrontEdgePosition <= mTrackingPosition THEN
				M_IsTU_Present := TRUE;
			ELSE
				M_IsTU_Present := FALSE;
			END_IF
		
		E_WindowTrackingWindowState.REAR_EDGE:
			IF WindowTable[mWindowIndex].TU_RearEdgePosition > mTrackingPosition THEN
				M_IsTU_Present := TRUE;
			ELSE
				M_IsTU_Present := FALSE;
			END_IF
		
		E_WindowTrackingWindowState.OCCUPIED:
			M_IsTU_Present := TRUE;
	END_CASE
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsZoneInRange" Id="{07774e1c-639f-4c8c-b110-4045bb303043}">
      <Declaration><![CDATA[/// Checks if a zone or a part of it,  is found in a certain range.
METHOD M_IsZoneInRange : BOOL; // Returns true if zone is in range, otherwise false
VAR_INPUT
	mZoneIndex				: UINT; // Tracking zone index
	mAbsoluteStartRange		: UDINT; // Start range position on the tracking [mm]
	mAbsoluteEndRange		: UDINT; // End range position on the tracking [mm]
END_VAR
VAR
	mStartWindowIndex		: UINT; // Window index at start position
	mEndWindowIndex			: UINT; // Window index at end position
	mTrackingRangeEnd		: UDINT; // Tracking range position end
	mTrackingRangeStart		: UDINT; // Tracking range position start
	mTrackingZoneEnd		: UDINT; // Tracking range position zone end
	mTrackingZoneStart		: UDINT; // Tracking range position zone start
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsZoneInRange := FALSE;

// Check inputs
IF mZoneIndex = 0 THEN
	RETURN;
END_IF

// Get window index of window start position
mStartWindowIndex := M_GetWindowIndex(mAbsoluteStartRange);
// Get window index of window end position
mEndWindowIndex := M_GetWindowIndex(mAbsoluteEndRange);

// Remark:
// Absolute view is unequal to tracking view
// ABS:  500mm 505mm .....1000mm
//    Startpos			 EndPos
//       |                  |
//  --------------------------------------      FlowDirection ->
// Win:  54  53  52 ....  43 42 ...
// Window index of end is normally lower than start (except overflow)     

// Ensure both window index are in a valid range
IF mStartWindowIndex > 0 AND mStartWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS AND
   mEndWindowIndex > 0 AND mEndWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN

	// Ensure that Zone consists of start and end tu window index
	IF ZoneTable[mZoneIndex].TU_StartWindowIndex > 0 AND
	   ZoneTable[mZoneIndex].TU_EndWindowIndex > 0 THEN

		//    TrackingEnd       TrackingStart
		//         |-----------------|
		//  --------------------------------------      FlowDirection ->
	   	mTrackingZoneEnd := ZoneTable[mZoneIndex].ZoneEndPosition;
	   	mTrackingZoneStart := ZoneTable[mZoneIndex].ZoneStartPosition;

		//    TrackingRangeEnd  TrackingRangeStart
		//      |----------------------|
		//  --------------------------------------      FlowDirection ->
		mTrackingRangeEnd := M_GetTrackingPosition(mAbsoluteStartRange);
   		mTrackingRangeStart := M_GetTrackingPosition(mAbsoluteEndRange);

		// When range does not consists of the overflow point
		IF mTrackingRangeEnd >= mTrackingRangeStart THEN 
			// Check if TU End edge is between range
			IF mTrackingZoneEnd >= mTrackingRangeStart AND
               mTrackingZoneEnd <= mTrackingRangeEnd THEN
				M_IsZoneInRange := TRUE;
				RETURN;
				
			// Check if TU start edge is between range
			ELSIF mTrackingZoneStart >= mTrackingRangeStart AND
                  mTrackingZoneStart <= mTrackingRangeEnd THEN
				M_IsZoneInRange := TRUE;
				RETURN;
				
			// Check if TU is overlapping full range
			ELSIF mTrackingZoneEnd >= mTrackingRangeEnd AND
                  mTrackingZoneStart <= mTrackingRangeStart THEN
				M_IsZoneInRange := TRUE;
				RETURN; 
			END_IF
			
		// If range is overlapping overflow point
		ELSE
			// Check if TU End edge is between range
			IF mTrackingZoneEnd >= mTrackingRangeStart OR  
               mTrackingZoneEnd <= mTrackingRangeEnd THEN
				M_IsZoneInRange := TRUE;
				RETURN;
				
			// Check if TU start edge is between range
			ELSIF mTrackingZoneStart >= mTrackingRangeStart OR  
                  mTrackingZoneStart <= mTrackingRangeEnd THEN
				M_IsZoneInRange := TRUE;
				RETURN;
				
			// Check if TU is overlapping full range
			ELSIF mTrackingZoneEnd >= mTrackingRangeEnd AND
                  mTrackingZoneStart <= mTrackingRangeStart THEN
				M_IsZoneInRange := TRUE;
				RETURN; 
			END_IF
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MakeSpace" Id="{2fd2b491-b214-4398-855b-581cc663a1fa}">
      <Declaration><![CDATA[/// Tries to free a certain area by the following options (Shift, Shorten, Delete)
METHOD PROTECTED M_MakeSpace : BOOL // Returns true if successfully
VAR_INPUT
	mStartWindowIndex		: UINT; // Start window index
	mWindowsToFree			: UINT; // Windows to free up (e.g. 1 only clears start window index)
	mAllowZoneDelete		: BOOL; // Allows to delete zones if they could not be modified or reloacted
END_VAR
VAR_INST
	MinFreeWindowIndex		: UINT; // Minimum window index until space has to be free 
	ShiftZonesOk			: BOOL; // Shift was executed
END_VAR
VAR
	mIdx					: UINT; // Iteration
	mWindowIndex			: UINT; // Temp window index
	mZoneIndex				: UINT; // Zone index
	mTU_StartInArea			: BOOL; // TU start found in area
	mTU_EndInArea			: BOOL; // TU end found in area
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initialize
M_MakeSpace := FALSE;

// Validate inputs
IF mStartWindowIndex = 0 OR
   mStartWindowIndex > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   mWindowsToFree = 0 OR
   mWindowsToFree > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   WindowSize = 0 THEN
	RETURN;
END_IF

// Initialize for-loop values
mWindowIndex := mStartWindowIndex;

// Calculate minimum window index which has to be free 
// Example: Startwindow 49, windows to be free 4 (49, 50, 51, 52)
//                  |-------------->
// Window     53 | 52 | 51 | 50 | 49
MinFreeWindowIndex := mStartWindowIndex + mWindowsToFree - 1;
	
// Correct window border overflow
IF MinFreeWindowIndex > MaxWindowIndex THEN
	MinFreeWindowIndex := MinFreeWindowIndex - MaxWindowIndex;
END_IF

// Check for any occupied zone in the area to be free and test if it spossible to shorten or delete it
FOR mIdx := 1 TO mWindowsToFree DO	
	IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
		mZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
	
		// Zone can be modified by one of the following options
		// - If Occupied -> Shorten
		// - Else Delete if allowed
		IF ZoneTable[mZoneIndex].TU_Present THEN
			// Shorten
			// Check if position of TU inside the zone is outside of the area to be free
			IF MinFreeWindowIndex >= mStartWindowIndex THEN
				mTU_StartInArea := ZoneTable[mZoneIndex].TU_StartWindowIndex >= mStartWindowIndex AND
				   				   ZoneTable[mZoneIndex].TU_StartWindowIndex <= MinFreeWindowIndex;
				
				mTU_EndInArea := ZoneTable[mZoneIndex].TU_EndWindowIndex >= mStartWindowIndex AND
				   				 ZoneTable[mZoneIndex].TU_EndWindowIndex <= MinFreeWindowIndex;
				
			// Otherwise overflow between
			ELSE
				mTU_StartInArea := ZoneTable[mZoneIndex].TU_StartWindowIndex <= MinFreeWindowIndex OR
				   				   ZoneTable[mZoneIndex].TU_StartWindowIndex >= mStartWindowIndex;
				
				mTU_EndInArea := ZoneTable[mZoneIndex].TU_EndWindowIndex <= MinFreeWindowIndex OR
				   				 ZoneTable[mZoneIndex].TU_EndWindowIndex >= mStartWindowIndex;
			END_IF
			
			// TU Start or End is in area to be free
			IF mTU_StartInArea OR mTU_EndInArea THEN
				// Shorten not possible, check if delete is an option
				IF mAllowZoneDelete THEN
					// Ok
					;
				ELSE
					// Abort, shorten does not help
					M_MakeSpace := FALSE;
					RETURN;
				END_IF
			ELSE
				// Shorten is possible
				;
			END_IF
		END_IF
	END_IF
	
	mWindowIndex := mWindowIndex + 1;
	
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
END_FOR

// All occupied zones can be handled, try to shift 
ShiftZonesOk := M_ShiftZone(
					mStartWindowIndex,
					mWindowsToFree,
					TRUE,
					TRUE);

IF ShiftZonesOk THEN
	// First shorten zones at borders
	IF WindowTable[mStartWindowIndex].ZoneIndex > 0 THEN
		// If it consists of a TU
		IF ZoneTable[WindowTable[mStartWindowIndex].ZoneIndex].TU_Present THEN
			M_ShortenZoneAtWindow(
				WindowTable[mStartWindowIndex].ZoneIndex,
				mStartWindowIndex);
		END_IF
	END_IF

	IF WindowTable[MinFreeWindowIndex].ZoneIndex > 0 THEN
		// If it consists of a TU
		IF ZoneTable[WindowTable[MinFreeWindowIndex].ZoneIndex].TU_Present THEN
			M_ShortenZoneAtWindow(
				WindowTable[MinFreeWindowIndex].ZoneIndex,
				MinFreeWindowIndex);
		END_IF
	END_IF

	// Initialize loop
	mWindowIndex := mStartWindowIndex;
	
	// Execute TU operations
	FOR mIdx := 1 TO mWindowsToFree DO
		IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
			M_DeleteZone(WindowTable[mWindowIndex].ZoneIndex);
		END_IF
		
		mWindowIndex := mWindowIndex + 1;
	
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
	
	M_MakeSpace := TRUE;
END_IF

IF NOT M_MakeSpace THEN
	// Error
	fbDebugMsg.M_SendErrorMsg('M_MakeSpace - Make space requested, but could not successfully executed.');	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MakeSpaceByWindows" Id="{36390a8b-f894-42fb-9c3f-9b4a196075e7}">
      <Declaration><![CDATA[/// Tries to free a certain area by the following options (Shift, Shorten, Delete)
METHOD PROTECTED M_MakeSpaceByWindows : BOOL // Returns true if successfully
VAR_INPUT
	mAbsolutePosition		: UDINT; // Start position window index
	mWindowsToFree			: UINT; // Windows to free up (e.g. 1 only clears start window index)
	mAllowZoneDelete		: BOOL; // Allows to delete zones if they could not be modified or reloacted
END_VAR

VAR
	mPositionWindowIndex	: UINT; // Window of position
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MakeSpaceByWindows := FALSE;

// Validate inputs
IF WindowSize = 0 OR
   mWindowsToFree <= 0 THEN
	RETURN;
END_IF

mPositionWindowIndex := M_GetWindowIndex(mAbsolutePosition);

M_MakeSpaceByWindows := M_MakeSpace(
							mStartWindowIndex	:= mPositionWindowIndex, 
							mWindowsToFree		:= mWindowsToFree, 
							mAllowZoneDelete	:= mAllowZoneDelete);
							]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ManageOngoingTransfers" Id="{8207db95-1288-4ff9-9f2d-82b7de88802b}">
      <Declaration><![CDATA[/// Allocates windows for ongoing transfers onto the belt 
/// until transfer gets completed by M_AddTU_RearEdge
/// Remark: Zones found during that process are tried to be shifted, otherwise deleted
METHOD PROTECTED M_ManageOngoingTransfers
VAR
	mIdx 				: UINT; // Loop iterator
	mWindowIndex		: UINT; // Current window iterator
	mTransferZoneIndex 	: UINT; // Transfer zone index iterator
	mFreeOk				: BOOL; // Shift ok
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Handle ongoing transfers onto the tracking belt
FOR mIdx := 1 TO TRANSFER_TABLE_SIZE DO
	// Check if dataset is active
	IF OngoingTransferList[mIdx].Active THEN
		// Get window index
		mWindowIndex := M_GetWindowIndex(OngoingTransferList[mIdx].AbsoluteInsertPosition);
		// Check if window has changed since last time
		IF mWindowIndex <> OngoingTransferList[mIdx].LastWindowIndex THEN
			IF mWindowIndex > 0 AND mWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
				mTransferZoneIndex := OngoingTransferList[mIdx].ZoneIndex;
			
				// When a window gets overwritten which is already part of another zone, try to shift
				IF WindowTable[mWindowIndex].ZoneIndex > 0 AND
				   WindowTable[mWindowIndex].ZoneIndex <> mTransferZoneIndex THEN
					// Shift reserved zones
					mFreeOk := M_MakeSpaceByWindows(OngoingTransferList[mIdx].AbsoluteInsertPosition, 1, TRUE);
					
					// If not possible to shift, try to delete
					IF mFreeOk THEN
						DebugMsg := CONCAT('M_ManageOngoingTransfers - Could not free space. Zone: ',UINT_TO_STRING(WindowTable[mWindowIndex].ZoneIndex));
						fbDebugMsg.M_SendInfoMsg(DebugMsg);
					END_IF
				END_IF
				
				// A zone index needs to be available
				IF mTransferZoneIndex > 0 THEN
					// Update zone as currently end of TU, even this is not the last window to ensure always valid zone configuration
					// Otherwise it is unclear how many windows are part of a zone.
					WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.REAR_EDGE;
					WindowTable[mWindowIndex].TU_RearEdgePosition := mWindowIndex * WindowSize - 1;
					
					WindowTable[mWindowIndex].ZoneIndex := OngoingTransferList[mIdx].ZoneIndex;
					ZoneTable[mTransferZoneIndex].ZoneEndWindowIndex := mWindowIndex;
					ZoneTable[mTransferZoneIndex].TU_EndWindowIndex := mWindowIndex;
					ZoneTable[mTransferZoneIndex].ZoneEndPosition := mWindowIndex * WindowSize - 1;
					
					
					IF ZoneTable[mTransferZoneIndex].ZoneEndPosition >= ZoneTable[mTransferZoneIndex].ZoneStartPosition THEN
						ZoneTable[mTransferZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[mTransferZoneIndex].ZoneEndPosition 
																				   - ZoneTable[mTransferZoneIndex].ZoneStartPosition);
					ELSE
						ZoneTable[mTransferZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[mTransferZoneIndex].ZoneEndPosition 
																				  + TotalTrackingLength 
																				  - ZoneTable[mTransferZoneIndex].ZoneStartPosition);
					END_IF
					
					// When a last is available (Was last rear edge, update to occupied 
					IF OngoingTransferList[mIdx].LastWindowIndex > 0 THEN
						IF WindowTable[OngoingTransferList[mIdx].LastWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
							WindowTable[OngoingTransferList[mIdx].LastWindowIndex].State := E_WindowTrackingWindowState.OCCUPIED;
							WindowTable[OngoingTransferList[mIdx].LastWindowIndex].TU_RearEdgePosition := 0;
						END_IF
					END_IF
					
					// Update transfer list
					OngoingTransferList[mIdx].LastWindowIndex := mWindowIndex;
				ELSE
					// Error
					;
				END_IF
			END_IF
		END_IF	
	ELSE
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MonitorZonesPTL" Id="{2396352b-4deb-4781-bc82-8822c1c85676}">
      <Declaration><![CDATA[/// Monitors if one of the registered zones reach PTL, so they can be deleted
METHOD PROTECTED M_MonitorZonesPTL
VAR
	mIdx 				: UINT; // Loop iterator
	mPosition			: UDINT; // Current zone end position
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Handle ongoing ptl on the tracking distance
FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
	// Check if dataset is active
	IF PTL_Zones[mIdx] > 0 THEN		
		mPosition := M_GetZoneEndPosition(PTL_Zones[mIdx]);
		
		// Zone which consists of a TU or which are not valid anymore
		// get deleted from list, so they are not monitored anymore
		IF NOT ZoneTable[PTL_Zones[mIdx]].Used OR
		   ZoneTable[PTL_Zones[mIdx]].TU_Present THEN
			M_RemoveZoneFromPTL(PTL_Zones[mIdx]);
			
		// When the absolute position of zone end is reached, delete zone
		ELSIF mPosition > ZoneTable[PTL_Zones[mIdx]].PositionToLive AND mPosition < ZoneTable[PTL_Zones[mIdx]].PositionToLive + TrackingLength THEN
			M_DeleteZone(PTL_Zones[mIdx]);
		END_IF
	ELSE
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveZone" Id="{ddc345d4-ce37-4962-8074-84103112b9d9}">
      <Declaration><![CDATA[/// Moves all windows of a zone to another target window. (Possible edges are applied as before in the new window)
/// Remark: Possible zones at destination get shifted or deleted based on configuration if possible.
METHOD PROTECTED M_MoveZone : BOOL // Returns true if successfully moved, otherwise false (e.g. target consists of a non movable zone)
VAR_INPUT
	mZoneIndex				: UINT; // Zone index to move
	mTargetStartWindow 		: UINT; // Target start window index
	mEnableDeleteOfZones  	: BOOL; // Zones at target destination gets deleted if they can not be shifted or shortened
END_VAR

VAR
	mIdx 					: UINT; // Loop iterator
	mZoneWindowLength 		: UINT; // Length of zone to be moved
	mWindowIndex 			: UINT; // Iterator window index loop
	mBufferOk				: BOOL; // Command executed successfully
END_VAR

VAR_INST
	MovePossible			: BOOL;
	OldRelWindowPositionRE 	: UDINT; // Old relative window position rear edge
	OldRelWindowPositionFE 	: UDINT; // Old relative window position front edge
	OldRelZoneStartPosition : UDINT; // Old relative zone start position
	OldRelZoneEndPosition 	: UDINT; // Old relative zone end position
	fbWindowBuffer			: FB_MemRingBuffer; // Temporary storage of source windows
	WindowBuffer			: ARRAY[1..(MAX_MOVE_WINDOWS * SIZEOF(ST_WindowTrackingWindow))] OF BYTE; // Buffer storage
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MoveZone := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   mTargetStartWindow = 0 OR
   mTargetStartWindow > MaxWindowIndex  THEN
   RETURN;
END_IF

// Calculate length of zone to move [windows]
IF ZoneTable[mZoneIndex].ZoneEndWindowIndex > ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
	mZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
ELSE
	mZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex + MaxWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
END_IF


mWindowIndex := mTargetStartWindow;
MovePossible := TRUE;

IF NOT mEnableDeleteOfZones THEN
	// Clear target
	FOR mIdx := 1 TO mZoneWindowLength DO
		// Check if target is free or already part of the same zone
		IF WindowTable[mWindowIndex].ZoneIndex > 0 AND
		   WindowTable[mWindowIndex].ZoneIndex <> mZoneIndex THEN
		   
			// Make sure destination is free
			MovePossible := M_MakeSpace(
								mWindowIndex,
								1,
								mEnableDeleteOfZones);
								
			IF NOT MovePossible THEN
				EXIT;
			END_IF
		END_IF
		
		mWindowIndex := mWindowIndex + 1;
			
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
END_IF

// When target is clear to receive a zone
IF MovePossible THEN
	// Clear temporary window buffer
	fbWindowBuffer.A_Reset(
		pBuffer 	:= ADR(WindowBuffer), 
		cbBuffer 	:= SIZEOF(WindowBuffer));
	
	mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex; 
	
	// Source windows needs to be stored temporarly, because it is possible
	// that the new target is inside the existing window range.
	FOR mIdx := 1 TO mZoneWindowLength DO
		// Add existing window to buffer
		fbWindowBuffer.A_AddTail(
			pBuffer 	:= ADR(WindowBuffer), 
			cbBuffer 	:= SIZEOF(WindowBuffer), 
			pWrite 		:= ADR(WindowTable[mWindowIndex]), 
			cbWrite 	:= SIZEOF(WindowTable[mWindowIndex]));
			
		mBufferOk := fbWindowBuffer.bOk;
			
		// Clear source window
		M_ClearWindow(mWindowIndex);
		
		mWindowIndex := mWindowIndex + 1;
		
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
	
	// Copy source window to destination and update zone information
	mWindowIndex := mTargetStartWindow;
	
	FOR mIdx := 1 TO mZoneWindowLength DO
		// Copy window by window to target
		fbWindowBuffer.A_RemoveHead(
			pBuffer 	:= ADR(WindowBuffer), 
			cbBuffer 	:= SIZEOF(WindowBuffer), 
			pRead 		:= ADR(WindowTable[mWindowIndex]), 
			cbRead 		:= SIZEOF(WindowTable[mWindowIndex]));
		
		mBufferOk := fbWindowBuffer.bOk;
		
		// Update begin and end of zone
		IF mIdx = 1 THEN
			ZoneTable[mZoneIndex].ZoneStartWindowIndex := mWindowIndex;
			
		ELSIF mIdx = mZoneWindowLength THEN
			ZoneTable[mZoneIndex].ZoneEndWindowIndex := mWindowIndex;
		END_IF
		
		// When the moved window is marked as Front edge, update zone and position based on new window
		IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
			ZoneTable[mZoneIndex].TU_StartWindowIndex := mWindowIndex;
			OldRelWindowPositionFE := WindowTable[mWindowIndex].TU_FrontEdgePosition MOD WindowSize;
			WindowTable[mWindowIndex].TU_FrontEdgePosition := OldRelWindowPositionFE + (mWindowIndex-1) * WindowSize;
			
		// When the moved window is marked as Rear edge, update zone and position based on new window	
		ELSIF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN 
			ZoneTable[mZoneIndex].TU_EndWindowIndex := mWindowIndex;
			OldRelWindowPositionRE := WindowTable[mWindowIndex].TU_RearEdgePosition MOD WindowSize;
			WindowTable[mWindowIndex].TU_RearEdgePosition := OldRelWindowPositionRE + (mWindowIndex-1) * WindowSize;
		END_IF
		
		mWindowIndex := mWindowIndex + 1;
		
		// Correct border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
	END_FOR
	
	// Update zone start and end position to new windows
	OldRelZoneStartPosition := ZoneTable[mZoneIndex].ZoneStartPosition MOD WindowSize;
	OldRelZoneEndPosition := ZoneTable[mZoneIndex].ZoneEndPosition MOD WindowSize;
	
	ZoneTable[mZoneIndex].ZoneStartPosition := OldRelZoneStartPosition + (ZoneTable[mZoneIndex].ZoneStartWindowIndex-1) * WindowSize;
	ZoneTable[mZoneIndex].ZoneEndPosition := OldRelZoneEndPosition + (ZoneTable[mZoneIndex].ZoneEndWindowIndex-1) * WindowSize;
	
	// Inform listener
	IF iEventListener <> 0 THEN
		iEventListener.M_TrackingZoneMovedEvent(
			mTrackingZoneIndex 	:= mZoneIndex,
			mTrackingZoneData 	:= ZoneTable[mZoneIndex]);
	END_IF
	
	M_MoveZone := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveZoneFE" Id="{673d8e4e-a51f-4c1d-b999-0cc4b7b68e7b}">
      <Declaration><![CDATA[/// Moves all windows of a zone to another target window aligned on front edge.
/// Remark: Possible zones at destination get shifted or deleted based on configuration.
/// Remark: If a physical TU can be found at Target, move not possible
METHOD PROTECTED M_MoveZoneFE : BOOL // Returns true if successful moved, otherwise false 
VAR_INPUT
	mZoneIndex					: UINT; // Zone index to move
	mAbsoluteTargetPosition		: UDINT; // Absolute target position [mm]
	mDeleteTargetZones  		: BOOL; // Zones at target destination gets deleted, otherwise shifted
END_VAR

VAR
	mMoveOk						: BOOL; // Move to new window location was successful
	mFrontEdgeAdjusted			: BOOL; // Front edge successfull adjusted
END_VAR

VAR_INST
	WindowNumberFE 				: UINT; // Number of front edge window in zone
	TargetWindowIndex			: UINT; // Target window index
	TargetMoveWindowIndex		: UINT; // Target move window index
	ZoneWindowLength 			: UINT; // Length of zone to be moved
	EdgeWindowIndex				: UINT; // Edge window index of zone
	NewTrackingPosition			: UDINT; // New required tracking position
	OldZoneStartWindowIndex 	: UINT; // Old zone start window index (Rollback)
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MoveZoneFE := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   WindowSize = 0 THEN
   RETURN;
END_IF

// Get window index of target position
TargetWindowIndex := M_GetWindowIndex(mAbsoluteTargetPosition);
   
// Ensure window is valid and physically occupied
IF ZoneTable[mZoneIndex].TU_Present AND
   TargetWindowIndex > 0 AND TargetWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
   
	// Calculate length of zone in windows
	IF ZoneTable[mZoneIndex].ZoneEndWindowIndex > ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		ZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		ZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
	
	// Store front edge and position of it in zone
	EdgeWindowIndex := ZoneTable[mZoneIndex].TU_StartWindowIndex;
	
	IF EdgeWindowIndex >= ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		WindowNumberFE := EdgeWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		WindowNumberFE := EdgeWindowIndex + MaxWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
	
	// If an edge is available
	IF EdgeWindowIndex > 0 THEN
		IF TargetWindowIndex >= WindowNumberFE THEN
			TargetMoveWindowIndex := TargetWindowIndex - WindowNumberFE + 1;
		ELSE
			TargetMoveWindowIndex := TargetWindowIndex + MaxWindowIndex - WindowNumberFE + 1;
		END_IF
		
		// Store old window index for a possible rollback
		OldZoneStartWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
		
		// Move zone to target
		mMoveOk := M_MoveZone(
						mZoneIndex 				:= mZoneIndex,
						mTargetStartWindow 		:= TargetMoveWindowIndex,
						mEnableDeleteOfZones 	:= FALSE);	
		
		// If zone could be moved to new location, 
		IF mMoveOk THEN
			NewTrackingPosition := M_GetTrackingPosition(mAbsoluteTargetPosition);
			
			// try to adapt edge position changes (Front edge and rear edge)
			mFrontEdgeAdjusted := M_AdjustFE(
									mWindowIndexFE 			:= TargetWindowIndex,
									mNewTrackingPosition 	:= NewTrackingPosition,
									mDeleteTargetZones 		:= mDeleteTargetZones);
		
			IF mFrontEdgeAdjusted THEN
				// Move successful
				M_MoveZoneFE := TRUE;
			
			// Edge could not be aligned -> Rollback and abort		
			ELSE
				mMoveOk := M_MoveZone(
							mZoneIndex 				:= mZoneIndex,
							mTargetStartWindow 		:= OldZoneStartWindowIndex,
							mEnableDeleteOfZones 	:= FALSE);
							
				IF NOT mMoveOk THEN
					// Error during rollback
					;
				END_IF
				
				M_MoveZoneFE := FALSE;
			END_IF		
											
		// Move was not possible -> Abort						
		ELSE
			M_MoveZoneFE := FALSE;
		END_IF	
		
	// Otherwise no front edge window found
	ELSE
		M_MoveZoneFE := FALSE;
	END_IF
// Zone not valid 
ELSE
	M_MoveZoneFE := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveZoneRE" Id="{d8d325ed-3e2d-46c7-b7bf-52757b03c146}">
      <Declaration><![CDATA[/// Moves all windows of a zone to another target window aligned on rear edge.
/// Remark: Possible zones at destination get shifted or deleted based on configuration.
/// Remark: If a physical TU can be found at Target, move not possible
METHOD PROTECTED M_MoveZoneRE : BOOL // Returns true if successful moved, otherwise false 
VAR_INPUT
	mZoneIndex					: UINT; // Zone index to move
	mAbsoluteTargetPosition		: UDINT; // Absolute target position [mm]
	mDeleteTargetZones  		: BOOL; // Zones at target destination gets deleted, otherwise shifted
END_VAR

VAR
	mMoveOk						: BOOL; // Move to new window location was successful
	mRearEdgeAdjusted			: BOOL; // Rear edge adjusted successfully
END_VAR

VAR_INST
	TargetWindowIndex			: UINT; // Target window index
	TargetMoveWindowIndex		: UINT; // Target move window index
	ZoneWindowLength 			: UINT; // Length of zone to be moved
	EdgeWindowIndex				: UINT; // Edge window index of zone
	WindowNumberRE 				: UINT; // Number of window in zone
	NewTrackingPosition			: UDINT; // new required tracking position
	OldZoneStartWindowIndex 	: UINT; // Old zone start window index (Rollback)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_MoveZoneRE := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   WindowSize = 0 THEN
   RETURN;
END_IF

// Get window index of target position
TargetWindowIndex := M_GetWindowIndex(mAbsoluteTargetPosition);
   
// Ensure window is valid and physically occupied
IF ZoneTable[mZoneIndex].TU_Present AND
   TargetWindowIndex > 0 AND TargetWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN 
	// Calculate length of zone in windows
	IF ZoneTable[mZoneIndex].ZoneEndWindowIndex > ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		ZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		ZoneWindowLength := ZoneTable[mZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[mZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
	
	// Store rear edge and position of it in zone
	EdgeWindowIndex := ZoneTable[mZoneIndex].TU_EndWindowIndex;
	
	IF EdgeWindowIndex >= ZoneTable[mZoneIndex].ZoneEndWindowIndex THEN
		WindowNumberRE := EdgeWindowIndex - ZoneTable[mZoneIndex].ZoneEndWindowIndex + 1;
	ELSE
		WindowNumberRE := EdgeWindowIndex + MaxWindowIndex - ZoneTable[mZoneIndex].ZoneEndWindowIndex + 1;
	END_IF
	
	// If an rear edge was found
	IF EdgeWindowIndex > 0 THEN
		// Calculate offset to ensure that rear edge window is at target window after move operation
		IF TargetWindowIndex >= WindowNumberRE THEN
			TargetMoveWindowIndex := TargetWindowIndex - WindowNumberRE + 1;
		ELSE
			TargetMoveWindowIndex := TargetWindowIndex + MaxWindowIndex - WindowNumberRE + 1;
		END_IF
		
		// Store old window index for a possible rollback
		OldZoneStartWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;

		// Move zone to target 
		mMoveOk := M_MoveZone(
						mZoneIndex 				:= mZoneIndex,
						mTargetStartWindow 		:= TargetMoveWindowIndex,
						mEnableDeleteOfZones 	:= FALSE);	
		
		// If zone could be moved to new location, 
		IF mMoveOk THEN
			NewTrackingPosition := M_GetTrackingPosition(mAbsoluteTargetPosition);
			
			// try to adapt edge position changes (Front edge and rear edge)
			mRearEdgeAdjusted := M_AdjustRE(
									mWindowIndexRE 			:= TargetWindowIndex,
									mNewTrackingPosition 	:= NewTrackingPosition,
									mDeleteTargetZones 		:= mDeleteTargetZones);
		
			IF mRearEdgeAdjusted THEN
				// Move successful
				M_MoveZoneRE := TRUE;
			
			// Edge could not be aligned -> Rollback and abort		
			ELSE
				fbDebugMsg.M_SendErrorMsg('M_MoveZoneRE - Rear edge could no be adjusted.');	
			
				mMoveOk := M_MoveZone(
							mZoneIndex 				:= mZoneIndex,
							mTargetStartWindow 		:= OldZoneStartWindowIndex,
							mEnableDeleteOfZones 	:= FALSE);
							
				IF NOT mMoveOk THEN
					// Error during rollback
					fbDebugMsg.M_SendErrorMsg('M_MoveZoneRE - Rollback not possible.');	
				END_IF
				
				M_MoveZoneRE := FALSE;
			END_IF
												
		// Move was not possible -> Abort						
		ELSE
			M_MoveZoneRE := FALSE;
		END_IF
		
	// Otherwise no rear edge window found
	ELSE
		M_MoveZoneRE := FALSE;
	END_IF
// Zone not valid 
ELSE
	M_MoveZoneRE := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_RemoveZoneFromPTL" Id="{00a5ee10-279d-49ae-874b-0754242c2380}">
      <Declaration><![CDATA[/// Removes a zone from the ptl list and closes all gaps in list
METHOD PROTECTED M_RemoveZoneFromPTL : BOOL // Returns true if zone was found and deleted, otherwise false
VAR_INPUT
	mZoneIndex			: UINT; // Zone index to remove
END_VAR
VAR
	mIdx				: UINT; // Iterator
	mCloseGapsInList 	: BOOL; // Flag to close gaps
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_RemoveZoneFromPTL := FALSE;
mCloseGapsInList := FALSE;

// Clean entry in PTL list and close gaps in list
FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
	IF PTL_Zones[mIdx] <> 0  THEN	
		IF PTL_Zones[mIdx] = mZoneIndex THEN 
			// Clear entry and mark following to close gaps
			mCloseGapsInList := TRUE;
			PTL_Zones[mIdx] := 0;
			M_RemoveZoneFromPTL := TRUE;
			
		ELSIF mCloseGapsInList THEN
			// Close gaps
			PTL_Zones[mIdx-1] := PTL_Zones[mIdx];
			PTL_Zones[mIdx] := 0;
		END_IF
	ELSE
		// No entries available
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_RemoveZoneFromTransferList" Id="{fe181709-b97e-4ebe-b879-7535ed1860ba}">
      <Declaration><![CDATA[/// Removes a zone from the transfer list and closes all gaps in list
METHOD PROTECTED M_RemoveZoneFromTransferList : BOOL // Returns true if zone was found and deleted, otherwise false
VAR_INPUT
	mZoneIndex			: UINT; // Zone index to remove
END_VAR
VAR
	mIdx				: UINT; // Iterator
	mCloseGapsInList 	: BOOL; // Flag to close gaps
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_RemoveZoneFromTransferList := FALSE;
mCloseGapsInList := FALSE;

// Clean entry in transfer list and close gaps in list
FOR mIdx := 1 TO TRANSFER_TABLE_SIZE DO
	IF OngoingTransferList[mIdx].Active THEN	
		IF OngoingTransferList[mIdx].ZoneIndex = mZoneIndex THEN 
			// Clear entry and mark following to close gaps
			mCloseGapsInList := TRUE;
			MEMSET(ADR(OngoingTransferList[mIdx]), 0, SIZEOF(OngoingTransferList[mIdx]));
			M_RemoveZoneFromTransferList := TRUE;
			
		ELSIF mCloseGapsInList THEN
			// Close gaps
			OngoingTransferList[mIdx-1] := OngoingTransferList[mIdx];
			MEMSET(ADR(OngoingTransferList[mIdx]), 0, SIZEOF(OngoingTransferList[mIdx]));
		END_IF
	ELSE
		// No entries available
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ReserveZone" Id="{cb55d34d-3ca6-471c-a0a1-dc936395962b}">
      <Declaration><![CDATA[/// Reserve a Zone on tracking
/// Remark: Target needs to be free
METHOD PROTECTED M_ReserveZone : UINT // Returns Zone index if successful, otherwise 0
VAR_INPUT
	mActionId						: INT; (* ID of action which requests zone - 
								     		(0 = Only reservation, but free to be used by other actions) *)
	mLength							: UINT; // Length of zone to allocate [mm]
	mStartWindowIndex 				: UINT; // Start window index
	mStartTrackingPosition			: UDINT; // Start tracking position of the zone in start window [mm]
	mInhibitShifting				: BOOL; // Mark zone as not shiftable
	miActionListener				: I_TrackingActionListener; // Action listener of the created zone
	mPositionToLive					: UDINT; // Absolute position until allocation gets deleted automatically if not used (0 = disabled)
END_VAR
VAR_INST
	ZoneIndex 						: UINT; // Allocated zone index
	MaxWindowPosition 				: UDINT; // Input check for required poition MAX
	MinWindowPosition 				: UDINT; // Input check for required poition MIN
END_VAR
VAR
	mIdx							: UINT; // Loop iterator
	mWindowIndex					: UINT; // Start window index
	mWindowLength					: UINT; // Zone length in windows
	mEndWindowIndex					: UINT; // End window index
	mReservationAllowed 			: BOOL; // Reservation valid (e.g. free space available)
	mZoneEndPosition				: UDINT; // Zone end position 
	mRelWindowPositionZoneStart 	: UDINT; // Relative position of zone start in window
	mFullLength						: UINT; // Full length to be allocated
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ReserveZone := 0;

// Validate inputs
IF mLength <= 0 OR
   WindowSize = 0 OR
   mStartWindowIndex <= 0 OR
   mStartWindowIndex > WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
   RETURN;
END_IF

// Get max and min tracking position of front edge window
MaxWindowPosition := (mStartWindowIndex) * WindowSize;
MinWindowPosition := (mStartWindowIndex-1) * WindowSize;

// Ensure that new tracking position is in range of window
IF mStartTrackingPosition < MinWindowPosition OR 
   mStartTrackingPosition >= MaxWindowPosition THEN
   RETURN;
END_IF

// Calculate relative position in first zone window
mRelWindowPositionZoneStart := mStartTrackingPosition MOD WindowSize;

// The relative position in the first window is added to the length, 
// in order to get the amount of windows which are allocated for that TU finally
mFullLength := mLength + UDINT_TO_UINT(mRelWindowPositionZoneStart);

// Convert length into number of windows
mWindowLength := mFullLength / WindowSize;
// If not the full length could be mapped in windows
// add an additional window
IF (mFullLength MOD WindowSize) > 0 THEN
	mWindowLength := mWindowLength + 1;
END_IF

mWindowIndex := mStartWindowIndex;
mReservationAllowed := TRUE;

// Ensure reservation is possible
FOR mIdx := 1 TO mWindowLength DO
	// When zone is not empty or marked as flush, abort
	IF WindowTable[mWindowIndex].ZoneIndex > 0  OR
	   WindowTable[mWindowIndex].Flush THEN
	   // Cancel resevation
	   mReservationAllowed := FALSE;
	   M_ReserveZone := 0;
	   
	   	// Error
		fbDebugMsg.M_SendErrorMsg('M_ReserveZone - Reservation not possible, no available space.');	
	   	RETURN;
	END_IF
	
	mWindowIndex := mWindowIndex + 1;
 
	// Correct border overflow
	IF mWindowIndex > MaxWindowIndex THEN
		mWindowIndex := mWindowIndex - MaxWindowIndex;
	END_IF
END_FOR

// When reservation is possible to be executed
IF mReservationAllowed THEN
	// Get new Zone index
	ZoneIndex := M_InsertNewZoneIndex();
	
	IF ZoneIndex > 0 THEN
		mWindowIndex := mStartWindowIndex;
		
		// Loop through all windows and assigne new zone
		FOR mIdx := 1 TO mWindowLength DO
		   // Clear window
			MEMSET(ADR(WindowTable[mWindowIndex]),0,SIZEOF(WindowTable[mWindowIndex]));
			
			WindowTable[mWindowIndex].ZoneIndex := ZoneIndex;
			WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.RESERVED;
							
			mWindowIndex := mWindowIndex + 1;
		 
			// Correct border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR
		
		mEndWindowIndex := mStartWindowIndex + mWindowLength - 1;
		
		// Correct border overflow
		IF mEndWindowIndex > MaxWindowIndex THEN
			mEndWindowIndex := mEndWindowIndex - MaxWindowIndex;
		END_IF
		
		mZoneEndPosition := mStartTrackingPosition + mLength;
		
		IF mZoneEndPosition > TotalTrackingLength THEN
			mZoneEndPosition := mZoneEndPosition - TotalTrackingLength;
		END_IF 
		
		ZoneTable[ZoneIndex].Used := TRUE;
		ZoneTable[ZoneIndex].ActionId := mActionId;
		ZoneTable[ZoneIndex].ZoneStartWindowIndex := mStartWindowIndex;
		ZoneTable[ZoneIndex].ZoneStartPosition := mStartTrackingPosition;
		ZoneTable[ZoneIndex].ZoneEndWindowIndex := mEndWindowIndex;
		ZoneTable[ZoneIndex].ZoneEndPosition := mZoneEndPosition;
		ZoneTable[ZoneIndex].ZoneLength := mLength;
		ZoneTable[ZoneIndex].InhibitShifting := mInhibitShifting;
		ZoneTable[ZoneIndex].iActionListener := miActionListener;
		ZoneTable[ZoneIndex].PositionToLive := mPositionToLive;

		IF mPositionToLive > 0 THEN
			M_AddZoneToPTL(ZoneIndex);
		END_IF
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneAddedEvent(ZoneIndex,ZoneTable[ZoneIndex]);
		END_IF
		
		M_ReserveZone := ZoneIndex;
	ELSE
		// Error
		fbDebugMsg.M_SendErrorMsg('M_ReserveZone - Could not find free zone.');	
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResyncOnlyFE" Id="{84a25842-3cdc-4730-ab3c-c506689a1078}">
      <Declaration><![CDATA[/// This function synchronize only a Front edge to a specific position and calculates the new TU length.
/// Remark: Zone begin gets adjusted to new front edge position. Spare windows in front of front edge get removed.
/// Remark: If at absolute position no zone is found, it searchs to the left for next front edge
/// until "mMaxFrontEdgeDeviation" to synchronize.
METHOD M_ResyncOnlyFE : UINT // Returns > 0 of the synchronized Zone index, otherwise 0 (e.g. No Zone, No occupied zone)
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position [mm]
	mMaxFrontEdgeDeviation 	: UDINT; (* When zone can not be found at "Absolute position",
										a search upwards is executed to a limit of MaxFrontEdgeDeviation [mm]*)
END_VAR
VAR_INST
	MaxTrackingPosition		: UDINT; // Max tracking distance to search for a zone
	NewPositionFE			: UDINT; // New front edge position in tracking
	NumberOfDeviationWindows: UINT; // Number of windows for maximal edge deviation 
	ZoneIndex				: UINT; // Zone index
	ZoneWindowLength 		: UINT; // Length of zone to be moved
	ExistingWindowIndexFE	: UINT; // Existing front edge window index
	ResyncPossible			: BOOL; // Resync is possible
	OldWindowFE				: ST_WindowTrackingWindow; // Stored old front edge window
	DistanceToTU_End		: DINT; // Distance to found TU End
	DistanceToTU_Start		: DINT; // Distance to found TU start
END_VAR
VAR
	mNewWindowIndexFE		: UINT; // Actual window index
	mWindowIndex			: UINT; // Window index iterator
	mIdx					: UINT; // Loop iterator
	mZoneFreeOk				: BOOL; // Shift possible
	mNewZoneWindowLength	: UINT; // Length of windows of aligned zone
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ResyncOnlyFE := 0;
ZoneIndex := 0;
NumberOfDeviationWindows := 0;
mNewZoneWindowLength := 0;
ResyncPossible := TRUE;

// Validate values
IF WindowSize = 0 THEN
	RETURN;
END_IF

// Get window index at position
mNewWindowIndexFE := M_GetWindowIndex(mAbsolutePosition);

// Find related ZoneIndex
IF mNewWindowIndexFE > 0 AND mNewWindowIndexFE <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	// Ensure that target window is not already a rear edge window 
	// This is not permitted, minimum zone is two window
	IF WindowTable[mNewWindowIndexFE].State = E_WindowTrackingWindowState.REAR_EDGE THEN
		ZoneIndex := 0;
		
	// Search correlating zone
	// Check from target window to the left until MaxFrontedgeDeviation
	ELSE
		// Calculate max number of allowed front deviation windows
		NumberOfDeviationWindows := UDINT_TO_UINT(mMaxFrontEdgeDeviation / WindowSize);
		
		// Add an additional window if rest of division was unequal 0
		IF mMaxFrontEdgeDeviation MOD WindowSize > 0 THEN
			NumberOfDeviationWindows := NumberOfDeviationWindows + 1;
		END_IF
		
		// Get max tracking position for valid zone
		MaxTrackingPosition := M_GetTrackingPosition(mAbsolutePosition - mMaxFrontEdgeDeviation);

		// Search for adjacent zone
		mWindowIndex := mNewWindowIndexFE;
				
		// Check all additional windows plus begin
		FOR mIdx := 1 TO NumberOfDeviationWindows + 1 DO
			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
			
			// Search next zone
			IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
				DistanceToTU_End := M_GetDistanceToTU_End(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
				DistanceToTU_Start := M_GetDistanceToTU_Start(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			
				// When a found zone is valid, check if edge is in valid range
				IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.Front_EDGE THEN
					// Check if it's not last deviation window to check
					IF mIdx < NumberOfDeviationWindows + 1 THEN
						// Return found zone
						ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					ELSE
						// Check position in window for max deviation
						IF WindowTable[mWindowIndex].TU_FrontEdgePosition <= MaxTrackingPosition THEN			
							// Return found zone
							ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
						END_IF
					END_IF
					EXIT;
					
				// Ensure TU end has not passed resync position and TU begin has reacher in minimum MaxDeviation pos
				// Remark: >0 = It is infront of resync position 
				ELSIF DistanceToTU_End > 0 AND
					  DistanceToTU_Start <= UDINT_TO_DINT(mMaxFrontEdgeDeviation) THEN
					// Return found zone
					ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					EXIT;
				END_IF
			END_IF
			
			mWindowIndex := mWindowIndex + 1;
		END_FOR 
	END_IF
END_IF

// Ensure zone is valid (Consists of a TU, adaption of FE possible)
IF ZoneIndex > 0 THEN
	// Only possible if zone consists of a physical TU
	IF ZoneTable[ZoneIndex].TU_Present THEN
		// Ensure that no other zone is between new front edge and old rear edge
		mWindowIndex := mNewWindowIndexFE;
		ResyncPossible := TRUE;
		
		// Calculate new zone length in windows
		IF ZoneTable[ZoneIndex].ZoneEndWindowIndex > mNewWindowIndexFE THEN
			mNewZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex - mNewWindowIndexFE + 1;
		ELSE
			mNewZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex + MaxWindowIndex - mNewWindowIndexFE + 1;
		END_IF
	
		// Ensure resync has space
		FOR mIdx := 1 TO mNewZoneWindowLength DO	
			// If found window is empty or already part of the zone
			IF WindowTable[mWindowIndex].ZoneIndex = 0 OR
			   WindowTable[mWindowIndex].ZoneIndex = ZoneIndex THEN
			   // Window is valid
			   ;
			
			// Otherwise another zone is found, try to shift
			ELSE
				mZoneFreeOk := M_MakeSpace(
									mStartWindowIndex 	:= mWindowIndex, 
									mWindowsToFree 		:= 1,
									mAllowZoneDelete 	:= TRUE);
									
				IF NOT mZoneFreeOk THEN
					// Error, zone could not be shifted -> abort
					ResyncPossible := FALSE;
					EXIT;
				END_IF
			END_IF
			  
			mWindowIndex := mWindowIndex + 1;

			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR  
	END_IF
END_IF

// Process when a valid zone could be found
IF ZoneIndex > 0 AND ResyncPossible THEN
	// Calculate length of existing zone in windows
	IF ZoneTable[ZoneIndex].ZoneEndWindowIndex > ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
		ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
	
	// Get existing front edge window
	ExistingWindowIndexFE := ZoneTable[ZoneIndex].TU_StartWindowIndex;
		
	// When front edge window could be found
	IF ExistingWindowIndexFE > 0 THEN
		// Store old window, because its possible to overwrite existing position
		OldWindowFE := WindowTable[ExistingWindowIndexFE];
		M_ClearWindow(ExistingWindowIndexFE);
		
		// Copy old window to new
		WindowTable[mNewWindowIndexFE] := OldWindowFE;
		
		NewPositionFE := M_GetTrackingPosition(mAbsolutePosition);
		
		// Adapt edge position and zone length
		WindowTable[mNewWindowIndexFE].TU_FrontEdgePosition := NewPositionFE;
		ZoneTable[ZoneIndex].ZoneStartWindowIndex := mNewWindowIndexFE;
		ZoneTable[ZoneIndex].TU_StartWindowIndex := mNewWindowIndexFE;
		ZoneTable[ZoneIndex].ZoneStartPosition := NewPositionFE;
		
		IF ZoneTable[ZoneIndex].ZoneEndPosition >= ZoneTable[ZoneIndex].ZoneStartPosition THEN
			ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition - ZoneTable[ZoneIndex].ZoneStartPosition);
		ELSE
			ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition + TotalTrackingLength - ZoneTable[ZoneIndex].ZoneStartPosition);
		END_IF

		// Clean all windows to the right of this zone
		mWindowIndex := mNewWindowIndexFE - 1;
		
		FOR mIdx := 1 TO MaxWindowIndex DO	
			// Correct window border overflow
			IF mWindowIndex <= 0 THEN
				mWindowIndex := mWindowIndex + MaxWindowIndex;
			END_IF
			
			// When window right of the front edge is part of the same zone, clean it
			IF WindowTable[mWindowIndex].ZoneIndex = ZoneIndex THEN
				M_ClearWindow(mWindowIndex);
				mWindowIndex := mWindowIndex -1;
			// Otherwise no other windows to clean
			ELSE
				EXIT;
			END_IF
		END_FOR  
			
		// Fill gap windows to the left
		mWindowIndex := mNewWindowIndexFE;
				
		FOR mIdx := 1 TO mNewZoneWindowLength DO	
			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
			
			// Assign ZoneIndex to all windows
			WindowTable[mWindowIndex].ZoneIndex := ZoneIndex;
			
			// Overwrite all windows as occupied except begin and end
			IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
				;
			// Stop overwriting at rear edge window
            ELSIF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
				EXIT;
			ELSE
				// Assign ZoneIndex to all windows
				WindowTable[mWindowIndex].ZoneIndex := ZoneIndex;
				WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.OCCUPIED;
			
				// Possible flush can be resettet, because of synchronization its valid again
				WindowTable[mWindowIndex].Flush := 0;
				WindowTable[mWindowIndex].TU_FrontEdgePosition := 0;
				WindowTable[mWindowIndex].TU_RearEdgePosition := 0;
			END_IF

			mWindowIndex := mWindowIndex + 1;
		END_FOR  
		
		M_ResyncOnlyFE := ZoneIndex;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResyncOnlyRE" Id="{6fdf8443-35ff-417f-999c-f1d4a06c3d53}">
      <Declaration><![CDATA[/// This function synchronize only Rear edge to a specific position and calculates new TU length.
/// Remark: Zone end gets adjusted to new rear edge position. Spare windows after rear edge get removed.
/// Remark: If at absolute position no zone is found, it search to the right
/// until "mMaxFrontEdgeDeviation" to find one to synchronize.
METHOD M_ResyncOnlyRE : UINT // Returns > 0 of the synchronized Zone index, otherwise 0
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position [mm]
	mMaxRearEdgeDeviation 	: UDINT; (* When zone can not be found at "Absolute position",
										a search upwards is executed to a limit of MaxRearEdgeDeviation [mm]*)
END_VAR
VAR_INST
	MinTrackingPosition		: UDINT; // Min tracking distance to search for a zone
	NumberOfDeviationWindows: UINT; // Number of windows for maximal edge deviation 
	ZoneIndex				: UINT; // Zone index
	ResyncPossible			: BOOL; // Resync is possible
	ExistingWindowIndexRE	: UINT; // Existing rear edge window index
	ZoneWindowLength 		: UINT; // Length of zone to be moved
	OldWindowRE				: ST_WindowTrackingWindow; // Stored old rear edge window
	NewPositionRE			: UDINT; // New rear edge position in tracking
	DistanceToTU_End		: DINT; // Distance to found TU End
	DistanceToTU_Start		: DINT; // Distance to found TU start
END_VAR
VAR
	mZoneFreeOk				: BOOL; // Successfully
	mNewZoneWindowLength	: UINT; // Length of windows of aligned zone
	mNewWindowIndexRE		: UINT; // Actual window index
	mWindowIndex			: UINT; // Window index iterator
	mIdx					: UINT; // Loop iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ResyncOnlyRE := 0;
ZoneIndex := 0;
NumberOfDeviationWindows := 0;

// Validate values
IF WindowSize = 0 THEN
	RETURN;
END_IF

// Get window index at position
mNewWindowIndexRE := M_GetWindowIndex(mAbsolutePosition);

IF mNewWindowIndexRE > 0 AND mNewWindowIndexRE <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	// Ensure that target window is not already a front edge window 
	// This is not permitted, minimum zone is two window
	IF WindowTable[mNewWindowIndexRE].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
		ZoneIndex := 0;
		
	// Search correlating zone
	// Check from target window to the right until MaxFrontedgeDeviation
	ELSE
		// Calculate max number of allowed rear edge deviation windows
		NumberOfDeviationWindows := UDINT_TO_UINT(mMaxRearEdgeDeviation / WindowSize);
		
		// Add an additional window if rest of division was unequal 0
		IF mMaxRearEdgeDeviation MOD WindowSize > 0 THEN
			NumberOfDeviationWindows := NumberOfDeviationWindows + 1;
		END_IF
		
		// Get min  tracking position for valid zone
		MinTrackingPosition := M_GetTrackingPosition(mAbsolutePosition + mMaxRearEdgeDeviation);

		// Search for a adjacent zone
		mWindowIndex := mNewWindowIndexRE;

		FOR mIdx := 1 TO NumberOfDeviationWindows + 1 DO	
			// Correct window border overflow
			IF mWindowIndex <= 0 THEN
				mWindowIndex := mWindowIndex + MaxWindowIndex;
			END_IF
			
			// Search next zone
			IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
				DistanceToTU_End := M_GetDistanceToTU_End(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
				DistanceToTU_Start := M_GetDistanceToTU_Start(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			
				// When a rear edge was found check for valid range
				IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
					// If it's not last deviation window to check
					IF mIdx < NumberOfDeviationWindows + 1 THEN
						// Return found zone
						ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					ELSE
						// Check position in window for max deviation
						IF WindowTable[mWindowIndex].TU_RearEdgePosition >= MinTrackingPosition THEN			
							// Return found zone
							ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
						END_IF
					END_IF
					EXIT;
					
				// Ensure TU start has passed resync position and TU end has reached in minimum MaxDeviation pos
				// Remark: >0 = It is infront of resync position 
				ELSIF DistanceToTU_Start < 0 AND
                      DistanceToTU_End >= UDINT_TO_DINT(mMaxRearEdgeDeviation) THEN
				   	// Return found zone
					ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					EXIT;
				END_IF
			END_IF
			
			mWindowIndex := mWindowIndex - 1;
		END_FOR 
	END_IF
END_IF

// Ensure zone is valid (Consists of a TU, adaption of RE possible)
IF ZoneIndex > 0 THEN
	// Only possible if zone consists of a physical TU
	IF ZoneTable[ZoneIndex].TU_Present THEN
		// Ensure that no other zone is between new rear edge and old front edge
		mWindowIndex := ZoneTable[ZoneIndex].ZoneStartWindowIndex;
		ResyncPossible := TRUE;
		
		// Calculate new zone length in windows
		IF mNewWindowIndexRE > ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
			mNewZoneWindowLength := mNewWindowIndexRE - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
		ELSE
			mNewZoneWindowLength := mNewWindowIndexRE  + MaxWindowIndex - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
		END_IF
	
		// Validate that sync is possible
		FOR mIdx := 1 TO mNewZoneWindowLength DO	
			// If found window is empty or already part of the zone
			IF WindowTable[mWindowIndex].ZoneIndex = 0 OR
			   WindowTable[mWindowIndex].ZoneIndex = ZoneIndex THEN
			   // Window is valid
			   ;
			
			// Otherwise another zone is found, try to shift
			ELSE
				mZoneFreeOk := M_MakeSpace(
									mStartWindowIndex 	:= mWindowIndex, 
									mWindowsToFree 		:= 1,
									mAllowZoneDelete 	:= TRUE);
									
				IF NOT mZoneFreeOk THEN
					// Error, zone could not be shifted -> abort
					ResyncPossible := FALSE;
					EXIT;
				END_IF
			END_IF
			  
			mWindowIndex := mWindowIndex + 1;

			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR  
	END_IF
END_IF

IF ZoneIndex > 0 AND ResyncPossible THEN
	// Calculate length of existing zone in windows
	IF ZoneTable[ZoneIndex].ZoneEndWindowIndex > ZoneTable[ZoneIndex].ZoneStartWindowIndex THEN
		ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
	ELSE
		ZoneWindowLength := ZoneTable[ZoneIndex].ZoneEndWindowIndex + MaxWindowIndex  - ZoneTable[ZoneIndex].ZoneStartWindowIndex + 1;
	END_IF
	
	// Get existing rear edge window
	ExistingWindowIndexRE := ZoneTable[ZoneIndex].TU_EndWindowIndex;
	
	// When rear edge window could be found
	IF ExistingWindowIndexRE > 0 THEN
		// Store old window, because its possible to overwrite existing position
		OldWindowRE := WindowTable[ExistingWindowIndexRE];
		M_ClearWindow(ExistingWindowIndexRE);
		
		// Copy old window to new
		WindowTable[mNewWindowIndexRE] := OldWindowRE;
		
		NewPositionRE := M_GetTrackingPosition(mAbsolutePosition);
		
		// Adapt edge position and zone length
		WindowTable[mNewWindowIndexRE].TU_RearEdgePosition := NewPositionRE;
		ZoneTable[ZoneIndex].ZoneEndWindowIndex := mNewWindowIndexRE;
		ZoneTable[ZoneIndex].TU_EndWindowIndex := mNewWindowIndexRE;
		ZoneTable[ZoneIndex].ZoneEndPosition := NewPositionRE;
		
		IF ZoneTable[ZoneIndex].ZoneEndPosition >= ZoneTable[ZoneIndex].ZoneStartPosition THEN
			ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition - ZoneTable[ZoneIndex].ZoneStartPosition);
		ELSE
			ZoneTable[ZoneIndex].ZoneLength := UDINT_TO_UINT(ZoneTable[ZoneIndex].ZoneEndPosition + TotalTrackingLength - ZoneTable[ZoneIndex].ZoneStartPosition);
		END_IF
		
		// Clean all windows to the left of this zone
		mWindowIndex := mNewWindowIndexRE + 1;
		
		FOR mIdx := 1 TO MaxWindowIndex DO	
			// Correct window border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
			
			// When window left of the rear edge is part of the same zone, clean it
			IF WindowTable[mWindowIndex].ZoneIndex = ZoneIndex THEN
				M_ClearWindow(mWindowIndex);
				mWindowIndex := mWindowIndex + 1;
			// Otherwise no other windows to clean
			ELSE
				EXIT;
			END_IF
		END_FOR  
			
		// Fill gap windows to the right
		mWindowIndex := mNewWindowIndexRE;
				
		FOR mIdx := 1 TO mNewZoneWindowLength DO	
			// Correct window border overflow
			IF mWindowIndex <= 0 THEN
				mWindowIndex := mWindowIndex + MaxWindowIndex;
			END_IF
			
			// Assign ZoneIndex to all windows
			WindowTable[mWindowIndex].ZoneIndex := ZoneIndex;
			
			// Overwrite all windows as occupied except begin and end
			IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
				;
				
			// Stop overwriting at front edge window
            ELSIF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.FRONT_EDGE THEN
				EXIT;
				
			ELSE
				// Assign ZoneIndex to all windows
				WindowTable[mWindowIndex].ZoneIndex := ZoneIndex;
				WindowTable[mWindowIndex].State := E_WindowTrackingWindowState.OCCUPIED;
			
				// Possible flush can be reset, because of synchronization its valid again
				WindowTable[mWindowIndex].Flush := 0;
				WindowTable[mWindowIndex].TU_FrontEdgePosition := 0;
				WindowTable[mWindowIndex].TU_RearEdgePosition := 0;
			END_IF

			mWindowIndex := mWindowIndex - 1;
		END_FOR  
		
		M_ResyncOnlyRE := ZoneIndex;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResyncTU_FE" Id="{0632ccab-4dcd-4b74-80ce-38bc20c7e61d}">
      <Declaration><![CDATA[/// This function synchronize whole TU aligned by Front edge to a specific position.
/// Rear edge is adjusted automatically to keep the length of TU.
/// Remark: If at absolute position no zone is found, it search to the left
/// until "mMaxFrontEdgeDeviation" to find one to synchronize.
METHOD M_ResyncTU_FE : UINT // Returns > 0 of the synchronized Zone index, otherwise 0
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position [mm]
	mMaxFrontEdgeDeviation 	: UDINT; (* When zone can not be found at "Absolute position",
										a search upwards is executed to a limit of MaxFrontEdgeDeviation [mm]*)
END_VAR
VAR_INST
	MaxTrackingPosition		: UDINT; // Max tracking distance to search for a zone
	NumberOfDeviationWindows: UINT; // Number of windows for maximal edge deviation 
	ZoneIndex				: UINT; // Zone index
END_VAR
VAR
	mZoneMoved 				: BOOL; // Zone moved successfully
	mSyncWindowIndex		: UINT; // Actual window index
	mWindowIndex			: UINT; // Window index iterator
	mIdx					: UINT; // Loop iterator
	DistanceToTU_End		: DINT; // Distance to found TU End
	DistanceToTU_Start		: DINT; // Distance to found TU start
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ResyncTU_FE := 0;
ZoneIndex := 0;
NumberOfDeviationWindows := 0;

// Validate values
IF WindowSize = 0 THEN
	RETURN;
END_IF

// Get window index at position
mSyncWindowIndex := M_GetWindowIndex(mAbsolutePosition);

// Search correlating zone
// Check from target window to the left until MaxFrontedgeDeviation
IF mSyncWindowIndex > 0 AND mSyncWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	// Calculate max number of allowed front deviation windows
	NumberOfDeviationWindows := UDINT_TO_UINT(mMaxFrontEdgeDeviation / WindowSize);
	
	// Add an additional window if rest of division was unequal 0
	IF mMaxFrontEdgeDeviation MOD WindowSize > 0 THEN
		NumberOfDeviationWindows := NumberOfDeviationWindows + 1;
	END_IF
	
	// Get max tracking position for valid zone
	MaxTrackingPosition := M_GetTrackingPosition(mAbsolutePosition - mMaxFrontEdgeDeviation);

	// Search for adjacent zone
	mWindowIndex := mSyncWindowIndex;
			
	FOR mIdx := 1 TO NumberOfDeviationWindows + 1 DO	
		// Correct window border overflow
		IF mWindowIndex > MaxWindowIndex THEN
			mWindowIndex := mWindowIndex - MaxWindowIndex;
		END_IF
		
		// Search next zone
		IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
			DistanceToTU_End := M_GetDistanceToTU_End(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			DistanceToTU_Start := M_GetDistanceToTU_Start(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			
			// When a found zone is valid, check if edge is in valid range
			IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.Front_EDGE THEN
				// Check if it's not last deviation window to check
				// Then it is anyway in the valid range
				IF mIdx < NumberOfDeviationWindows + 1 THEN
					// Return found zone
					ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					
				// if it is the last window,
				// ensure the position inside the window is in the allowed border
				ELSE
					// Check position in window for max deviation
					IF WindowTable[mWindowIndex].TU_FrontEdgePosition <= MaxTrackingPosition THEN			
						// Return found zone
						ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					END_IF
				END_IF
				EXIT;
				
			// Ensure TU end has not passed resync position and TU begin has reacher in minimum MaxDeviation pos
			// Remark: >0 = It is infront of resync position 
			ELSIF DistanceToTU_End > 0 AND
                  DistanceToTU_Start <= UDINT_TO_DINT(mMaxFrontEdgeDeviation) THEN
				// Return found zone
				ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
				EXIT;
			END_IF
		END_IF
		
		mWindowIndex := mWindowIndex + 1;
	END_FOR 
END_IF

// Process when a zone could be found
IF ZoneIndex > 0 THEN
	mZoneMoved := M_MoveZoneFE(
					mZoneIndex 				:= ZoneIndex,
					mAbsoluteTargetPosition := mAbsolutePosition,
					mDeleteTargetZones 		:= FALSE);
					
	IF mZoneMoved THEN
		M_ResyncTU_FE := ZoneIndex;
	ELSE
		M_ResyncTU_FE := 0;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResyncTU_RE" Id="{67633d5e-db15-4da9-a88d-8ddb1e0e7b93}">
      <Declaration><![CDATA[/// This function synchronize whole TU aligned by Rear edge to a specific position.
/// Front edge is adjusted automatically to keep the length of TU.
/// Remark: If at absolute position no zone is found, it search to the right
/// until "mMaxFrontEdgeDeviation" to find one to synchronize.
METHOD M_ResyncTU_RE : UINT // Returns > 0 of the synchronized Zone index, otherwise 0
VAR_INPUT
	mAbsolutePosition		: UDINT; // Absolute position [mm]
	mMaxRearEdgeDeviation 	: UDINT; (* When zone can not be found at "Absolute position",
										a search upwards is executed to a limit of MaxRearEdgeDeviation [mm]*)
END_VAR
VAR_INST
	MinTrackingPosition		: UDINT; // Min tracking distance to search for a zone
	NumberOfDeviationWindows: UINT; // Number of windows for maximal edge deviation 
	ZoneIndex				: UINT; // Zone index
	DistanceToTU_End		: DINT; // Distance to found TU End
	DistanceToTU_Start		: DINT; // Distance to found TU start
END_VAR
VAR
	mZoneMoved 				: BOOL; // Zone moved successfully
	mSyncWindowIndex		: UINT; // Actual window index
	mWindowIndex			: UINT; // Window index iterator
	mIdx					: UINT; // Loop iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ResyncTU_RE := 0;
ZoneIndex := 0;
NumberOfDeviationWindows := 0;

// Validate values
IF WindowSize = 0 THEN
	RETURN;
END_IF

// Get window index at position
mSyncWindowIndex := M_GetWindowIndex(mAbsolutePosition);

IF mSyncWindowIndex > 0 AND mSyncWindowIndex <= WindowTracking.MAX_NUMBER_OF_WINDOWS THEN
	// Calculate max number of allowed rear edge deviation windows
	NumberOfDeviationWindows := UDINT_TO_UINT(mMaxRearEdgeDeviation / WindowSize);
	
	// Add an additional window if rest of division was unequal 0
	IF mMaxRearEdgeDeviation MOD WindowSize > 0 THEN
		NumberOfDeviationWindows := NumberOfDeviationWindows + 1;
	END_IF
	
	// Get min tracking position for valid zone
	MinTrackingPosition := M_GetTrackingPosition(mAbsolutePosition - mMaxRearEdgeDeviation);

	// Search for a adjacent zone to the right
	mWindowIndex := mSyncWindowIndex;
			
	FOR mIdx := 1 TO NumberOfDeviationWindows + 1 DO	
		// Correct window border overflow
		IF mWindowIndex <= 0 THEN
			mWindowIndex := mWindowIndex + MaxWindowIndex;
		END_IF
		
		// Search next zone
		IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
			DistanceToTU_End := M_GetDistanceToTU_End(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			DistanceToTU_Start := M_GetDistanceToTU_Start(mAbsolutePosition, WindowTable[mWindowIndex].ZoneIndex);
			
			// When a found zone is valid, check if edge is in valid range
			IF WindowTable[mWindowIndex].State = E_WindowTrackingWindowState.REAR_EDGE THEN
				// If it's not last deviation window to check
				IF mIdx < NumberOfDeviationWindows THEN
					// Return found zone
					ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
				ELSE
					// Check position in window for max deviation
					IF WindowTable[mWindowIndex].TU_RearEdgePosition >= MinTrackingPosition THEN
						// Return found zone
						ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
					END_IF
				END_IF
				EXIT;
				
			// Ensure TU start has passed resync position and TU end has reached in minimum MaxDeviation pos
			// Remark: >0 = It is infront of resync position 
			ELSIF DistanceToTU_Start < 0 AND
                  DistanceToTU_End >= UDINT_TO_DINT(mMaxRearEdgeDeviation) THEN
				 // Return found zone
				ZoneIndex := WindowTable[mWindowIndex].ZoneIndex;
				EXIT;
			END_IF
		END_IF
		
		mWindowIndex := mWindowIndex - 1;
	END_FOR 
END_IF

// Process when a zone could be found
IF ZoneIndex > 0 THEN
	mZoneMoved := M_MoveZoneRE(
					mZoneIndex 				:= ZoneIndex,
					mAbsoluteTargetPosition := mAbsolutePosition,
					mDeleteTargetZones 		:= FALSE);
					
	IF mZoneMoved THEN
		M_ResyncTU_RE := ZoneIndex;
	ELSE
		M_ResyncTU_RE := 0;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ShiftZone" Id="{08440ea1-4b89-4401-a375-e1711cabebf6}">
      <Declaration><![CDATA[/// Shift zone at StartWindowIndex by WindowsToShift (If WindowsToShift includes more zones, they are shifted as well)
/// Remark: Only Zones without a TU Present and permition to shift, can be shifted. 
/// Remark: When a zone is found to shift, the whole zone is shifted
/// Remark: Zones which can not be reallocated (e.g. not enough space on tracking) get deleted. Owner of the Zone
/// will be notfied about that process.
METHOD PROTECTED M_ShiftZone : BOOL // Returns true if successfull shifted, otherwise false (e.g. not allowed to shift, wrong input)
VAR_INPUT
	mStartWindowIndex		: UINT; // Start window index
	mWindowsToShift			: UINT; // Windows to shift
	mExcludeTUs				: BOOL; // Exclude physical occupied zones
	mAllowOverrun			: BOOL; // Allow to throw out zones which cannot be place on the tracking anymore because of reallocations
END_VAR
VAR_INST
	ShiftingAllowed			: BOOL; // Target position is to be shifted
	RetrieveOk 				: BOOL; // Retrieve reallocation order successfully
	MoveOk 					: BOOL; // Move of zone executed successfully
	RelocEntry 				: ST_WindowTrackingReloc; // Reallocation order
	fbRelocator 			: FB_WindowRelocator; // Windows relocator
	ZoneOverrun				: BOOL;
	ZoneOverrunWindowIndex	: UINT;
END_VAR
VAR
	mIdx 					: DINT; // Loop iterator
	mNumberOfOverrunWindows : UINT;
	mEndOverrunWindowIndex	: UINT;
	mWindowIndex 			: UDINT; // Window index to loop trough tracking distance
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ShiftZone := FALSE;

// Validate inputs
IF mStartWindowIndex = 0 OR
   mStartWindowIndex > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   mWindowsToShift = 0 OR
   mWindowsToShift > WindowTracking.MAX_NUMBER_OF_WINDOWS OR
   WindowSize = 0 THEN
	RETURN;
END_IF

// Inform listener
IF iEventListener <> 0 THEN
	iEventListener.M_TrackingShiftingInitiatedEvent(
		mAbsolutePosition 	:= M_GetAbsolutePosition(mStartWindowIndex - 1 * WindowSize),
		mDistance 			:= mWindowsToShift * WindowSize,
		mWindowIndex 		:= mStartWindowIndex,
		mWindowsToShift 	:= mWindowsToShift);
END_IF

fbRelocator.M_Reset();

ShiftingAllowed := M_IsShiftable(
						mStartWindowIndex,
						mWindowsToShift,
						mExcludeTUs,
						mAllowOverrun,
						mZoneOverrun => ZoneOverrun,
						mZoneOverrunWindowIndex => ZoneOverrunWindowIndex,
						mfbRelocator := fbRelocator);

IF ShiftingAllowed THEN
	// Clear overrun distance if allowed
	IF ZoneOverrun THEN
		IF mStartWindowIndex = 1 THEN
			mEndOverrunWindowIndex := MaxWindowIndex;
		ELSE	
			mEndOverrunWindowIndex := mStartWindowIndex - 1;
		END_IF
	
		IF mEndOverrunWindowIndex >= ZoneOverrunWindowIndex THEN
			mNumberOfOverrunWindows := mEndOverrunWindowIndex - ZoneOverrunWindowIndex;
		ELSE
			mNumberOfOverrunWindows := mEndOverrunWindowIndex + MaxWindowIndex - ZoneOverrunWindowIndex;
		END_IF
		
		mWindowIndex := ZoneOverrunWindowIndex;
		
		// Clear all zones which can not be relocated
		FOR mIdx := 1 TO mNumberOfOverrunWindows DO
			IF WindowTable[mWindowIndex].ZoneIndex > 0 THEN
				M_DeleteZone(WindowTable[mWindowIndex].ZoneIndex);
			END_IF
			
			mWindowIndex := mWindowIndex + 1;
			
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR
	END_IF

	// Do reallocation
	// Execute all scheduled reallocations
	FOR mIdx := 1 TO MAX_NUMBER_OF_ZONES DO
		
		RetrieveOk := fbRelocator.M_RetrieveLastEntry(
						mpData 		:= ADR(RelocEntry),
						mDataSize 	:= SIZEOF(RelocEntry));
						
		// Move all zones according all stored reallocation orders starting with the last added
		IF RetrieveOk THEN
			MoveOk := M_MoveZone(
						mZoneIndex 				:= RelocEntry.ZoneIndex,
						mTargetStartWindow 		:= RelocEntry.TargetWindow,
						mEnableDeleteOfZones 	:= TRUE);
						
			IF NOT MoveOk THEN
				// Error
				fbDebugMsg.M_SendErrorMsg('M_ShiftZone - Move was not possible.');	
			END_IF
		ELSE
			// No entries available anymore
			EXIT;
		END_IF
	END_FOR
	
	// Shifting executed
	M_ShiftZone := TRUE;
ELSE
	M_ShiftZone := FALSE;
END_IF

// Inform listener
IF iEventListener <> 0 THEN
	iEventListener.M_TrackingShiftingCompletedEvent(
		mAbsolutePosition 	:= M_GetAbsolutePosition(mStartWindowIndex - 1 * WindowSize),
		mDistance 			:= mWindowsToShift * WindowSize,
		mWindowIndex 		:= mStartWindowIndex,
		mWindowsToShift 	:= mWindowsToShift);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ShortenZone" Id="{b360cdc1-2dbe-47ee-b030-dd6656ea1fa6}">
      <Declaration><![CDATA[/// Shortens a zone by given value in up- or downstream direction
METHOD M_ShortenZone : BOOL// Returns TRUE if successful,
VAR_INPUT
	mZoneIndex 				: UINT; // Zone index to enlarge
	mReductionLength		: UINT; // Reduce existing zone by this length [mm]
	mShiftFrontEdge			: BOOL; // Shift front edge for reduction
END_VAR
VAR
	mIdx					: UINT; // Loop iterator
	mWindowIndex			: UINT; // Start window index
	mReductionWindowLength	: UINT; // Zone length in windows
	mReductionAllowed 		: BOOL; // Reduction valid
	mZoneEndWindowIndex		: UINT; // Zone end window index
	mZoneStartWindowIndex	: UINT; // Zone start window index
	mZoneEndPositionNew		: UDINT; // Zone end position after reduction
	mZoneStartPositionNew	: UDINT; // Zone start position after enlargement
END_VAR
VAR_INST
	OldZoneData				: ST_WindowTrackingZone; // Old tracking zone data
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ShortenZone := FALSE;

// Validate inputs
IF mZoneIndex <= 0 OR
   mZoneIndex > MAX_NUMBER_OF_ZONES OR
   WindowSize = 0 THEN
   RETURN;
END_IF

IF ZoneTable[mZoneIndex].TU_Present THEN
	IF NOT mShiftFrontEdge THEN
		// Calculate new zone end position
		IF mReductionLength > ZoneTable[mZoneIndex].ZoneEndPosition THEN
			mZoneEndPositionNew := ZoneTable[mZoneIndex].ZoneEndPosition - mReductionLength + TotalTrackingLength;
			mReductionWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneEndPosition)) - M_GetWindowIndex(M_GetAbsolutePosition(mZoneEndPositionNew)) + MaxWindowIndex + 1;
		ELSE
			mZoneEndPositionNew := ZoneTable[mZoneIndex].ZoneEndPosition - mReductionLength;
			mReductionWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneEndPosition)) - M_GetWindowIndex(M_GetAbsolutePosition(mZoneEndPositionNew)) + 1;
		END_IF
		
		mWindowIndex := ZoneTable[mZoneIndex].ZoneEndWindowIndex;
		mReductionAllowed := TRUE;
		
		// Ensure reduction is possible
		FOR mIdx := 1 TO mReductionWindowLength DO
			// Is intended window index not occupied by TU
			IF WindowTable[mWindowIndex].State <> E_WindowTrackingWindowState.RESERVED THEN
				mReductionAllowed := FALSE;
				// Error
				fbDebugMsg.M_SendErrorMsg('M_ShortenZone - Reduction not possible, TU already in range of reduction.');	
				RETURN;
			END_IF
			
			mWindowIndex := mWindowIndex - 1;
			
			// Correct border overflow
			IF mWindowIndex = 0 THEN
				mWindowIndex := MaxWindowIndex;
			END_IF
		END_FOR
	ELSE
		// Calculate new zone start position
		IF ZoneTable[mZoneIndex].ZoneStartPosition + mReductionLength > TotalTrackingLength THEN
			mZoneStartPositionNew := ZoneTable[mZoneIndex].ZoneStartPosition + mReductionLength - TotalTrackingLength;
			mReductionWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(mZoneStartPositionNew)) - M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneStartPosition)) + MaxWindowIndex + 1;
		ELSE
			mZoneStartPositionNew := ZoneTable[mZoneIndex].ZoneStartPosition + mReductionLength;
			mReductionWindowLength := M_GetWindowIndex(M_GetAbsolutePosition(mZoneStartPositionNew)) - M_GetWindowIndex(M_GetAbsolutePosition(ZoneTable[mZoneIndex].ZoneStartPosition)) + 1;
		END_IF
		
		mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
		mReductionAllowed := TRUE;
		
		// Ensure reduction is possible
		FOR mIdx := 1 TO mReductionWindowLength DO
			// Is intended window index not occupied by TU
			IF WindowTable[mWindowIndex].State <> E_WindowTrackingWindowState.RESERVED THEN
				mReductionAllowed := FALSE;
				// Error
				fbDebugMsg.M_SendErrorMsg('M_ShortenZone - Reduction not possible, TU already in range of reduction.');	
				RETURN;
			END_IF
			
			mWindowIndex := mWindowIndex + 1;
			
			// Correct border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
		END_FOR
	END_IF
END_IF

// When reduction is possible to be executed
IF mReductionAllowed THEN
	OldZoneData := ZoneTable[mZoneIndex];
	
	IF NOT mShiftFrontEdge THEN
		mWindowIndex := ZoneTable[mZoneIndex].ZoneEndWindowIndex;
	
		// Loop through all windows and assign new zone
		// Init
		mZoneEndWindowIndex := mWindowIndex;
		
		FOR mIdx := 1 TO mReductionWindowLength DO
			// Clear window
			MEMSET(ADR(WindowTable[mWindowIndex]), 0, SIZEOF(WindowTable[mWindowIndex]));
			
			mWindowIndex := mWindowIndex - 1;
			
			// Correct border overflow
			IF mWindowIndex = 0 THEN
				mWindowIndex := MaxWindowIndex;
			END_IF
				
			mZoneEndWindowIndex := mWindowIndex;
		END_FOR	
		
		// Update zone table
		ZoneTable[mZoneIndex].ZoneEndWindowIndex := mZoneEndWindowIndex;
		ZoneTable[mZoneIndex].ZoneEndPosition := mZoneEndPositionNew;
		ZoneTable[mZoneIndex].ZoneLength := ZoneTable[mZoneIndex].ZoneLength - mReductionLength;
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneShortenedEvent(
				mTrackingZoneIndex 		:= mZoneIndex,
                mOldTrackingZoneData 	:= OldZoneData,
                mNewTrackingZoneDAta 	:= ZoneTable[mZoneIndex]);
		END_IF

		M_ShortenZone := TRUE;
	ELSE
		mWindowIndex := ZoneTable[mZoneIndex].ZoneStartWindowIndex;
	
		// Loop through all windows and assign new zone
		// Init
		mZoneStartWindowIndex := mWindowIndex;
		
		FOR mIdx := 1 TO mReductionWindowLength DO
			// Clear window
			MEMSET(ADR(WindowTable[mWindowIndex]), 0, SIZEOF(WindowTable[mWindowIndex]));
			
			mWindowIndex := mWindowIndex + 1;
			
			// Correct border overflow
			IF mWindowIndex > MaxWindowIndex THEN
				mWindowIndex := mWindowIndex - MaxWindowIndex;
			END_IF
				
			mZoneStartWindowIndex := mWindowIndex;
		END_FOR	
		
		// Update zone table
		ZoneTable[mZoneIndex].ZoneStartWindowIndex := mZoneStartWindowIndex;
		ZoneTable[mZoneIndex].ZoneStartPosition := mZoneStartPositionNew;
		ZoneTable[mZoneIndex].ZoneLength := ZoneTable[mZoneIndex].ZoneLength - mReductionLength;
		
		// Inform listener
		IF iEventListener <> 0 THEN
			iEventListener.M_TrackingZoneShortenedEvent(
				mTrackingZoneIndex 		:= mZoneIndex,
                mOldTrackingZoneData 	:= OldZoneData,
                mNewTrackingZoneDAta 	:= ZoneTable[mZoneIndex]);
		END_IF
		
		M_ShortenZone := TRUE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ShortenZoneAtWindow" Id="{40bc74b9-efaf-443d-a546-1a2effa19b65}">
      <Declaration><![CDATA[/// Shortes a zone from window to its boder where no TU is in between
METHOD PROTECTED M_ShortenZoneAtWindow : BOOL // Returns true if successful, otherwise false
VAR_INPUT
	mZoneIndex			: UINT;
	mWindowIndex		: UINT; // Start window index
END_VAR
VAR_INST
	ShortenAfterTU 		: BOOL; // Shorten on side between zone end and tu end
	ShortenInFrontOfTU 	: BOOL; // Shorten on side between tu start and zone start
	ShortenLengthMM		: UINT; // Length to shorten
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_ShortenZoneAtWindow := FALSE;
ShortenAfterTU:= FALSE;
ShortenInFrontOfTU := FALSE;
ShortenLengthMM := 0;

// Validate inputs
IF mWindowIndex = 0 OR
   mWindowIndex > WindowTracking.MAX_NUMBER_OF_WINDOWS OR 
   mZoneIndex = 0 THEN
	RETURN;
END_IF
 
IF WindowTable[mWindowIndex].ZoneIndex <> mZoneIndex THEN
	RETURN;
END_IF

IF ZoneTable[mZoneIndex].TU_Present THEN
	// Find related border (No TU between window index and border)
	//        |
	//        v     TU
	//            ||||||
	//   |--------||||||----|
	//   

	// Check for no overflow between zone end and tu rear edge
	IF ZoneTable[mZoneIndex].ZoneEndWindowIndex >= ZoneTable[mZoneIndex].TU_EndWindowIndex THEN
		// Check if window index is between
		IF mWindowIndex >= ZoneTable[mZoneIndex].TU_EndWindowIndex AND
		   mWindowIndex <= ZoneTable[mZoneIndex].ZoneEndWindowIndex THEN
		   // Window for shorten found
		   ShortenAfterTU := TRUE;
		   ShortenLengthMM := UDINT_TO_UINT(ZoneTable[mZoneIndex].ZoneEndPosition - ((mWindowIndex-1) * WindowSize));
		END_IF
	ELSE
		// Check if window index is between
		IF mWindowIndex >= ZoneTable[mZoneIndex].TU_EndWindowIndex THEN
		   	// Window for shorten found
		  	ShortenAfterTU := TRUE;
		   	ShortenLengthMM := UDINT_TO_UINT(ZoneTable[mZoneIndex].ZoneEndPosition + TotalTrackingLength - ((mWindowIndex-1) * WindowSize));
			
		ELSIF mWindowIndex <= ZoneTable[mZoneIndex].ZoneEndWindowIndex THEN
			// Window for shorten found
		   	ShortenAfterTU := TRUE;
		   	ShortenLengthMM := UDINT_TO_UINT(ZoneTable[mZoneIndex].ZoneEndPosition - ((mWindowIndex-1) * WindowSize));	
		END_IF
	END_IF
	
	// Check for no overflow between zone end and tu rear edge
	IF ZoneTable[mZoneIndex].TU_StartWindowIndex >= ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		// Check if window index is between
		IF mWindowIndex >= ZoneTable[mZoneIndex].ZoneStartWindowIndex AND
		   mWindowIndex <= ZoneTable[mZoneIndex].TU_StartWindowIndex THEN
		   // Window for shorten found
		   ShortenInFrontOfTU := TRUE;
		   ShortenLengthMM := UDINT_TO_UINT((mWindowIndex * WindowSize) - ZoneTable[mZoneIndex].ZoneStartPosition);
		END_IF
	ELSE
		// Check if window index is between
		IF mWindowIndex >= ZoneTable[mZoneIndex].ZoneStartWindowIndex THEN
		   	// Window for shorten found
		   	ShortenInFrontOfTU := TRUE;
		   	ShortenLengthMM := UDINT_TO_UINT((mWindowIndex * WindowSize) - ZoneTable[mZoneIndex].ZoneStartPosition);
		   
		ELSIF mWindowIndex <= ZoneTable[mZoneIndex].TU_StartWindowIndex THEN
			// Window for shorten found
		   	ShortenInFrontOfTU := TRUE;
		   	ShortenLengthMM := UDINT_TO_UINT((mWindowIndex * WindowSize) + TotalTrackingLength - ZoneTable[mZoneIndex].ZoneStartPosition);
		END_IF
	END_IF

	// When window was found inside a valid area of the zone
	IF ShortenInFrontOfTU OR ShortenAfterTU THEN
		IF ShortenInFrontOfTU THEN
			M_ShortenZoneAtWindow := M_ShortenZone(mZoneIndex, ShortenLengthMM, TRUE);
	  	ELSE
			M_ShortenZoneAtWindow := M_ShortenZone(mZoneIndex, ShortenLengthMM, FALSE);
		END_IF
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_DeleteZoneTrackingEnd" Id="{05b77ade-6117-4d16-b592-a6a32a63f0f8}">
      <Declaration><![CDATA[/// All Zones get deleted if they completly (Rear edge) left TrackingLength
/// Default: Enabled
PROPERTY P_DeleteZoneTrackingEnd : BOOL // Returns true if enabled, otherwise false]]></Declaration>
      <Get Name="Get" Id="{b3dbf710-efe8-4525-9cda-2cd13af61e10}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_DeleteZoneTrackingEnd := DeleteZoneTrackingEnd;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{7339db5b-264c-45b0-8047-38de9149b495}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[DeleteZoneTrackingEnd := P_DeleteZoneTrackingEnd;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_TrackingAddition" Id="{103e273b-67e9-4be0-9ba7-cc481966cdea}">
      <Declaration><![CDATA[/// Additional tracking length. Can be used to allow more additional space for reservations.
PROPERTY P_TrackingAddition : UDINT // Additional tracking distance]]></Declaration>
      <Get Name="Get" Id="{f07fbaf0-494c-46da-bd86-5c4d5f4a7c99}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_TrackingAddition := TrackingAddition;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{02a9110a-1f66-4b4a-a9e4-4390c31a087a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[TrackingAddition := P_TrackingAddition;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="P_TransferList" Id="{80d5faef-a0d4-42b3-8525-5781194f7b0e}">
      <Declaration><![CDATA[/// Access to Ongoing trasfer list  for read operations
/// Remark: User has to ensure that writing does not influence the process in a bad way.
{attribute 'suppress_wrn_C0410'}
PROPERTY P_TransferList : REFERENCE TO ARRAY[1..TRANSFER_TABLE_SIZE] OF ST_WindowTrackingTransfer]]></Declaration>
      <Get Name="Get" Id="{2c3a2542-cf5c-4e86-bd14-1b1952f29c80}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_TransferList REF= OngoingTransferList;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_TU_Count" Id="{6b488f27-acf7-47b0-b092-606d3d96af85}">
      <Declaration><![CDATA[/// Returns currently available amount of TUs
PROPERTY P_TU_Count : INT]]></Declaration>
      <Get Name="Get" Id="{a2dbed7c-8df2-45d1-beda-599b3c7eef34}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_TU_Count := TU_Count;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_WindowTable" Id="{2e36c3fe-c255-45dc-bcd3-e00da9932bce}">
      <Declaration><![CDATA[/// Access to Window table  for read operations
/// Remark: User has to ensure that writing does not influence the process in a bad way.
{attribute 'suppress_wrn_C0410'}
PROPERTY P_WindowTable : REFERENCE TO ARRAY[1..WindowTracking.MAX_NUMBER_OF_WINDOWS] OF ST_WindowTrackingWindow;]]></Declaration>
      <Get Name="Get" Id="{ce938b07-cb0d-448b-9e12-2593cb3b8350}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_WindowTable REF= WindowTable;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_ZoneCount" Id="{8a29b4a6-8470-4188-bb5d-98cb614f5c8a}">
      <Declaration><![CDATA[/// Returns currently available amount of Zones
PROPERTY P_ZoneCount : INT]]></Declaration>
      <Get Name="Get" Id="{2cc354f9-c67a-4891-ae45-61c8349df8bf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_ZoneCount := ZoneCount;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_ZoneTable" Id="{728e378f-0db2-4831-b262-bd53ec917f5b}">
      <Declaration><![CDATA[/// Access to Zone table  for read operations
/// Remark: User has to ensure that writing does not influence the process in a bad way.
{attribute 'suppress_wrn_C0410'}
PROPERTY P_ZoneTable : REFERENCE TO ARRAY[1..WindowTracking.MAX_NUMBER_OF_ZONES] OF ST_WindowTrackingZone;]]></Declaration>
      <Get Name="Get" Id="{e5840375-a011-44eb-9f62-c42ae7510d84}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_ZoneTable REF= ZoneTable;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <ObjectProperties>
      <XmlArchive>
        <Data>
          <o xml:space="preserve" t="UMLStereoTypeContainerObject">
            <v n="IsType" t="UMLType">BaseArea</v>
            <v n="Stereotype">""</v>
            <d n="Stereotypes" t="Hashtable" />
          </o>
        </Data>
        <TypeList>
          <Type n="Hashtable">System.Collections.Hashtable</Type>
          <Type n="String">System.String</Type>
          <Type n="UMLStereoTypeContainerObject">{30250973-b110-4e31-b562-c102e042dca4}</Type>
          <Type n="UMLType">{0197b136-405a-42ee-bb27-fd08b621d0cf}</Type>
        </TypeList>
      </XmlArchive>
    </ObjectProperties>
    <LineIds Name="FB_WindowTracking">
      <LineId Id="241" Count="100" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AddTU">
      <LineId Id="3" Count="88" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AddTU_FE">
      <LineId Id="3" Count="72" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AddTU_RE">
      <LineId Id="3" Count="110" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AddZoneToPTL">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AdjustFE">
      <LineId Id="3" Count="196" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AdjustRE">
      <LineId Id="3" Count="179" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AllocateFixedZone">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AllocateNextFreeZone">
      <LineId Id="3" Count="138" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_AssignNextFreeZone">
      <LineId Id="3" Count="87" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_CalculateTotalTrackingLength">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ClearTables">
      <LineId Id="3" Count="44" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ClearWindow">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_DeleteZone">
      <LineId Id="3" Count="92" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_EnlargeZone">
      <LineId Id="3" Count="163" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_FlushDistance">
      <LineId Id="3" Count="31" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetAbsolutePosition">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetDistanceToTU_End">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetDistanceToTU_Start">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetDistanceToZoneEnd">
      <LineId Id="3" Count="27" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetDistanceToZoneStart">
      <LineId Id="3" Count="27" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetFirstZoneIndex">
      <LineId Id="3" Count="104" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetLastZoneIndex">
      <LineId Id="3" Count="104" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetPendingAssignments">
      <LineId Id="3" Count="60" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetTrackingPosition">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetTU_EndPosition">
      <LineId Id="3" Count="26" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetTU_StartPosition">
      <LineId Id="3" Count="26" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetWindowIndex">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetZoneEndPosition">
      <LineId Id="3" Count="25" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetZoneIndex">
      <LineId Id="3" Count="42" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_GetZoneStartPosition">
      <LineId Id="3" Count="25" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_InhibitShifting">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_Init">
      <LineId Id="3" Count="31" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_InsertNewZoneIndex">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_IsShiftable">
      <LineId Id="3" Count="164" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_IsTU_InRange">
      <LineId Id="3" Count="89" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_IsTU_Present">
      <LineId Id="3" Count="31" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_IsZoneInRange">
      <LineId Id="3" Count="84" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MakeSpace">
      <LineId Id="3" Count="127" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MakeSpaceByWindows">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ManageOngoingTransfers">
      <LineId Id="3" Count="65" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MonitorZonesPTL">
      <LineId Id="3" Count="19" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MoveZone">
      <LineId Id="3" Count="137" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MoveZoneFE">
      <LineId Id="3" Count="90" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_MoveZoneRE">
      <LineId Id="3" Count="92" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_RemoveZoneFromPTL">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_RemoveZoneFromTransferList">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ReserveZone">
      <LineId Id="3" Count="122" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ResyncOnlyFE">
      <LineId Id="3" Count="215" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ResyncOnlyRE">
      <LineId Id="3" Count="212" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ResyncTU_FE">
      <LineId Id="3" Count="85" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ResyncTU_RE">
      <LineId Id="3" Count="79" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ShiftZone">
      <LineId Id="3" Count="100" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ShortenZone">
      <LineId Id="3" Count="148" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.M_ShortenZoneAtWindow">
      <LineId Id="3" Count="78" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_DeleteZoneTrackingEnd.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_DeleteZoneTrackingEnd.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_TrackingAddition.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_TrackingAddition.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_TransferList.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_TU_Count.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_WindowTable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_ZoneCount.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindowTracking.P_ZoneTable.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>