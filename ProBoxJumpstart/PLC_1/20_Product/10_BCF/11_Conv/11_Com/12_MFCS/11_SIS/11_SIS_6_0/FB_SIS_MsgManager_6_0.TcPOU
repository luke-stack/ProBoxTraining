<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_SIS_MsgManager_6_0" Id="{cb137b49-3aff-408d-aa48-921f0b7215bf}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SIS_MsgManager_6_0 IMPLEMENTS ITF_MFCS
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	SIS Manager V6.0
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
	Config				: ST_CFG_SIS_MsgManager_6_0; // Configuration
END_VAR

VAR
	Init				: BOOL := FALSE; // Instance initialized	
	RecvTelegram		: ARRAY [1..MAX_APP_DATA_LENGTH] OF BYTE; // Last telegram read from base drive
	SendTelegram		: ARRAY [1..MAX_APP_DATA_LENGTH] OF BYTE; // Last telegram read from base drive
	fbDebugMsg			: FB_DebugMsg; // Debug Messages
	DebugMsg			: STRING(MAX_STRING_LENGTH); // String to compose the logmessage
	fbBaseDriver		: FB_SIS_BaseDriver; // Base SIS driver
	TelegramType		: STRING(3); // SIS Telegram type from the incoming message
	eMsgType			: E_ITC_MsgTypeConv;
	ReceivedLength		: UDINT; // Received length
	WritePointer		: UDINT; // Write pointer to assembly data
	
	TTA					: ST_TTA_6_0; // Struct TTA IN
	TTA_ITC				: ST_ITC_TTA; // Struct TTA IN
	TDQ					: ST_TDQ_6_0; // Struct TDQ IN
	TDQ_ITC				: ST_ITC_TDQ; // Struct TDQ IN
	SCQ					: ST_SCQ_6_0; // Struct SCQ IN
	SCQ_ITC				: ST_ITC_SCQ; // Struct SCQ IN
	GCQ					: ST_GCQ_6_0; // Struct GCQ IN
	GCQ_ITC				: ST_ITC_GCQ; // Struct ECQ IN
	ECQ					: ST_ECQ_6_0; // Struct ECQ IN
	ECQ_ITC				: ST_ITC_ECQ; // Struct ECQ IN
	FCQ					: ST_FCQ_6_0; // Struct FCQ IN
	FCQ_ITC				: ST_ITC_FCQ; // Struct FCQ IN
	SSQ					: ST_SSQ_6_0; // Struct SSQ IN
	SSQ_ITC				: ST_ITC_SSQ; // Struct SSQ IN
	GSQ					: ST_GSQ_6_0; // Struct GSQ IN
	GSQ_ITC				: ST_ITC_GSQ; // Struct GSQ IN
	ESQ					: ST_ESQ_6_0; // Struct ESQ IN
	ESQ_ITC				: ST_ITC_ESQ; // Struct ESQ IN
	FSQ					: ST_FSQ_6_0; // Struct FSQ IN
	FSQ_ITC				: ST_ITC_FSQ; // Struct FSQ IN
	TUQ					: ST_TUQ_6_0; // Struct TUQ IN
	TUQ_ITC				: ST_ITC_TUQ; // Struct TUQ IN
	SIQ					: ST_SIQ_6_0; // Struct SIQ IN
	SIQ_ITC				: ST_ITC_SIQ; // Struct SIQ IN
	MCQ					: ST_MCQ_6_0; // Struct MCQ IN
	MCQ_ITC				: ST_ITC_MCQ; // Struct MCQ IN
	DIQ					: ST_DIQ_6_0; // Struct DIQ IN
	DIQ_ITC				: ST_ITC_DIQ; // Struct DIQ IN
	SDO					: ST_SDO_6_0; // Struct SDO IN
	SDO_ITC				: ST_ITC_SDO; // Struct SDO IN
	IRQ					: ST_IRQ_6_0; // Struct IRQ IN
	IRQ_ITC				: ST_ITC_IRQ; // Struct IRQ IN
	GVQ					: ST_GVQ_6_0; // Struct GVQ IN
	GVQ_ITC				: ST_ITC_GVQ; // Struct GVQ IN
	ECR					: ST_ECR_6_0; // Struct ECR OUT
	ECR_ITC				: ST_ITC_ECR; // Struct ECR OUT
	ESR					: ST_ESR_6_0; // Struct ESR OUT
	ESR_ITC				: ST_ITC_ESR; // Struct ESR ITC
	GCR					: ST_GCR_6_0; // Struct GCR OUT
	GCR_ITC				: ST_ITC_GCR; // Struct GCR ITC
	GSR					: ST_GSR_6_0; // Struct GSR OUT
	GSR_ITC				: ST_ITC_GSR; // Struct GSR ITC
	GVR					: ST_GVR_6_0; // Struct GVR OUT
	GVR_ITC				: ST_ITC_GVR; // Struct GVR ITC
	IPR					: ST_IPR_6_0; // Struct IPR OUT
	IPR_ITC				: ST_ITC_IPR; // Struct IPR ITC
	ISR					: ST_ISR_6_0; // Struct ISR OUT
	ISR_ITC				: ST_ITC_ISR; // Struct ISR ITC
	MCR					: ST_MCR_6_0; // Struct MCR OUT
	MCR_ITC				: ST_ITC_MCR; // Struct MCR ITC
	POR					: ST_POR_6_0; // Struct POR OUT
	POR_ITC				: ST_ITC_POR; // Struct POR ITC
	SCR					: ST_SCR_6_0; // Struct SCR OUT
	SCR_ITC				: ST_ITC_SCR; // Struct SCR ITC
	SDI					: ST_SDI_6_0; // Struct SDI OUT
	SDI_ITC				: ST_ITC_SDI; // Struct SDI ITC
	SIR					: ST_SIR_6_0; // Struct SIR OUT
	SIR_ITC				: ST_ITC_SIR; // Struct SIR ITC
	SNR					: ST_SNR_6_0; // Struct SNR OUT
	SNR_ITC				: ST_ITC_SNR; // Struct SNR ITC
	SSR					: ST_SSR_6_0; // Struct SSR OUT
	SSR_ITC				: ST_ITC_SSR; // Struct SSR ITC
	TDR					: ST_TDR_6_0; // Struct TDR OUT
	TDR_ITC				: ST_ITC_TDR; // Struct TDR ITC
	TTC					: ST_TTC_6_0; // Struct TTC OUT
	TTC_ITC				: ST_ITC_TTC; // Struct TTC ITC
	TTQ					: ST_TTQ_6_0; // Struct TTQ OUT
	TTQ_ITC				: ST_ITC_TTQ; // Struct TTQ ITC
	TUR					: ST_TUR_6_0; // Struct TUR OUT
	TUR_ITC				: ST_ITC_TUR; // Struct TUR ITC
	FSR					: ST_FSR_6_0; // Struct FSR OUT
	FSR_ITC				: ST_ITC_FSR; // Struct FSR ITC
	FCR					: ST_FCR_6_0; // Struct FCR OUT
	FCR_ITC				: ST_ITC_FCR; // Struct FCR ITC
	ATR					: ST_ATR_6_0; // Struct ATR OUT
	ATR_ITC				: ST_ITC_ATR; // Struct ATR ITC
	RTR					: ST_RTR_6_0; // Struct RTR OUT
	RTR_ITC				: ST_ITC_RTR; // Struct RTR ITC
	ERR					: ST_ERR_6_0; // Struct ERR OUT
	ERR_ITC				: ST_ITC_ERR; // Struct ERR ITC
	VIQ					: ST_VIQ_6_0; // Struct VIQ OUT
	VIQ_ITC				: ST_ITC_VIQ; // Struct VIQ ITC
	VIR					: ST_VIR_6_0; // Struct VIR OUT
	VIR_ITC				: ST_ITC_VIR; // Struct VIR ITC
	RAA					: ST_RAA_6_0; // Struct RAA OUT
	RAA_ITC				: ST_ITC_RAA; // Struct RAA ITC
	RAC					: ST_RAC_6_0; // Struct RAC OUT
	RAC_ITC				: ST_ITC_RAC; // Struct RAC OUT
	RDQ					: ST_RDQ_6_0; // Struct RDQ OUT
	RDQ_ITC				: ST_ITC_RDQ; // Struct RDQ OUT
	RDR					: ST_RDR_6_0; // Struct RDR OUT
	RDR_ITC				: ST_ITC_RDR; // Struct RDR ITC
	DAQ					: ST_DAQ_6_0; // Struct DAQ IN
	DAQ_ITC				: ST_ITC_DAQ; // Struct DAQ IN
	GDQ					: ST_GDQ_6_0; // Struct GDQ IN
	GDQ_ITC				: ST_ITC_GDQ; // Struct GDQ IN
	DAR					: ST_DAR_6_0; // Struct DAR OUT
	DAR_ITC				: ST_ITC_DAR; // Struct DAR ITC
	GDR					: ST_GDR_6_0; // Struct GDR OUT
	GDR_ITC				: ST_ITC_GDR; // Struct GDR ITC
	
	
	ECR_String			: T_MaxString; // String
	ESR_String			: T_MaxString; // String
	GCR_String			: T_MaxString; // String
	GSR_String			: T_MaxString; // String
	GVR_String			: T_MaxString; // String
	IPR_String			: T_MaxString; // String
	ISR_String			: T_MaxString; // String
	MCR_String			: T_MaxString; // String
	POR_String			: T_MaxString; // String
	SCR_String			: T_MaxString; // String
	SDI_String			: T_MaxString; // String
	SIR_String			: T_MaxString; // String
	SNR_String			: T_MaxString; // String
	SSR_String			: T_MaxString; // String
	TDR_String			: T_MaxString; // String
	TTC_String			: T_MaxString; // String
	TTQ_String			: T_MaxString; // String
	TUR_String			: T_MaxString; // String
	FSR_String			: T_MaxString; // String
	FCR_String			: T_MaxString; // String
	ATR_String			: T_MaxString; // String
	RTR_String			: T_MaxString; // String
	ERR_String			: T_MaxString; // String
	VIR_String			: T_MaxString; // String
	DAR_String			: T_MaxString; // String
	GDR_String			: T_MaxString; // String
	
	// Robot telegrams
	RCQ_String			: T_MaxString; // String
	RCA_String			: T_MaxString; // String
	RCC_String			: T_MaxString; // String
	RDQ_String			: T_MaxString; // String
	RDR_String			: T_MaxString; // String
	
	Idx					: INT; // Iterator
	TempInt				: INT; // Temporary integer
	IdxOffset			: INT; // Offset telegram length
	NoError				: BOOL; // Temporary no error bit
	BufferWarningActive : BOOL; // Buffer warning level active
	BufferAlarmActive 	: BOOL; // Buffer alarm level active
END_VAR

VAR PERSISTENT
	Settings			: ST_CFG_SIS_MsgManager_6_0; // Active configuration
END_VAR

VAR CONSTANT
	MAX_APP_DATA_LENGTH	: UDINT := 30000;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(**************************************************************************************************************
   SIS Manager - Body never called!
***************************************************************************************************************)
;
]]></ST>
    </Implementation>
    <Action Name="A_PutDAQ" Id="{afca6365-c9ef-498d-a162-a488f56c4b15}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutDAQ
 * 	FUNCTION	Process DAQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(DAQ), fillByte := 0, n := SIZEOF(DAQ));
				
// Copy the TDQ data fields to the DAQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET+1;
// Copy
MEMCPY(destAddr := ADR(DAQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(DAQ.NumberOfSets), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_NUMBEROFSETS));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_NUMBEROFSETS;
// Copy
MEMCPY(destAddr := ADR(DAQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_CODE));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_CODE;

FOR Idx := 1 TO STRING_TO_INT(DAQ.NumberOfSets) DO
	
	MEMCPY(destAddr := ADR(DAQ.Variable[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_VARIABLENAME));
 
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_VARIABLENAME;
	// Copy
	MEMCPY(destAddr := ADR(DAQ.MaxReportTime[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_MAXREPORTTIME));
   // Adjust index
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_MAXREPORTTIME;
	// Copy
	MEMCPY(destAddr := ADR(DAQ.SampleTime[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_SAMPLETIME));
	 // Adjust index
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_SAMPLETIME;
	// Copy
	MEMCPY(destAddr := ADR(DAQ.Threshold[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_THRESHOLD));
	 // Adjust index
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_THRESHOLD;
	// Copy
	MEMCPY(destAddr := ADR(DAQ.Option[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_BIT));
	 // Adjust index
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_BIT;
	// Copy
	MEMCPY(destAddr := ADR(DAQ.Enable[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_BIT));
	
	IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_BIT;
	
END_FOR



// Map to ITC
DAQ_ITC.Position :=  DAQ.Position;
DAQ_ITC.Code := STRING_TO_INT(DAQ.Code);
DAQ_ITC.NumberOfSets := STRING_TO_INT(DAQ.NumberOfSets);

FOR Idx := 1 TO STRING_TO_INT(DAQ.NumberOfSets) DO

	DAQ_ITC.Set[Idx].mVariableName := DAQ.Variable[Idx];
	DAQ_ITC.Set[Idx].MaxReportTime := F_MaxReportTime_TO_Time(sTimeIn:= DAQ.MaxReportTime[Idx]);
	DAQ_ITC.Set[Idx].SampleTime := F_SampleTime_TO_TIME(SampleTimeString:=DAQ.SampleTime[Idx]);
	DAQ_ITC.Set[Idx].Threshold := STRING_TO_INT(DAQ.Threshold[Idx]);
	DAQ_ITC.Set[Idx].Option := INT_TO_BOOL(STRING_TO_INT(DAQ.Option[Idx]));
	DAQ_ITC.Set[Idx].Enable :=  INT_TO_BOOL(STRING_TO_INT(DAQ.Enable[Idx]));
END_FOR

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.DATA_ACQUISITION_REQUEST,
			mpData		 := ADR(DAQ_ITC),
			mLen		 := SIZEOF(DAQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
ELSE	
	DebugMsg := 'DAQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);		
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutDIQ" Id="{277a1d66-1cfe-4db9-afbf-02661a80b0c3}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutDIQ
 * 	FUNCTION	Process DIQ
 **************************************************************************************)
 
// Clear structure
MEMSET(destAddr := ADR(DIQ), fillByte := 0, n := SIZEOF(DIQ));

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.DIGITAL_INPUT_REQUEST,
			mpData		 := 0,
			mLen		 := 0);

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'DIQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutECQ" Id="{e7a73871-9600-4d95-9afb-641d60ac8447}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutECQ
 * 	FUNCTION	Process ECQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(ECQ), fillByte := 0, n := SIZEOF(ECQ));

// Copy the ECQ data fields to the ECQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

// Copy
MEMCPY(destAddr := ADR(ECQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(ECQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLCODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.CONTROLCODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(ECQ.Variable), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLVARIABLE_STRINGLENGTH));


// Map to ITC
ECQ_ITC.Position := ECQ.Position;
ECQ_ITC.Code := STRING_TO_INT(ECQ.Code);
ECQ_ITC.Variable := STRING_TO_INT(ECQ.Variable);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeCOnv.ELEMENT_CONTROL_REQUEST,
			mpData		 := ADR(ECQ_ITC),
			mLen		 := SIZEOF(ECQ_ITC));

	
// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
ELSE	
	DebugMsg := 'ECQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutESQ" Id="{025a67ee-650f-4e7a-abf3-ba0724fcfdd8}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutESQ
 * 	FUNCTION	Process ESQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(ESQ), fillByte := 0, n := SIZEOF(ESQ));

// Copy the ESQ data fields to the ESQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

MEMCPY(destAddr := ADR(ESQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := 12);

// Map to ITC
ESQ_ITC.Position := ESQ.Position;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeCOnv.ELEMENT_STATUS_REQUEST,
			mpData		 := ADR(ESQ_ITC),
			mLen		 := SIZEOF(ESQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'ESQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutFCQ" Id="{9de7de37-b13c-411c-8ea0-9425bfd0f8d8}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutFCQ
 * 	FUNCTION	Process FCQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(FCQ), fillByte := 0, n := SIZEOF(FCQ));

// Copy the FCQ data fields to the FCQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

// Copy
MEMCPY(destAddr := ADR(FCQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(FCQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLCODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.CONTROLCODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(FCQ.Variable), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLVARIABLE_STRINGLENGTH));

// Map to ITC
FCQ_ITC.Position := FCQ.Position; 
FCQ_ITC.Code := STRING_TO_INT(FCQ.Code);
FCQ_ITC.Variable := STRING_TO_DINT(FCQ.Variable);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeCOnv.FUNCTION_CONTROL_REQUEST,
			mpData		 := ADR(FCQ_ITC),
			mLen		 := SIZEOF(FCQ_ITC));
	
// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'FCQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutFSQ" Id="{ad09782b-9306-4197-9c0c-b77e1ebae4a1}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutFSQ
 * 	FUNCTION	Process FSQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(FSQ), fillByte := 0, n := SIZEOF(FSQ));

// Copy the FSQ data fields to the FSQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(FSQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));

// Map to ITC
FSQ_ITC.Position := FSQ.Position; 

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeCOnv.FUNCTION_STATUS_REQUEST,
			mpData		 := ADR(FSQ_ITC),
			mLen		 := SIZEOF(FSQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'FSQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutGCQ" Id="{e55a53e9-3564-456e-9046-3bca8cd0f226}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutGCQ
 * 	FUNCTION	Process GCQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(GCQ), fillByte := 0, n := SIZEOF(GCQ));

// Copy the GCQ data fields to the GCQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(GCQ.GroupName), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GCQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLCODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.CONTROLCODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GCQ.Variable), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLVARIABLE_STRINGLENGTH));

// Map to ITC
GCQ_ITC.Position := GCQ.GroupName;
GCQ_ITC.Code := STRING_TO_INT(GCQ.Code);
GCQ_ITC.Variable := STRING_TO_DINT(GCQ.Variable);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.GROUP_CONTROL_REQUEST,
			mpData		 := ADR(GCQ_ITC),
			mLen		 := SIZEOF(GCQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'GCQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutGDQ" Id="{7fe40808-3f66-44db-bf6e-d8bbf07b82d3}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutGDQ
 * 	FUNCTION	Process GDQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(GDQ), fillByte := 0, n := SIZEOF(GDQ));

// Copy the GDQ data fields to the GDQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET+1;
// Copy
MEMCPY(destAddr := ADR(GDQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GDQ.Variable), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DATA_ACQUISITION_VARIABLENAME));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DATA_ACQUISITION_VARIABLENAME;

// Map to ITC
GDQ_ITC.Position :=  GDQ.Position;
GDQ_ITC.Variable :=  GDQ.Variable;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.GATHERED_DATA_REQUEST,
			mpData		 := ADR(GDQ_ITC),
			mLen		 := SIZEOF(GDQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'GDQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutGSQ" Id="{b501f4e1-aebc-4c32-82bd-e440c25b28fc}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutGSQ
 * 	FUNCTION	Process GSQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(GSQ), fillByte := 0, n := SIZEOF(GSQ));

// Copy the GSQ data fields to the GSQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

MEMCPY(destAddr := ADR(GSQ.GroupName), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));

// Map to ITC
GSQ_ITC.Position := GSQ.GroupName;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.GROUP_STATUS_REQUEST,
			mpData		 := ADR(GSQ_ITC),
			mLen		 := SIZEOF(GSQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'GSQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutGVQ" Id="{303cecd2-3349-49e0-a363-dfe94f1c155a}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutGVQ
 * 	FUNCTION	Process GVQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(GVQ), fillByte := 0, n := SIZEOF(GVQ));

// Copy the GVQ data fields to the GVQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(GVQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_CODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_CODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Number), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_NUMBER_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_NUMBER_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Quantity), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_QUANTITY_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_QUANTITY_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[0]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[1]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[2]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[3]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[4]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[5]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[6]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[7]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[8]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.GVQ_VARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(GVQ.Variable[9]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.GVQ_VARIABLE_STRINGLENGTH));

// Map to ITC
GVQ_ITC.Code := STRING_TO_INT(GVQ.Code);
GVQ_ITC.Number := STRING_TO_INT(GVQ.Number);
GVQ_ITC.Quantity := STRING_TO_INT(GVQ.Quantity);
GVQ_ITC.Variable[0] := STRING_TO_DINT(GVQ.Variable[0]);
GVQ_ITC.Variable[1] := STRING_TO_DINT(GVQ.Variable[1]);
GVQ_ITC.Variable[2] := STRING_TO_DINT(GVQ.Variable[2]);
GVQ_ITC.Variable[3] := STRING_TO_DINT(GVQ.Variable[3]);
GVQ_ITC.Variable[4] := STRING_TO_DINT(GVQ.Variable[4]);
GVQ_ITC.Variable[5] := STRING_TO_DINT(GVQ.Variable[5]);
GVQ_ITC.Variable[6] := STRING_TO_DINT(GVQ.Variable[6]);
GVQ_ITC.Variable[7] := STRING_TO_DINT(GVQ.Variable[7]);
GVQ_ITC.Variable[8] := STRING_TO_DINT(GVQ.Variable[8]);
GVQ_ITC.Variable[9] := STRING_TO_DINT(GVQ.Variable[9]);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.GLOBAL_VARIABLE_REQUEST,
			mpData		 := ADR(GVQ_ITC),
			mLen	 := SIZEOF(GVQ_ITC));
	
// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'GVQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutIRQ" Id="{793ca8f7-0a09-45c4-aaa0-49a04f43581e}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutIRQ
 * 	FUNCTION	Process IRQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(IRQ), fillByte := 0, n := SIZEOF(IRQ));

// Copy the IRQ data fields to the IRQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(IRQ.SignalType), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.IRQ_SIGNALTYPE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.IRQ_SIGNALTYPE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(IRQ.StartSignalNumber), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.IRQ_START_SIGNAL_NUMBER_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.IRQ_START_SIGNAL_NUMBER_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(IRQ.DataLength), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.IRQ_DATALENGTH_STRINGLENGTH));

// Map to ITC
IRQ_ITC.DataLength := STRING_TO_INT(IRQ.DataLength);
IRQ_ITC.SignalType := STRING_TO_INT(IRQ.SignalType);
IRQ_ITC.StartSignalNumber := STRING_TO_INT(IRQ.StartSignalNumber);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.I_O_STATUS_REQUEST,
			mpData		 := ADR(IRQ_ITC),
			mLen		 := SIZEOF(IRQ_ITC));


// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'IRQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutMCQ" Id="{53c4e627-355b-41cf-a7c7-0a46c99aef81}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutMCQ
 * 	FUNCTION	Process MCQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(MCQ), fillByte := 0, n := SIZEOF(MCQ));

// Copy the MCQ data fields to the MCQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(MCQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_CODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_CODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Speed), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_SPEED_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_SPEED_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis1Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis1Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis2Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n :=INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis2Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis3Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis3Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis4Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis4Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis5Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis5Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis6Fwd), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Axis6Rev), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_AXIS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_AXIS_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Button1), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_BUTTON_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MCQ_BUTTON_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(MCQ.Button2), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MCQ_BUTTON_STRINGLENGTH));

// Map to ITC
MCQ_ITC.Position 	:= MCQ.Position;
MCQ_ITC.Code		:= STRING_TO_INT(MCQ.Code);
MCQ_ITC.Speed		:= MCQ.Speed = '1';
MCQ_ITC.Axis1Fwd	:= MCQ.Axis1Fwd = '1';
MCQ_ITC.Axis1Rev	:= MCQ.Axis1Rev = '1';
MCQ_ITC.Axis2Fwd	:= MCQ.Axis2Fwd = '1';
MCQ_ITC.Axis2Rev	:= MCQ.Axis2Rev = '1';
MCQ_ITC.Axis3Fwd	:= MCQ.Axis3Fwd = '1';
MCQ_ITC.Axis3Rev	:= MCQ.Axis3Rev = '1';
MCQ_ITC.Axis4Fwd	:= MCQ.Axis4Fwd = '1';
MCQ_ITC.Axis4Rev	:= MCQ.Axis4Rev = '1';
MCQ_ITC.Axis5Fwd	:= MCQ.Axis5Fwd = '1';
MCQ_ITC.Axis5Rev	:= MCQ.Axis5Rev = '1';
MCQ_ITC.Axis6Fwd	:= MCQ.Axis6Fwd = '1';
MCQ_ITC.Axis6Rev	:= MCQ.Axis6Rev = '1';
MCQ_ITC.Button1		:= MCQ.Button1 = '1';
MCQ_ITC.Button2		:= MCQ.Button2 = '1';

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.MANUAL_CONTROL_REQUEST,
			mpData		 := ADR(MCQ_ITC),
			mLen		 := SIZEOF(MCQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'MCQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutRAA" Id="{c5b2ca05-c99c-461f-a7b7-238c193e81cd}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutRAA
 * 	FUNCTION	Process RAA
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(RAA), fillByte := 0, n := SIZEOF(RAA));

// Copy the RAA data fields to the RAA data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(RAA.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.CommandDataIndex), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_COMMAND_DATA_INDEX_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_COMMAND_DATA_INDEX_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.CommandPriority), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_COMMAND_PRIORITY_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_COMMAND_PRIORITY_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.AssignmentID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_ASSIGNMENT_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_ASSIGNMENT_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.CommandSequenceIndex), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_SEQUENCE_INDEX_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_SEQUENCE_INDEX_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.CommandSequenceSize), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_SEQUENCE_SIZE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_SEQUENCE_SIZE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RAA.CommandArgsCount), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_COMMAND_ARGS_COUNT_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RAA_COMMAND_ARGS_COUNT_STRINGLENGTH;

IF STRING_TO_INT(RAA.CommandArgsCount) <= SIS_6_0.RAA_NUMBER_OF_COMMAND_ARGS THEN
	FOR Idx := 1 TO STRING_TO_INT(RAA.CommandArgsCount) BY 1 DO
		// Copy
		MEMCPY(destAddr := ADR(RAA.CommandArgs[Idx].Key), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_COMMAND_ARGS_KEY_STRINGLENGTH));
		// Adjust index
		IdxOffset := IdxOffset + SIS_6_0.RAA_COMMAND_ARGS_KEY_STRINGLENGTH;
		// Copy
		MEMCPY(destAddr := ADR(RAA.CommandArgs[Idx].Value), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_COMMAND_ARGS_VALUE_STRINGLENGTH));
		// Adjust index
		IdxOffset := IdxOffset + SIS_6_0.RAA_COMMAND_ARGS_VALUE_STRINGLENGTH;
	END_FOR
END_IF

// Copy
MEMCPY(destAddr := ADR(RAA.RobotCommand), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RAA_ROBOT_COMMAND_STRINGLENGTH));

// Map to ITC
RAA_ITC.Position				:= RAA.Position;
RAA_ITC.CommandDataIndex		:= STRING_TO_INT(RAA.CommandDataIndex);
RAA_ITC.CommandPriority			:= STRING_TO_INT(RAA.CommandPriority);
RAA_ITC.AssignmentID			:= STRING_TO_UDINT(RAA.AssignmentID);
RAA_ITC.GroupID					:= STRING_TO_ULINT(RAA.CommandSequenceIndex);
RAA_ITC.LastGroupInSequence		:= STRING_TO_INT(RAA.CommandSequenceSize);
RAA_ITC.CommandArgsCount		:= STRING_TO_DINT(RAA.CommandArgsCount);

FOR Idx := 1 TO STRING_TO_INT(RAA.CommandArgsCount) BY 1 DO 
	RAA_ITC.CommandArgs[Idx].Key	:= RAA.CommandArgs[Idx].Key;
	RAA_ITC.CommandArgs[Idx].Value	:= RAA.CommandArgs[Idx].Value;
END_FOR

RAA_ITC.RobotCommand				:= RAA.RobotCommand;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.ROBOT_ACTION_ASSIGNMENT,
			mpData		 := ADR(RAA_ITC),
			mLen		 := SIZEOF(RAA_ITC));
			
IF NoError THEN			
	// Message processed
	fbBaseDriver.M_ProcessedMsg();

ELSE	
	DebugMsg := 'RAA - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutRDQ" Id="{283a83a3-917c-4b7c-ba23-676f0351b5d7}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutRDQ
 * 	FUNCTION	Process RDQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(RDQ), fillByte := 0, n := SIZEOF(RDQ));

// Copy the RDQ data fields to the RDQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(RDQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RDQ.CommandDataIndex), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RDQ_COMMAND_DATA_INDEX_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RDQ_COMMAND_DATA_INDEX_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RDQ.AssignmentID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RDQ.CommandSequenceIndex), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.RDQ_COMMAND_SEQUENCE_INDEX_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.RDQ_COMMAND_SEQUENCE_INDEX_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(RDQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.ERR_CODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.ERR_CODE_STRINGLENGTH;

// Map to ITC
RDQ_ITC.Position	 		:= RDQ.Position;
RDQ_ITC.CommandDataIndex	:= STRING_TO_INT(RDQ.CommandDataIndex);
RDQ_ITC.AssignmentID		:= STRING_TO_UDINT(RDQ.AssignmentID);
RDQ_ITC.GroupID				:= STRING_TO_ULINT(RDQ.CommandSequenceIndex);
RDQ_ITC.Code				:= STRING_TO_INT(RDQ.Code);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.ROBOT_DELETE_REQUEST,
			mpData		 := ADR(RDQ_ITC),
			mLen		 := SIZEOF(RDQ_ITC));
			
IF NoError THEN			
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
ELSE	
	DebugMsg := 'RDQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF	]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutSCQ" Id="{28a48d3d-24d0-46b3-8fa9-1c659c20d66c}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutSCQ
 * 	FUNCTION	Process SCQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(SCQ), fillByte := 0, n := SIZEOF(SCQ));

// Copy the SCQ data fields to the SCQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(SCQ.SubsystemName), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(SCQ.Code), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLCODE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.CONTROLCODE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(SCQ.Variable), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.CONTROLVARIABLE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.CONTROLVARIABLE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(SCQ.SystemTime), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TIMESTAMP_STRINGLENGTH));
 
// Map to ITC
SCQ_ITC.SubsystemName := SCQ.SubsystemName;
SCQ_ITC.Code := STRING_TO_INT(SCQ.Code);
SCQ_ITC.Variable := STRING_TO_DINT(SCQ.Variable);
SCQ_ITC.SystemTime := SCQ.SystemTime;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.SUBSYSTEM_CONTROL_REQUEST,
			mpData		 := ADR(SCQ_ITC),
			mLen		 := SIZEOF(SCQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'SCQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutSDO" Id="{11c5f0df-a727-44a2-883f-b6e019b21704}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutSDO
 * 	FUNCTION	Process SDO
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(SDO), fillByte := 0, n := SIZEOF(SDO));

// Copy the SDO data fields to the SDO data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

// Copy
MEMCPY(destAddr := ADR(SDO.SignalNumber), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.SDO_SIGNAL_NUMBER_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.SDO_SIGNAL_NUMBER_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(SDO.SignalState), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.SDO_SIGNALSTATE_STRINGLENGTH));


// Map to ITC
SDO_ITC.SignalNumber := STRING_TO_INT(SDO.SignalNumber);
SDO_ITC.SignalState := STRING_TO_INT(SDO.SignalState);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.SET_DIGITAL_OUTPUT,
			mpData		 := ADR(SDO_ITC),
			mLen		 := SIZEOF(SDO_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'SDO - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutSIQ" Id="{9bd59ac7-1635-4a0e-8b10-a268ac6a210e}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutSIQ
 * 	FUNCTION	Process SIQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(SIQ), fillByte := 0, n := SIZEOF(SIQ));

// Copy the SIQ data fields to the SIQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

// Copy
MEMCPY(destAddr := ADR(SIQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(SIQ.CODE), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.SIQ_CODE_STRINGLENGTH));

// Map to ITC
SIQ_ITC.Position := SIQ.Position;
SIQ_ITC.Code := STRING_TO_INT(SIQ.Code);

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.SCANNER_INFORMATION_REQUEST,
			mpData		 := ADR(SIQ_ITC),
			mLen		 := SIZEOF(SIQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'SIQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutSSQ" Id="{8a6b8ea4-7eb7-4774-a619-6235b4662d59}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutSSQ
 * 	FUNCTION	Process SSQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(SSQ), fillByte := 0, n := SIZEOF(SSQ));

// Copy the SSQ data fields to the PLQ data structure
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(SSQ.SubsystemName), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));


// Map to ITC
SSQ_ITC.Position := SSQ.SubsystemName;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.SUBSYSTEM_STATUS_REQUEST,
			mpData		 := ADR(SSQ_ITC),
			mLen		 := SIZEOF(SSQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'SSQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutTDQ" Id="{eba49d2e-28d9-49dc-a5f5-15980001f7f3}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutTDQ
 * 	FUNCTION	Process TDQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(TDQ), fillByte := 0, n := SIZEOF(TDQ));
				
// Copy the TDQ data fields to the TDQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(TDQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TDQ.TU_ID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TU_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TU_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TDQ.AssignmentID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TDQ.MsgSequence), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MSG_SEQUENCE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MSG_SEQUENCE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TDQ.CODE), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TDQ_CODE_STRINGLENGTH));


// Map to ITC
TDQ_ITC.Position := TDQ.Position;
TDQ_ITC.Code := STRING_TO_INT(TDQ.Code);
TDQ_ITC.MsgSequence := STRING_TO_INT(TDQ.MsgSequence);
TDQ_ITC.AssignmentID := STRING_TO_UDINT(TDQ.AssignmentID);
TDQ_ITC.TU_ID := TDQ.TU_ID;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.TASK_DELETE_REQUEST,
			mpData		 := ADR(TDQ_ITC),
			mLen		 := SIZEOF(TDQ_ITC));


// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'TDQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutTTA" Id="{81695a8e-09de-4ffe-8f77-cd2fec387764}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutTTA
 * 	FUNCTION	Process TTA
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(TTA), fillByte := 0, n := SIZEOF(TTA));

// Copy the TTA data fields to the TTA data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(TTA.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.TU_DataIndex), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TU_DATAINDEX_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TU_DATAINDEX_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.MsgSequence), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.MSG_SEQUENCE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.MSG_SEQUENCE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.TU_ID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TU_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TU_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.TU_Type), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TU_TYPE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TU_TYPE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.AssignmentID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.Length), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DIMENSIONS));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DIMENSIONS;
// Copy
MEMCPY(destAddr := ADR(TTA.Width), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DIMENSIONS));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DIMENSIONS;
// Copy
MEMCPY(destAddr := ADR(TTA.Height), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.DIMENSIONS));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.DIMENSIONS;
// Copy
MEMCPY(destAddr := ADR(TTA.Weight), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_WEIGHT));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_WEIGHT;
// Copy
MEMCPY(destAddr := ADR(TTA.Orientation), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_ORIENTATION));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_ORIENTATION;
// Copy
MEMCPY(destAddr := ADR(TTA.TU_Parameter), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_TU_PARAMETER));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_TU_PARAMETER;
// Copy
MEMCPY(destAddr := ADR(TTA.IO_Data), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_IO_DATA_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_IO_DATA_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.LowerLimit), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_LOWER_LIMIT_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_LOWER_LIMIT_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.UpperLimit), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_UPPER_LIMIT_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_UPPER_LIMIT_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.GroupInfo), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_GROUPINFO_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_GROUPINFO_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.Sequence), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_SEQUENCE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_SEQUENCE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.NumberInSequence), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_NO_IN_SEQUENCE_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_NO_IN_SEQUENCE_STRINGLENGTH;
// Copy
MEMCPY(destAddr := ADR(TTA.NumberOfDestinations), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TTA_NO_OF_DESTINATIONS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TTA_NO_OF_DESTINATIONS_STRINGLENGTH;

// Based on the "NumberOfDestinations in the TTA, obtain and store all the destinations 
FOR Idx := 1 TO STRING_TO_INT(TTA.NumberOfDestinations) DO
	// offset = ((Index - 1) * DestinationFieldLength  + BaseAddress ) 
	TempInt 		:= (((Idx - 1) * SIS_6_0.POSITION_STRINGLENGTH) + IdxOffset);
	MEMCPY(destAddr := ADR(TTA.Destination[idx]), srcAddr := ADR(RecvTelegram[TempInt]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
END_FOR

// Map to ITC
TTA_ITC.Position :=  TTA.Position;
TTA_ITC.TU_DataIndex := STRING_TO_INT(TTA.TU_DataIndex);
TTA_ITC.MsgSequence := STRING_TO_INT(TTA.MsgSequence);
TTA_ITC.TU_ID := TTA.TU_ID;
TTA_ITC.TU_Type := STRING_TO_INT(TTA.TU_Type);
TTA_ITC.AssignmentID := STRING_TO_UDINT(TTA.AssignmentID);
TTA_ITC.Length := STRING_TO_INT(TTA.Length);
TTA_ITC.Width := STRING_TO_INT(TTA.Width);
TTA_ITC.Height := STRING_TO_INT(TTA.Height);
TTA_ITC.Weight := STRING_TO_DINT(TTA.Weight);
TTA_ITC.Orientation := TTA.Orientation;
TTA_ITC.TU_Parameter := STRING_TO_INT(TTA.TU_Parameter);
TTA_ITC.IO_Data := STRING_TO_INT(TTA.IO_Data);
TTA_ITC.LowerLimit := STRING_TO_DINT(TTA.LowerLimit);
TTA_ITC.UpperLimit := STRING_TO_DINT(TTA.UpperLimit);
TTA_ITC.GroupID := STRING_TO_ULINT(TTA.GroupInfo);
TTA_ITC.Sequence := STRING_TO_ULINT(TTA.Sequence);
TTA_ITC.SubSequence := STRING_TO_INT(TTA.NumberInSequence);
TTA_ITC.NumberOfDestinations := STRING_TO_INT(TTA.NumberOfDestinations);
TTA_ITC.Destination := TTA.Destination;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.TRANSPORT_TASK_ASSIGNMENT,
			mpData		 := ADR(TTA_ITC),
			mLen		 := SIZEOF(TTA_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
ELSE	
	DebugMsg := 'TTA - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutTUQ" Id="{c3db037e-06cc-4ab9-916d-6f63a55f1731}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutTUQ
 * 	FUNCTION	Process TUQ
 **************************************************************************************)

// Clear data structure 
MEMSET(destAddr := ADR(TUQ), fillByte := 0, n := SIZEOF(TUQ));

// Copy the TUQ data fields to the TUQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;

MEMCPY(destAddr := ADR(TUQ.TU_ID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.TU_ID_STRINGLENGTH));

// Adjust index
IdxOffset := IdxOffset + SIS_6_0.TU_ID_STRINGLENGTH;

MEMCPY(destAddr := ADR(TUQ.AssignmentID), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH));

// Map to ITC
TUQ_ITC.AssignmentID := STRING_TO_UDINT(TUQ.AssignmentID);
TUQ_ITC.TU_ID := TUQ.TU_ID;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.TRANSPORT_UNIT_REQUEST,
			mpData		 := ADR(TUQ_ITC),
			mLen		 := SIZEOF(TUQ_ITC));
				
// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'TUQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_PutVIQ" Id="{be35b43b-1edd-4d38-b743-cb669e31b980}">
      <Implementation>
        <ST><![CDATA[(**************************************************************************************
 * 	NAME		A_PutVIQ
 * 	FUNCTION	Process VIQ
 **************************************************************************************)
 
// Clear data structure 
MEMSET(destAddr := ADR(VIQ), fillByte := 0, n := SIZEOF(VIQ));

// Copy the VIQ data fields to the VIQ data structure 
IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
// Copy
MEMCPY(destAddr := ADR(VIQ.Position), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.POSITION_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.POSITION_STRINGLENGTH;
//Copy
MEMCPY(destAddr := ADR(VIQ.NumberOfKeys), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.VIQ_NUMBER_OF_KEYS_STRINGLENGTH));
// Adjust index
IdxOffset := IdxOffset + SIS_6_0.VIQ_NUMBER_OF_KEYS_STRINGLENGTH;

IF STRING_TO_INT(VIQ.NumberOfKeys) <= System.NUMBER_OF_KEYS_VIQ THEN
	FOR Idx := 1 TO STRING_TO_INT(VIQ.NumberOfKeys) BY 1 DO
		// Copy
		MEMCPY(destAddr := ADR(VIQ.Keys[Idx]), srcAddr := ADR(RecvTelegram[IdxOffset]), n := INT_TO_UDINT(SIS_6_0.VIQ_KEY_STRINGLENGTH));
		// Adjust index
		IdxOffset := IdxOffset + SIS_6_0.VIQ_KEY_STRINGLENGTH; 
	END_FOR
END_IF
// Map to ITC
VIQ_ITC.Position := VIQ.Position;
VIQ_ITC.NumberOfKeys := STRING_TO_INT(VIQ.NumberOfKeys);
VIQ_ITC.Keys := VIQ.Keys;

// Forward to mirror channel
M_MirrorData(Data := ADR(RecvTelegram), DataLen := ReceivedLength);

// Forward message to ITC
NoError := fbITC_Manager.M_AddData(
			meChannelSrc := Settings.MFCS_Channel,
			mMsgType	 := E_ITC_MsgTypeConv.VISUALIZATION_INFORMATION_REQUEST,
			mpData		 := ADR(VIQ_ITC),
			mLen		 := SIZEOF(VIQ_ITC));

// If forwarding was successful
IF NoError THEN
	// Message processed
	fbBaseDriver.M_ProcessedMsg();
	
ELSE	
	DebugMsg := 'VIQ - Could not be forwarded to ITC';
	fbDebugMsg.M_SendErrorMsg(DebugMsg);	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Method Name="M_BufferLevelAlarm" Id="{3c9cc46b-af90-4231-bf8f-b5b982298506}">
      <Declaration><![CDATA[METHOD M_BufferLevelAlarm : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	If buffer fill quantity exeeds a certain level, return an
 *						alarm.
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Set bufffer alarm if buffer level exeeds a certain level
IF fbBaseDriver.SendBufferQuantity > Settings.BufferLevelAlarm THEN
	BufferAlarmActive := TRUE;
	
// Reset bufffer alarm if buffer level is lower the hyst	
ELSIF BufferAlarmActive AND
	  fbBaseDriver.SendBufferQuantity < Settings.BufferLevelAlarm - Settings.BufferLevelHysterese THEN
	BufferAlarmActive := FALSE;
END_IF

M_BufferLevelAlarm := BufferAlarmActive;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_BufferLevelWarning" Id="{d1418555-60ed-441b-b864-dc1208299c4a}">
      <Declaration><![CDATA[METHOD M_BufferLevelWarning : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	If buffer fill quantity exeeds a certain level, return a
 *						warning.
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Set buffer warning if buffer level exeeds a certain level
IF fbBaseDriver.SendBufferQuantity > Settings.BufferLevelWarning THEN
	BufferWarningActive := TRUE;
	
// Reset buffer warning if buffer level is lower the hyst	
ELSIF BufferWarningActive AND
	  fbBaseDriver.SendBufferQuantity < Settings.BufferLevelWarning - Settings.BufferLevelHysterese THEN
	BufferWarningActive := FALSE;
END_IF

M_BufferLevelWarning := BufferWarningActive;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CallCommunicationService" Id="{cbea2037-da76-4b3d-9c1c-719d8a7314db}">
      <Declaration><![CDATA[{attribute 'object_name' := 'M_CallCommunicationService'}
METHOD M_CallCommunicationService
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Call communication service
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(**************************************************************************************************************
 	Initialization
***************************************************************************************************************)
M_Init(FALSE);


(**************************************************************************************************************
   Call SIS BaseDriver
***************************************************************************************************************)
fbBaseDriver(
	Settings 		   := Settings.BaseDriver,
	pRecvAppData	   := ADR(RecvTelegram),
	RecvAppDataLen	   := SIZEOF(RecvTelegram),
	ReceivedAppDataLen => ReceivedLength);


(**************************************************************************************************************
   Buffering incoming data 
***************************************************************************************************************)
(*
It is possible, that the currently processed telegram, takes longer 
than one cycle. Therefore by the base driver provided data needs to 
be buffered.
*)

// If new application data are available
IF fbBaseDriver.NewAppData THEN
	// Get the TYPE of telegram which was received 
	MEMCPY(destAddr := ADR(TelegramType), srcAddr := ADR(RecvTelegram), n := 3);
	
	// Transport Task Assignment
	IF TelegramType = 'TTA' THEN
		// Process
		A_PutTTA();
		
	// Transport Delete Request
	ELSIF TelegramType = 'TDQ' THEN
		// Process
		A_PutTDQ();
	
	// Subsystem Control Request
	ELSIF TelegramType = 'SCQ' THEN	
		// Process
		A_PutSCQ();
	
	// Group Control Request
	ELSIF TelegramType = 'RAA' THEN
		// Process
		A_PutRAA();
	
	// Visualisation Information Request
	ELSIF TelegramType = 'VIQ' THEN
		// Process
		A_PutVIQ();	
	
	// Robot Delete Request		
	ELSIF TelegramType = 'RDQ' THEN
		// Process
		A_PutRDQ();
	
	// Group Control Request
	ELSIF TelegramType = 'GCQ' THEN	
		// Process
		A_PutGCQ();
	
	// Element Control Request
	ELSIF TelegramType = 'ECQ' THEN	
		// Process
		A_PutECQ();
	
	// Function Control Request
	ELSIF TelegramType = 'FCQ' THEN	
		// Process
		A_PutFCQ();
	
	// Subsystem Status Request
	ELSIF TelegramType = 'SSQ' THEN	
		// Process
		A_PutSSQ();
	
	// Group Status Request
	ELSIF TelegramType = 'GSQ' THEN	
		// Process
		A_PutGSQ();
		
	// Element Status Request
	ELSIF TelegramType = 'ESQ' THEN	
		// Process
		A_PutESQ();
	
	// Function Status Request
	ELSIF TelegramType = 'FSQ' THEN	
		// Process
		A_PutFSQ();

	// Transport Unit Request
	ELSIF TelegramType = 'TUQ' THEN	
		// Process
		A_PutTUQ();
	
	// Scanner Information Request
	ELSIF TelegramType = 'SIQ' THEN	
		// Process
		A_PutSIQ();

	// Manual Control Request
	ELSIF TelegramType = 'MCQ' THEN	
		// Process
		A_PutMCQ();
	
	// Digital Input Request
	ELSIF TelegramType = 'DIQ' THEN	
		// Process
		A_PutDIQ();
	
	// Set Digital Output
	ELSIF TelegramType = 'SDO' THEN	
		// Process
		A_PutSDO();
		
	// I/O Status Request
	ELSIF TelegramType = 'IRQ' THEN	
		// Process
		A_PutIRQ();
	
	// Global Variable Request
	ELSIF TelegramType = 'GVQ' THEN	
		// Process
		A_PutGVQ();
		
	// Customized message
	ELSIF TelegramType = 'MSG' THEN	
		// Process
		M_PutMSG(ADR(RecvTelegram),ReceivedLength);
			
	// Data Aquisition Request
	ELSIF TelegramType = 'DAQ' THEN	
		// Process
		A_PutDAQ();
		
	// Gathered Data Request
	ELSIF TelegramType = 'GDQ' THEN	
		// Process
		A_PutGDQ();		
	// Drop unknown types
	ELSE
		// Message processed
		fbBaseDriver.M_ProcessedMsg();
	END_IF
ELSE
	// Clear received structure
	MEMSET(destAddr := ADR(RecvTelegram), fillByte := 0, n := SIZEOF(RecvTelegram));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetReceivedData" Id="{b8edc8db-820c-4655-9935-94793974c606}">
      <Declaration><![CDATA[METHOD M_GetReceivedData : ST_PointerSet
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Returns last received data
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
M_GetReceivedData.pAdr := ADR(RecvTelegram);
M_GetReceivedData.Len := ReceivedLength;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{853387f1-5b2c-4fc2-af9c-fe65f4440001}">
      <Declaration><![CDATA[METHOD M_Init : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Initialize Msg Manager.
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
	mInit		: BOOL; // Force init
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// If instance is not initialized or init is forced
IF NOT Init OR mInit THEN
	
	// Activate configuration
	Settings := Config;
	fbBaseDriver.Settings := Settings.BaseDriver;
	
	// Initialize base driver
	fbBaseDriver.M_Init(TRUE);

    // Send log message
    fbDebugMsg.M_SendInfoMsg('Initialization done');
		
	// Init done
    Init := TRUE;

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsConnected" Id="{620cbb54-f1b9-47bb-92f3-379ab01185cf}">
      <Declaration><![CDATA[{attribute 'object_name' := 'M_IsConnected'}
METHOD M_IsConnected : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Connection is established
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Return connection state of base driver
M_IsConnected := fbBaseDriver.Connected;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MirrorData" Id="{f4828c4b-97a6-48c4-8afc-5386592794bd}">
      <Declaration><![CDATA[METHOD PROTECTED M_MirrorData : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Mirror these data (Max length 255) to a additonal connection.
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
	Data	: PVOID;
	DataLen	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initialize
M_MirrorData := TRUE;

// Check if a mirror channel is available
IF Settings.MirrorChannel > E_MFCS_Channel.BEGIN_CHANNEL AND
   Settings.MirrorChannel < E_MFCS_Channel.END_CHANNEL THEN
   
   	// Forward data to an additional connection
   	M_MirrorData := fbMFCS_Channel[Settings.MirrorChannel].M_SendData(
						meChannelSrc := 0,
						mMsgType  	 := E_ITC_MsgTypeConv.DATA_MESSAGE,
						mpData	  	 := Data,
						mLen		 := DataLen);
				
   	// If forwarding was not successful
   	IF NOT M_MirrorData THEN
		DebugMsg := 'Mirror Channel was not able to accept message.';
		fbDebugMsg.M_SendErrorMsg(DebugMsg);		
   	END_IF
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessATR" Id="{9f3cebc7-b85e-4937-b503-b5883c6dbf2f}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessATR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send ATR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpATR				: POINTER TO ST_ITC_ATR; // Pointer to ATR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a ATR 	
IF  Settings.Telegrams.SendATR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(ATR_ITC), srcAddr := mpATR, n := SIZEOF(ATR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Fill position
ATR.Position	:= 	F_StuffString(
						InputString 	:= ATR_ITC.Position, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Error Code 
ATR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(ATR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
(**************************************************************************************************************
 	Build byte stream and add to Base Driver
***************************************************************************************************************)
// Initialize
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('ATR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ATR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(ATR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ATR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(ATR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
// Add to buffer of Base Driver
M_ProcessATR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessDAR" Id="{92d4e74e-a954-41af-9f34-45891ce437ca}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessDAR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send DAR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpDAR				: POINTER TO ST_ITC_DAR; // Pointer to DAR
END_VAR
VAR
	Idx : INT;	//Iterator
	Idx2 : INT;	//Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a DAR 	
IF  Settings.Telegrams.SendDAR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(DAR_ITC), srcAddr := mpDAR, n := SIZEOF(DAR_ITC));
MEMSET(destAddr := ADR(DAR), 0, SIZEOF(DAR));
(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)


// Get SIS-Number 
DAR.Position := F_StuffString(
					InputString 	:= DAR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0', 
					LeftAligned := FALSE);
//Get Number Sets
DAR.NumberOfSets := F_StuffString(
						InputString 	:= INT_TO_STRING(DAR_ITC.NumberOfSets), 
						StringLength	:= SIS_6_0.DATA_ACQUISITION_NUMBEROFSETS, 
						StuffCharacter 	:= '0', 
						LeftAligned := FALSE);
//Get  Code
DAR.Code := F_StuffString(
						InputString 	:= INT_TO_STRING(DAR_ITC.Code), 
						StringLength	:= SIS_6_0.DATA_ACQUISITION_CODE, 
						StuffCharacter 	:= '0', 
						LeftAligned 	:= FALSE);

//Build Set 
IF DAR_ITC.SetOffset>E_CM_Index.E_BEGIN_VARIABLE THEN 	
Idx2:=1;	
	FOR Idx:=DAR_ITC.SetOffset TO DAR_ITC.NumberOfSets+DAR_ITC.SetOffset -1  DO 
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_StuffString(InputString :=DAR_ITC.Set[Idx].mVariableName, StringLength:= System.CM_VARIABLENAME_STRINGLENGTH, StuffCharacter:= ' ', LeftAligned := FALSE));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_Time_TO_MaxReportTime(TIN:= DAR_ITC.Set[Idx].MaxReportTime));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_Time_TO_SampleTime(DAR_ITC.Set[Idx].SampleTime));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_StuffString(InputString := INT_TO_STRING(DAR_ITC.Set[Idx].Threshold), StringLength:= SIS_6_0.DATA_ACQUISITION_THRESHOLD, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_StuffString(InputString := INT_TO_STRING(BOOL_TO_INT(DAR_ITC.Set[Idx].Option)), StringLength:= 1, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_StuffString(InputString := INT_TO_STRING(BOOL_TO_INT(DAR_ITC.Set[Idx].Enable)), StringLength:= 1, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx2]   := CONCAT(DAR.Set[Idx2],F_StuffString(InputString := INT_TO_STRING(DAR_ITC.Set[Idx].ErrorCode), StringLength:= 4, StuffCharacter:= '0', LeftAligned := FALSE));
		Idx2:= Idx2+1;
	END_FOR
ELSE  	
	FOR Idx:=1 TO DAR_ITC.NumberOfSets DO 
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_StuffString(InputString :=DAR_ITC.Set[Idx].mVariableName, StringLength:= System.CM_VARIABLENAME_STRINGLENGTH, StuffCharacter:= ' ', LeftAligned := FALSE));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_Time_TO_MaxReportTime(TIN:= DAR_ITC.Set[Idx].MaxReportTime));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_Time_TO_SampleTime(DAR_ITC.Set[Idx].SampleTime));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_StuffString(InputString := INT_TO_STRING(DAR_ITC.Set[Idx].Threshold), StringLength:= SIS_6_0.DATA_ACQUISITION_THRESHOLD, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_StuffString(InputString := INT_TO_STRING(BOOL_TO_INT(DAR_ITC.Set[Idx].Option)), StringLength:= 1, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_StuffString(InputString := INT_TO_STRING(BOOL_TO_INT(DAR_ITC.Set[Idx].Enable)), StringLength:= 1, StuffCharacter:= '0', LeftAligned := FALSE));
		DAR.Set[Idx]   := CONCAT(DAR.Set[Idx],F_StuffString(InputString := INT_TO_STRING(DAR_ITC.Set[Idx].ErrorCode), StringLength:= 4, StuffCharacter:= '0', LeftAligned := FALSE));
	END_FOR
END_IF;
	

(**************************************************************************************************************
 Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('DAR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(DAR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(DAR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(DAR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(DAR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(DAR.NumberOfSets), 
	SrcLen:= INT_TO_UDINT(LEN(DAR.NumberOfSets)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
IF DAR_ITC.SetOffset>E_CM_Index.E_BEGIN_VARIABLE THEN 	
Idx2:=1;	
	FOR Idx:=DAR_ITC.SetOffset TO DAR_ITC.NumberOfSets+DAR_ITC.SetOffset -1  DO 
		F_AssembleByteStream(
						pSrc			:= ADR(DAR.Set[Idx2]), 
						SrcLen			:= INT_TO_UDINT(LEN(DAR.Set[Idx2])), 
						pDest			:= ADR(SendTelegram), 
						DestLen			:= SIZEOF(SendTelegram), 
						WritePointer	:= WritePointer);
		Idx2 := Idx2 +1;
	END_FOR;
ELSE
	FOR Idx:=1 TO DAR_ITC.NumberOfSets DO 
		F_AssembleByteStream(
						pSrc			:= ADR(DAR.Set[Idx]), 
						SrcLen			:= INT_TO_UDINT(LEN(DAR.Set[Idx])), 
						pDest			:= ADR(SendTelegram), 
						DestLen			:= SIZEOF(SendTelegram), 
						WritePointer	:= WritePointer);
	END_FOR;
END_IF
	

// Add to buffer of Base Driver
M_ProcessDAR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);
					
// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessECR" Id="{576b4c1a-1fa8-49e7-a42b-2f3c65cb0a35}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessECR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send ECR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
 
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpECR				: POINTER TO ST_ITC_ECR; // Pointer to ECR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a ECR 	
IF  Settings.Telegrams.SendECR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(ECR_ITC), srcAddr := mpECR, n := SIZEOF(ECR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Fill position
ECR.Position	:= 	F_StuffString(
						InputString 	:= ECR_ITC.Position, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Fill code
ECR.Code	:= F_StuffString(
					InputString 	:= INT_TO_STRING(ECR_ITC.Code), 
					StringLength	:= SIS_6_0.CONTROLCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Fill variable
ECR.Variable 	:= F_StuffString(
					InputString 	:= DINT_TO_STRING(ECR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Fill errorcode
ECR.ReturnCode 	:= F_StuffString(
					InputString 	:= INT_TO_STRING(ECR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('ECR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ECR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(ECR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ECR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(ECR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ECR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(ECR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ECR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(ECR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessECR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);
					
// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessERR" Id="{d1170e15-4e31-4890-a610-e57cc8b74987}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessERR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send ERR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpERR				: POINTER TO ST_ITC_ERR; // Pointer to ATR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a ERR 	
IF  Settings.Telegrams.SendERR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(ERR_ITC), srcAddr := mpERR, n := SIZEOF(ERR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Fill position
ERR.Position	:= 	F_StuffString(
						InputString 	:= ERR_ITC.Position, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Fill position
ERR.Code	:= 	F_StuffString(
						InputString 	:= INT_TO_STRING(ERR_ITC.Code), 
						StringLength	:= SIS_6_0.ERR_CODE_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
						
// Get Error Code 
ERR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(ERR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);;
					
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('ERR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ERR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(ERR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ERR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(ERR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ERR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(ERR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
// Add to buffer of Base Driver
M_ProcessERR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);
					
// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessESR" Id="{6dcc88c1-f6f9-432b-88c6-bfd56c21bd08}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessESR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send ESR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpESR				: POINTER TO ST_ITC_ESR; // Pointer to ESR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a ESR 	
IF  Settings.Telegrams.SendESR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(ESR_ITC), srcAddr := mpESR, n := SIZEOF(ESR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Build position
ESR.Position := F_StuffString(
					InputString 	:= ESR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
// Build state
ESR.State := INT_TO_STRING(ESR_ITC.State);

// Build enabled
ESR.Enabled	:= INT_TO_STRING(BOOL_TO_INT(ESR_ITC.Enabled));

// Build error state	
ESR.ErrorState := INT_TO_STRING(ESR_ITC.ErrorState);					

// Build error code
ESR.ErrorCode := F_StuffString(
					InputString 	:= INT_TO_STRING(ESR_ITC.ErrorCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
// Build error type
ESR.ErrorType := INT_TO_STRING(ESR_ITC.ErrorType);

// Build information
ESR.ErrorInformation := F_StuffString(
							InputString 	:= ESR_ITC.ErrorInformation, 
							StringLength	:= SIS_6_0.ERRORINFORMATION_STRINGLENGTH, 
							StuffCharacter 	:= ' ',
							LeftAligned		:= TRUE);
// Build variable
ESR.Variable  := F_StuffString(
					InputString 	:= DINT_TO_STRING(ESR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Error Code 
ESR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(ESR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('ESR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ESR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ESR.State), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.State)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(ESR.Enabled), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.Enabled)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	


F_AssembleByteStream(
	pSrc:= ADR(ESR.ErrorState), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.ErrorState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);		

F_AssembleByteStream(
	pSrc:= ADR(ESR.ErrorCode), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.ErrorCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(ESR.ErrorType), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.ErrorType)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);		
	
F_AssembleByteStream(
	pSrc:= ADR(ESR.ErrorInformation), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.ErrorInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(ESR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(ESR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(ESR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);		

// Add to buffer of Base Driver
M_ProcessESR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessFCR" Id="{797dcd1e-ca6f-4159-80ef-4baf4f3191c3}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessFCR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send FCR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpFCR				: POINTER TO ST_ITC_FCR; // Pointer to FCR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a FCR 	
IF  Settings.Telegrams.SendFCR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(FCR_ITC), srcAddr := mpFCR, n := SIZEOF(FCR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Fill position
FCR.Position	:= 	F_StuffString(
						InputString 	:= FCR_ITC.Position, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Fill code
FCR.Code	:= F_StuffString(
				InputString 	:= INT_TO_STRING(FCR_ITC.Code), 
				StringLength	:= SIS_6_0.CONTROLCODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Fill variable
FCR.Variable 	:= F_StuffString(
					InputString 	:= DINT_TO_STRING(FCR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Fill errorcode
FCR.ReturnCode 	:= F_StuffString(
					InputString 	:= INT_TO_STRING(FCR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('FCR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(FCR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(FCR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FCR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(FCR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FCR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(FCR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FCR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(FCR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

// Add to buffer of Base Driver
M_ProcessFCR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);
					
// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessFSR" Id="{b095a612-c95f-437a-853c-7e9ade8b6cbf}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessFSR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send FSR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpFSR				: POINTER TO ST_ITC_FSR; // Pointer to FSR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a FSR 	
IF  Settings.Telegrams.SendFSR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(FSR_ITC), srcAddr := mpFSR, n := SIZEOF(FSR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Set position
FSR.Position := F_StuffString(
					InputString 	:= FSR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
// Set previous function no
FSR.PrevFunctionNo := F_StuffString(
						InputString 	:= FSR_ITC.PrevFunctionNo, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
						
// Set next function no
FSR.NextFunctionNo := F_StuffString(
						InputString 	:= FSR_ITC.NextFunctionNo, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
						
// Set state
FSR.State := INT_TO_STRING(FSR_ITC.eState);

// Set enabled
FSR.Enabled := INT_TO_STRING(BOOL_TO_INT(FSR_ITC.Enabled));

// Set transport state
FSR.TransportState := F_StuffString(
						InputString 	:= INT_TO_STRING(FSR_ITC.TransportState), 
						StringLength	:= SIS_6_0.FSR_STATES_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Set takeover state	
FSR.TakeOverState := F_StuffString(
						InputString 	:= INT_TO_STRING(FSR_ITC.TakeOverState), 
						StringLength	:= SIS_6_0.FSR_STATES_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Set handover state
FSR.HandOverState := F_StuffString(
						InputString 	:= INT_TO_STRING(FSR_ITC.HandOverState), 
						StringLength	:= SIS_6_0.FSR_STATES_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Set TU-ID
FSR.TU_ID := F_StuffString(
				InputString 	:= FSR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);

// Set TU-Type	
FSR.TU_Type := F_StuffString(
				InputString 	:= INT_TO_STRING(FSR_ITC.TU_Type), 
				StringLength	:= SIS_6_0.TU_TYPE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);
				
// Set Assignment ID	
FSR.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(FSR_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Set load information	
FSR.LoadInformation  := INT_TO_STRING(FSR_ITC.LoadInformation);

// Set destination
FSR.Destination  := F_StuffString(
						InputString 	:= FSR_ITC.Destination, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
						
// Set error state
FSR.ErrorState := INT_TO_STRING(FSR_ITC.eErrorState);

// Set error code				
FSR.ErrorCode := F_StuffString(
					InputString 	:= INT_TO_STRING(FSR_ITC.eErrorCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
// Set error type		
FSR.ErrorType  := INT_TO_STRING(FSR_ITC.eErrorType);

// Set error information	
FSR.ErrorInformation  := F_StuffString(
							InputString 	:= FSR_ITC.ErrorInformation, 
							StringLength	:= SIS_6_0.ERRORINFORMATION_STRINGLENGTH, 
							StuffCharacter 	:= ' ',
							LeftAligned		:= TRUE);
// Set variable		
FSR.Variable := F_StuffString(
					InputString 	:= DINT_TO_STRING(FSR_ITC.Variable), 
					StringLength	:= SIS_6_0.FSR_VARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Error Code 
FSR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(FSR_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('FSR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(FSR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.PrevFunctionNo), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.PrevFunctionNo)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.NextFunctionNo), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.NextFunctionNo)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.State), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.State)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.Enabled), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.Enabled)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.TransportState), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.TransportState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.TakeOverState), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.TakeOverState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.HandOverState), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.HandOverState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.TU_Type), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.TU_Type)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.LoadInformation), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.LoadInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.Destination), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.Destination)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(FSR.ErrorState), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.ErrorState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
		
F_AssembleByteStream(
	pSrc:= ADR(FSR.ErrorCode), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.ErrorCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.ErrorType), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.ErrorType)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.ErrorInformation), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.ErrorInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(FSR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(FSR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	

// Add to buffer of Base Driver
M_ProcessFSR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessGCR" Id="{eeb0e894-383b-4c47-85a6-a0bb9bbe7357}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessGCR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send GCR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpGCR				: POINTER TO ST_ITC_GCR; // Pointer to GCR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a GCR 	
IF  Settings.Telegrams.SendGCR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(GCR_ITC), srcAddr := mpGCR, n := SIZEOF(GCR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
GCR.GroupName := F_StuffString(
					InputString 	:= GCR_ITC.GroupName, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Code 
GCR.Code := F_StuffString(
				InputString 	:= INT_TO_STRING(GCR_ITC.Code), 
				StringLength	:= SIS_6_0.CONTROLCODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get Variable 
GCR.Variable := F_StuffString(
					InputString 	:= DINT_TO_STRING(GCR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get ErrorCode 
GCR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(GCR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('GCR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(GCR.GroupName), 
	SrcLen:= INT_TO_UDINT(LEN(GCR.GroupName)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GCR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(GCR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GCR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(GCR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GCR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(GCR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

// Add to buffer of Base Driver
M_ProcessGCR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessGDR" Id="{c45180e0-7ccd-4a40-ab6f-55577b847a04}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessGDR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send GDR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpGDR				: POINTER TO ST_ITC_GDR; // Pointer to GDR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a GDR 	
IF  Settings.Telegrams.SendGDR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(GDR_ITC), srcAddr := mpGDR, n := SIZEOF(GDR_ITC));
MEMSET(destAddr := ADR(GDR), 0, SIZEOF(GDR));
(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
GDR.Position := F_StuffString(
					InputString 	:= GDR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned := FALSE);
// Get Variable 
GDR.Variable := F_StuffString(
				InputString 	:= GDR_ITC.Variable, 
				StringLength	:= SIS_6_0.GATHERED_DATA_VARIABLE, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);
//Number of Sets
GDR.NumberOfSets := 	F_StuffString(
										InputString 	:=INT_TO_STRING(GDR_ITC.NumberOfSets), 
										StringLength	:= SIS_6_0.DATA_ACQUISITION_NUMBEROFSETS, 
										StuffCharacter 	:= '0',
										LeftAligned		:= FALSE);
//Build Data Set String
FOR Idx:= 0 TO GDR_ITC.NumberOfSets-1 DO 
	GDR.DataSet[Idx]  := CONCAT(GDR.DataSet[Idx],F_StuffString(InputString := GDR_ITC.DataSet[Idx].Value, StringLength:= Conveyor.GATHERED_DATA_VALUE,StuffCharacter := '0', LeftAligned := FALSE));
	GDR.DataSet[Idx]  := CONCAT(GDR.DataSet[Idx],GDR_ITC.DataSet[Idx].TimeStamp);
	GDR.DataSet[Idx]  := CONCAT(GDR.DataSet[Idx],F_StuffString(InputString 	:= INT_TO_STRING(GDR_ITC.DataSet[Idx].Sequence), StringLength:= SIS_6_0.GATHERED_DATA_SEQUENCE,StuffCharacter := '0', LeftAligned := FALSE));
END_FOR;

// Get Error Code 
GDR.ReturnCode := F_StuffString(
				InputString 	:= INT_TO_STRING(GDR_ITC.eReturnCode), 
				StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned 	:= FALSE);
				
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('GDR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(GDR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(GDR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(GDR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(GDR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(GDR.NumberOfSets), 
	SrcLen:= INT_TO_UDINT(LEN(GDR.NumberOfSets)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

FOR Idx:= 0
 TO GDR_ITC.NumberOfSets DO
	F_AssembleByteStream(
						pSrc		:= ADR(GDR.DataSet[Idx]), 
						SrcLen		:= INT_TO_UDINT(LEN(GDR.DataSet[Idx])), 
						pDest		:= ADR(SendTelegram),
						DestLen		:= SIZEOF(SendTelegram), 
						WritePointer:= WritePointer);
						
END_FOR

	
	
	
F_AssembleByteStream(
	pSrc:= ADR(GDR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(GDR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessGDR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessGSR" Id="{9f3df5c7-bc5f-4f9a-a5f5-9394c3fcb040}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessGSR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send GSR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpGSR				: POINTER TO ST_ITC_GSR; // Pointer to GSR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a GSR 	
IF  Settings.Telegrams.SendGSR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(GSR_ITC), srcAddr := mpGSR, n := SIZEOF(GSR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
GSR.GroupName := F_StuffString(
					InputString 	:= GSR_ITC.GroupName, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Mode 
GSR.Mode := INT_TO_STRING(GSR_ITC.eMode);

// Get State 
GSR.State := INT_TO_STRING(GSR_ITC.eState);

// Get ErrorState 
GSR.ErrorState := INT_TO_STRING(GSR_ITC.eErrorState);

// Get ErrorCode 
GSR.ErrorCode := F_StuffString(
					InputString 	:= INT_TO_STRING(GSR_ITC.eErrorCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get ErrorType 
GSR.ErrorType := INT_TO_STRING(GSR_ITC.eErrorType);

// Get ErrorInformation 
GSR.ErrorInformation := F_StuffString(
							InputString 	:= GSR_ITC.ErrorInformation, 
							StringLength	:= SIS_6_0.ERRORINFORMATION_STRINGLENGTH, 
							StuffCharacter 	:= ' ',
							LeftAligned		:= TRUE);

// Get Variable 
GSR.Variable := F_StuffString(
					InputString 	:= DINT_TO_STRING(GSR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
// Get Error Code 
GSR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(GSR_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('GSR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(GSR.GroupName), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.GroupName)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(GSR.Mode), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.Mode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(GSR.State), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.State)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GSR.ErrorState), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.ErrorState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GSR.ErrorCode), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.ErrorCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(GSR.ErrorType), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.ErrorType)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(GSR.ErrorInformation), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.ErrorInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GSR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(GSR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(GSR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	


// Add to buffer of Base Driver
M_ProcessGSR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessGVR" Id="{de315c96-7309-4265-9083-fd470f83d178}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessGVR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send GVR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpGVR				: POINTER TO ST_ITC_GVR; // Pointer to GVR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a GVR 	
IF  Settings.Telegrams.SendGVR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(GVR_ITC), srcAddr := mpGVR, n := SIZEOF(GVR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get Number 
GVR.Number := 	F_StuffString(
					InputString 	:= INT_TO_STRING(GVR_ITC.Number), 
					StringLength	:= SIS_6_0.GVR_NUMBER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Quantity 
GVR.Quantity := F_StuffString(
					InputString 	:= INT_TO_STRING(GVR_ITC.Quantity), 
					StringLength	:= SIS_6_0.GVR_QUANTITY_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Initialize values
FOR Idx := 0 TO 9 DO
	GVR.Variable[Idx] := '0';
END_FOR

// Fill values
FOR Idx := 0 TO 9 DO
	GVR.Variable[Idx] := F_StuffString(
							InputString 	:= DINT_TO_STRING(GVR_ITC.Variable[Idx]), 
							StringLength	:= SIS_6_0.GVR_VARIABLE_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);
	
END_FOR

// Get ReturnCode 
GVR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(GVR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('GVR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(GVR.Number), 
	SrcLen:= INT_TO_UDINT(LEN(GVR.Number)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(GVR.Quantity), 
	SrcLen:= INT_TO_UDINT(LEN(GVR.Quantity)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

// Add Variables 
FOR Idx := 0 TO 9 DO
	F_AssembleByteStream(
		pSrc:= ADR(GVR.Variable[Idx]), 
		SrcLen:= INT_TO_UDINT(LEN(GVR.Variable[Idx])), 
		pDest:= ADR(SendTelegram), 
		DestLen:= SIZEOF(SendTelegram), 
		WritePointer:= WritePointer);	
END_FOR

F_AssembleByteStream(
	pSrc:= ADR(GVR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(GVR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessGVR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessIPR" Id="{1c77f2d9-ce41-407d-b7b3-1849a8398d29}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessIPR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send IPR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpIPR				: POINTER TO ST_ITC_IPR; // Pointer to IPR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a IPR 	
IF  Settings.Telegrams.SendIPR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(IPR_ITC), srcAddr := mpIPR, n := SIZEOF(IPR_ITC));


(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SIS-Number 
IPR.Position := F_StuffString(
					InputString 	:= IPR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-DataIndex 
IPR.TU_DataIndex := F_StuffString(
						InputString 	:= DINT_TO_STRING(IPR_ITC.TU_DataIndex), 
						StringLength	:= SIS_6_0.TU_DATAINDEX_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get MSG Sequence 
IPR.MSG_Sequence := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.MSG_Sequence), 
						StringLength	:= SIS_6_0.MSG_SEQUENCE_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get TU-ID 
IPR.TU_ID := F_StuffString(
				InputString 	:= IPR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);

// Get TU-Type 
IPR.TU_Type := F_StuffString(
				InputString 	:= INT_TO_STRING(IPR_ITC.TU_Type), 
				StringLength	:= SIS_6_0.TU_TYPE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);			

// Get Assignment id 
IPR.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(IPR_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
				
// Get Height
IPR.Height := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.Height), 
						StringLength	:= SIS_6_0.IPR_HEIGHT_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);;
				
// Get Width Right 
IPR.WidthRight := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.WidthRight), 
						StringLength	:= SIS_6_0.IPR_WIDTHRIGHT_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
				
// Get Width Left 
IPR.WidthLeft := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.WidthLeft), 
						StringLength	:= SIS_6_0.IPR_WIDTHLEFT_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);	
						
// Get Length Front 
IPR.LengthFront := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.LengthFront), 
						StringLength	:= SIS_6_0.IPR_LENGTHFRONT_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
						
// Get Length Rear 
IPR.LengthRear := F_StuffString(
						InputString 	:= INT_TO_STRING(IPR_ITC.LengthRear), 
						StringLength	:= SIS_6_0.IPR_LENGTHREAR_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Weight 
IPR.Weight := F_StuffString(
				InputString 	:= DINT_TO_STRING(IPR_ITC.Weight), 
				StringLength	:= SIS_6_0.IPR_WEIGHT_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get Tunnel 
IPR.Tunnel := INT_TO_STRING(IPR_ITC.Tunnel);

// Get Runner 
IPR.Runner := INT_TO_STRING(IPR_ITC.Runner);

// Get Error 
IPR.ErrorCode := F_StuffString(
					InputString 	:= INT_TO_STRING(IPR_ITC.ErrorCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


// Get Valid Label String 
IPR.ValidLabelString := F_StuffString(
							InputString 	:= INT_TO_STRING(IPR_ITC.ValidLabelString), 
							StringLength	:= SIS_6_0.IPR_VALIDLABELSTRING_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);

// Get Label 
IPR.Label:= F_StuffString(
				InputString 	:= IPR_ITC.Label, 
				StringLength	:= Conveyor.LABEL_LENGTH, 
				StuffCharacter 	:= '-',
				LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('IPR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(IPR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(IPR.TU_DataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.TU_DataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(IPR.MSG_Sequence), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.MSG_Sequence)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.TU_Type), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.TU_Type)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.Height), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Height)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.WidthRight), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.WidthRight)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.WidthLeft), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.WidthLeft)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.LengthFront), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.LengthFront)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.LengthRear), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.LengthRear)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.Weight), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Weight)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.Tunnel), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Tunnel)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.Runner), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Runner)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.ErrorCode), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.ErrorCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.ValidLabelString), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.ValidLabelString)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(IPR.Label), 
	SrcLen:= INT_TO_UDINT(LEN(IPR.Label)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessIPR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessISR" Id="{45482520-f2e8-4afb-8abd-16aacbeef50b}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessISR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send ISR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpISR				: POINTER TO ST_ITC_ISR; // Pointer to ISR
END_VAR

VAR
	Idx					: INT; // Iterator
	TempByte			: BYTE; // Temporary byte
	TempInt				: INT; // Temporary int
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a ISR 	
IF  Settings.Telegrams.SendISR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(ISR_ITC), srcAddr := mpISR, n := SIZEOF(ISR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Set the ISR.SignalType 
ISR.SignalType := INT_TO_STRING(ISR_ITC.SignalType);

// Set the ISR.StartingSignalNumber 
ISR.StartSignalNumber := F_StuffString(
							InputString 	:= INT_TO_STRING(ISR_ITC.StartSignalNumber), 
							StringLength	:= SIS_6_0.ISR_SIGNALNUMBER_STRINGLENGTH, 
							StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Set the ISR.DataLength 
ISR.DataLength := F_StuffString(
							InputString 	:= INT_TO_STRING(ISR_ITC.DataLength), 
							StringLength	:= SIS_6_0.ISR_DATALENGTH_STRINGLENGTH, 
							StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Store information
ISR.Information	:= ISR_ITC.Information;

ISR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(ISR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
							
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('ISR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(ISR.SignalType), 
	SrcLen:= INT_TO_UDINT(LEN(ISR.SignalType)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ISR.StartSignalNumber), 
	SrcLen:= INT_TO_UDINT(LEN(ISR.StartSignalNumber)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ISR.DataLength), 
	SrcLen:= INT_TO_UDINT(LEN(ISR.DataLength)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ISR.Information), 
	SrcLen:= INT_TO_UDINT(LEN(ISR.Information)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(ISR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(ISR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessISR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessMCR" Id="{09226bb3-f999-4547-9505-2c2a1fc6e365}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessMCR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send MCR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpMCR				: POINTER TO ST_ITC_MCR; // Pointer to MCR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a MCR 	
IF  Settings.Telegrams.SendMCR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(MCR_ITC), srcAddr := mpMCR, n := SIZEOF(MCR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get position
MCR.Position := F_StuffString(
					InputString 	:= MCR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);;
					
// Get Code 
MCR.Code := F_StuffString(
				InputString 	:= INT_TO_STRING(MCR_ITC.Code), 
				StringLength	:= SIS_6_0.MCR_CODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get mode
MCR.Mode := INT_TO_STRING(MCR_ITC.Mode);

// Get speed
IF MCR_ITC.Speed.Enable THEN
	IF MCR_ITC.Speed.Fast THEN
		MCR.Speed := '2';
	ELSE
		MCR.Speed := '1';
	END_IF
ELSE
	MCR.Speed := '0';
END_IF


// Get Axis fwd
IF MCR_ITC.Axis[1].Forward.Enable THEN
	IF MCR_ITC.Axis[1].Forward.Selected THEN
		MCR.Axis1Fwd := '2';
	ELSE
		MCR.Axis1Fwd := '1';
	END_IF
ELSE
	MCR.Axis1Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[1].Reverse.Enable THEN
	IF MCR_ITC.Axis[1].Reverse.Selected THEN
		MCR.Axis1Rev := '2';
	ELSE
		MCR.Axis1Rev := '1';
	END_IF
ELSE
	MCR.Axis1Rev := '0';
END_IF

// Get Axis fwd
IF MCR_ITC.Axis[2].Forward.Enable THEN
	IF MCR_ITC.Axis[2].Forward.Selected THEN
		MCR.Axis2Fwd := '2';
	ELSE
		MCR.Axis2Fwd := '1';
	END_IF
ELSE
	MCR.Axis2Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[2].Reverse.Enable THEN
	IF MCR_ITC.Axis[2].Reverse.Selected THEN
		MCR.Axis2Rev := '2';
	ELSE
		MCR.Axis2Rev := '1';
	END_IF
ELSE
	MCR.Axis2Rev := '0';
END_IF

// Get Axis fwd
IF MCR_ITC.Axis[3].Forward.Enable THEN
	IF MCR_ITC.Axis[3].Forward.Selected THEN
		MCR.Axis3Fwd := '2';
	ELSE
		MCR.Axis3Fwd := '1';
	END_IF
ELSE
	MCR.Axis3Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[3].Reverse.Enable THEN
	IF MCR_ITC.Axis[3].Reverse.Selected THEN
		MCR.Axis3Rev := '2';
	ELSE
		MCR.Axis3Rev := '1';
	END_IF
ELSE
	MCR.Axis3Rev := '0';
END_IF

// Get Axis fwd
IF MCR_ITC.Axis[4].Forward.Enable THEN
	IF MCR_ITC.Axis[4].Forward.Selected THEN
		MCR.Axis4Fwd := '2';
	ELSE
		MCR.Axis4Fwd := '1';
	END_IF
ELSE
	MCR.Axis4Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[4].Reverse.Enable THEN
	IF MCR_ITC.Axis[4].Reverse.Selected THEN
		MCR.Axis4Rev := '2';
	ELSE
		MCR.Axis4Rev := '1';
	END_IF
ELSE
	MCR.Axis4Rev := '0';
END_IF

// Get Axis fwd
IF MCR_ITC.Axis[5].Forward.Enable THEN
	IF MCR_ITC.Axis[5].Forward.Selected THEN
		MCR.Axis5Fwd := '2';
	ELSE
		MCR.Axis5Fwd := '1';
	END_IF
ELSE
	MCR.Axis5Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[5].Reverse.Enable THEN
	IF MCR_ITC.Axis[5].Reverse.Selected THEN
		MCR.Axis5Rev := '2';
	ELSE
		MCR.Axis5Rev := '1';
	END_IF
ELSE
	MCR.Axis5Rev := '0';
END_IF

// Get Axis fwd
IF MCR_ITC.Axis[6].Forward.Enable THEN
	IF MCR_ITC.Axis[6].Forward.Selected THEN
		MCR.Axis6Fwd := '2';
	ELSE
		MCR.Axis6Fwd := '1';
	END_IF
ELSE
	MCR.Axis6Fwd := '0';
END_IF

// Get Axis rev
IF MCR_ITC.Axis[6].Reverse.Enable THEN
	IF MCR_ITC.Axis[6].Reverse.Selected THEN
		MCR.Axis6Rev := '2';
	ELSE
		MCR.Axis6Rev := '1';
	END_IF
ELSE
	MCR.Axis6Rev := '0';
END_IF

// Get Button 1
IF MCR_ITC.Button[1].Enable THEN
	IF MCR_ITC.Button[1].Selected THEN
		MCR.Button1 := '2';
	ELSE
		MCR.Button1 := '1';
	END_IF
ELSE
	MCR.Button1 := '0';
END_IF

// Get Button 2
IF MCR_ITC.Button[2].Enable THEN
	IF MCR_ITC.Button[2].Selected THEN
		MCR.Button2 := '2';
	ELSE
		MCR.Button2 := '1';
	END_IF
ELSE
	MCR.Button2 := '0';
END_IF

// Get return code
MCR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(MCR_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('MCR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(MCR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Mode), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Mode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Speed), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Speed)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis1Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis1Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis1Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis1Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis2Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis2Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis2Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis2Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis3Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis3Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis3Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis3Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis4Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis4Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis4Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis4Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis5Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis5Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis5Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis5Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis6Fwd), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis6Fwd)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Axis6Rev), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Axis6Rev)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(MCR.Button1), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Button1)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(MCR.Button2), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.Button2)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(MCR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(MCR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	


// Add to buffer of Base Driver
M_ProcessMCR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessPOR" Id="{4ca53d7f-a685-4f9c-81ea-aeee5712edfa}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessPOR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send POR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpPOR				: POINTER TO ST_ITC_POR; // Pointer to POR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a POR 	
IF  Settings.Telegrams.SendPOR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(POR_ITC), srcAddr := mpPOR, n := SIZEOF(POR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SIS-Number 
POR.Position := F_StuffString(
					InputString 	:= POR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-ID 
POR.TU_ID := F_StuffString(
					InputString 	:= POR_ITC.TU_ID, 
					StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
					StuffCharacter 	:= ' ',
					LeftAligned		:= FALSE);

// Get TU-Type 
POR.TU_Type := F_StuffString(
					InputString 	:= INT_TO_STRING(POR_ITC.TU_Type), 
					StringLength	:= SIS_6_0.TU_TYPE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
// Get Assignment 
POR.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(POR_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Load Information 
POR.LoadInformation := INT_TO_STRING(BOOL_TO_INT(POR_ITC.LoadInformation));


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('POR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(POR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(POR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(POR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(POR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(POR.TU_Type), 
	SrcLen:= INT_TO_UDINT(LEN(POR.TU_Type)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(POR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(POR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(POR.LoadInformation), 
	SrcLen:= INT_TO_UDINT(LEN(POR.LoadInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

// Add to buffer of Base Driver
M_ProcessPOR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessRAC" Id="{d83ce76e-fec2-4965-aec3-7770bb227a27}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessRAC : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send RAC Robot Task Complete
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 *************************************************************************************)
VAR_INPUT
	meChannelSrc				: E_MFCS_Channel; // Source communicaton channel	
	mpRAC						: POINTER TO ST_ITC_RAC;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a RAC 	
IF  Settings.Telegrams.SendRAC THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(RAC_ITC), srcAddr := mpRAC, n := SIZEOF(RAC_ITC));


(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
RAC.Position := F_StuffString(
					InputString 	:= RAC_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Robot task index 
RAC.CommandDataIndex := F_StuffString(
				InputString 	:= DINT_TO_STRING(RAC_ITC.CommandDataIndex), 
				StringLength	:= SIS_6_0.RAC_COMMAND_DATA_INDEX_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);
					
// Get Assignment ID 
RAC.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(RAC_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.RAC_ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Robot Task ID 
RAC.CommandSequenceIndex := F_StuffString(
								InputString 	:= ULINT_TO_STRING(RAC_ITC.GroupID), 
								StringLength	:= SIS_6_0.RAC_COMMAND_SEQUENCE_INDEX_STRINGLENGTH, 
								StuffCharacter 	:= '0',
								LeftAligned		:= FALSE);

// Get return Code 
RAC.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(RAC_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;


F_AssembleByteStream(
	pSrc:= ADR('RAC'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RAC.Position), 
	SrcLen:= INT_TO_UDINT(LEN(RAC.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RAC.CommandDataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(RAC.CommandDataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RAC.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(RAC.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RAC.CommandSequenceIndex), 
	SrcLen:= INT_TO_UDINT(LEN(RAC.CommandSequenceIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RAC.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(RAC.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessRAC := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessRDR" Id="{1c760700-4898-476e-b758-168a7a4ff2c8}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessRDR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send RDR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				04.01.2016		Kay Röder			Initial programming
 *
 **************************************************************************************)
VAR_INPUT
	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpRDR				: POINTER TO ST_ITC_RDR; // Pointer to RDR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a RDR 	
IF  Settings.Telegrams.SendRDR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(RDR_ITC), srcAddr := mpRDR, n := SIZEOF(RDR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Set position // Set SIS-Address
RDR.Position := F_StuffString(
					InputString		:= RDR_ITC.Position,
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH,
					StuffCharacter	:= '0',
					LeftAligned		:= FALSE);

// Set Robot_Task_Index
RDR.CommandDataIndex := F_StuffString(
						InputString		:= DINT_TO_STRING(RDR_ITC.CommandDataIndex),
						StringLength	:= SIS_6_0.RDR_COMMAND_DATA_INDEX_STRINGLENGTH,
						StuffCharacter	:= '0',
						LeftAligned		:= FALSE);
						
// Set Assignment ID
RDR.AssignmentID := F_StuffString(
						InputString		:= UDINT_TO_STRING(RDR_ITC.AssignmentID),
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH,
						StuffCharacter	:= '0',
						LeftAligned		:= FALSE);
						
// Set Robot_Task_ID
RDR.CommandSequenceIndex := F_StuffString(
								InputString		:= ULINT_TO_STRING(RDR_ITC.GroupID),
								StringLength	:= SIS_6_0.RDR_COMMAND_SEQUENCE_INDEX_STRINGLENGTH,
								StuffCharacter	:= '0',
								LeftAligned		:= FALSE);

// Set ReturnCode
RDR.ReturnCode := F_StuffString(
						InputString		:= INT_TO_STRING(RDR_ITC.ReturnCode),
						StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH,
						StuffCharacter	:= '0',
						LeftAligned		:= FALSE);
						
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('RDR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RDR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(RDR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RDR.CommandDataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(RDR.CommandDataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RDR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(RDR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RDR.CommandSequenceIndex), 
	SrcLen:= INT_TO_UDINT(LEN(RDR.CommandSequenceIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RDR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(RDR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessRDR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessRTR" Id="{e6d0a22b-31a2-4af5-af8f-ed55e390608b}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessRTR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send RTR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpRTR				: POINTER TO ST_ITC_RTR; // Pointer to RTR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a RTR 	
IF  Settings.Telegrams.SendRTR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(RTR_ITC), srcAddr := mpRTR, n := SIZEOF(RTR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Fill position
RTR.Position	:= 	F_StuffString(
						InputString 	:= RTR_ITC.Position, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Error Code 
RTR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(RTR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('RTR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(RTR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(RTR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(RTR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(RTR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessRTR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessSCR" Id="{eab2c5b8-2721-4f3a-bb86-79c28c88497e}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessSCR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send SCR.
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpSCR				: POINTER TO ST_ITC_SCR; // Pointer to SCR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a SCR 	
IF  Settings.Telegrams.SendSCR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(SCR_ITC), srcAddr := mpSCR, n := SIZEOF(SCR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get Subsystem name 
SCR.SubsystemName := F_StuffString(
							InputString 	:= SCR_ITC.SubsystemName, 
							StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);

// Get Code 
SCR.Code := F_StuffString(
				InputString 	:= INT_TO_STRING(SCR_ITC.Code), 
				StringLength	:= SIS_6_0.CONTROLCODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get Variable 
SCR.Variable := F_StuffString(
					InputString 	:= DINT_TO_STRING(SCR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get ErrorCode
SCR.ReturnCode := F_StuffString(
						InputString 	:= INT_TO_STRING(SCR_ITC.ReturnCode), 
						StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('SCR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SCR.SubsystemName), 
	SrcLen:= INT_TO_UDINT(LEN(SCR.SubsystemName)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SCR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(SCR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SCR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(SCR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SCR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(SCR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);


// Add to buffer of Base Driver
M_ProcessSCR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessSDI" Id="{3d75d1db-89c0-4d76-bdae-c6f21923a24e}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessSDI : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send SDI
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpSDI				: POINTER TO ST_ITC_SDI; // Pointer to SDI
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a SDI 	
IF  Settings.Telegrams.SendSDI THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(SDI_ITC), srcAddr := mpSDI, n := SIZEOF(SDI_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SignalNumber 
SDI.SignalNumber := F_StuffString(
						InputString 	:= INT_TO_STRING(SDI_ITC.SignalNumber), 
						StringLength	:= SIS_6_0.SDI_SIGNALNUMBER_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get SignalState 
SDI.SignalState := INT_TO_STRING(BOOL_TO_INT(SDI_ITC.SignalState));

// Get Error Code 
SDI.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(SDI_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('SDI'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SDI.SignalNumber), 
	SrcLen:= INT_TO_UDINT(LEN(SDI.SignalNumber)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SDI.SignalState), 
	SrcLen:= INT_TO_UDINT(LEN(SDI.SignalState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SDI.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(SDI.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessSDI := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessSIR" Id="{09c025a5-9702-44f5-a54d-7e0f5789ebe0}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessSIR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send SIR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpSIR				: POINTER TO ST_ITC_SIR; // Pointer to SIR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a SIR 	
IF  Settings.Telegrams.SendSIR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(SIR_ITC), srcAddr := mpSIR, n := SIZEOF(SIR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SIS-Number 
SIR.Position := F_StuffString(
							InputString 	:= SIR_ITC.Position, 
							StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);
							
// Get Code 
SIR.Code := F_StuffString(
				InputString 	:= INT_TO_STRING(SIR_ITC.Code), 
				StringLength	:= SIS_6_0.SIR_CODE_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get TU-ID 
SIR.TU_ID := F_StuffString(
				InputString 	:= SIR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);

// Get counter value
SIR.Counter1 := F_StuffString(
					InputString 	:= DINT_TO_STRING(SIR_ITC.Counter1), 
					StringLength	:= SIS_6_0.SIR_COUNTER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get counter value
SIR.Counter2 := F_StuffString(
					InputString 	:= DINT_TO_STRING(SIR_ITC.Counter2), 
					StringLength	:= SIS_6_0.SIR_COUNTER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get counter value
SIR.Counter3 := F_StuffString(
					InputString 	:= DINT_TO_STRING(SIR_ITC.Counter3), 
					StringLength	:= SIS_6_0.SIR_COUNTER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get counter value
SIR.Counter4 := F_StuffString(
					InputString 	:= DINT_TO_STRING(SIR_ITC.Counter4), 
					StringLength	:= SIS_6_0.SIR_COUNTER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
		
// Get counter value		
SIR.Counter5 := F_StuffString(
					InputString 	:= DINT_TO_STRING(SIR_ITC.Counter5), 
					StringLength	:= SIS_6_0.SIR_COUNTER_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
		
// Get error code
SIR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(SIR_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('SIR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Code), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Code)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SIR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Counter1), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Counter1)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Counter2), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Counter2)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Counter3), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Counter3)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Counter4), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Counter4)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SIR.Counter5), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.Counter5)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(SIR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(SIR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);


// Add to buffer of Base Driver
M_ProcessSIR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessSNR" Id="{f4068b1b-c27d-48dd-818c-064759e066ef}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessSNR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send SNR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpSNR				: POINTER TO ST_ITC_SNR; // Pointer to SNR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a SNR 	
IF  Settings.Telegrams.SendSNR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(SNR_ITC), srcAddr := mpSNR, n := SIZEOF(SNR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SIS-Number 
SNR.Position := F_StuffString(
					InputString 	:= SNR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-ID 
SNR.TU_ID := F_StuffString(
				InputString 	:= SNR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);


// Get Error Code 
SNR.InfoCode := F_StuffString(
					InputString 	:= INT_TO_STRING(SNR_ITC.InfoCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
					
					
(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('SNR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SNR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(SNR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SNR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(SNR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SNR.InfoCode), 
	SrcLen:= INT_TO_UDINT(LEN(SNR.InfoCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessSNR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessSSR" Id="{b401b109-b603-431a-9bb1-0c38a1fe40b9}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessSSR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send SSR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpSSR				: POINTER TO ST_ITC_SSR; // Pointer to SSR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a SSR 	
IF  Settings.Telegrams.SendSSR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(SSR_ITC), srcAddr := mpSSR, n := SIZEOF(SSR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get Subsystem name 
SSR.SubsystemName := F_StuffString(
						InputString 	:= SSR_ITC.SubsystemName, 
						StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Mode 
SSR.Mode := INT_TO_STRING(SSR_ITC.eMode);

// Get system info
SSR.State := INT_TO_STRING(SSR_ITC.eState);

// Get system info
SSR.SystemInfo := INT_TO_STRING(SSR_ITC.eSystemInfo);

// Get ErrorState 
SSR.ErrorState := INT_TO_STRING(SSR_ITC.eErrorState);

// Get ErrorCode 
SSR.ErrorCode := F_StuffString(
					InputString 	:= INT_TO_STRING(SSR_ITC.eErrorCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get ErrorType 
SSR.ErrorType := INT_TO_STRING(SSR_ITC.eErrorType);

// Get ErrorInformation 
SSR.ErrorInformation := F_StuffString(
							InputString 	:= SSR_ITC.ErrorInformation, 
							StringLength	:= SIS_6_0.ERRORINFORMATION_STRINGLENGTH, 
							StuffCharacter 	:= ' ',
							LeftAligned		:= TRUE);

// Get Variable 
SSR.Variable := F_StuffString(
					InputString 	:= DINT_TO_STRING(SSR_ITC.Variable), 
					StringLength	:= SIS_6_0.CONTROLVARIABLE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Error Code 
SSR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(SSR_ITC.eReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('SSR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SSR.SubsystemName), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.SubsystemName)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SSR.Mode), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.Mode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(SSR.State), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.State)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(SSR.SystemInfo), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.SystemInfo)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(SSR.ErrorState), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.ErrorState)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SSR.ErrorCode), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.ErrorCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(SSR.ErrorType), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.ErrorType)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SSR.ErrorInformation), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.ErrorInformation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SSR.Variable), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.Variable)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(SSR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(SSR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Add to buffer of Base Driver
M_ProcessSSR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessTDR" Id="{ad408df4-f6e4-4c05-95e6-5814c26696bc}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessTDR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send TDR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpTDR				: POINTER TO ST_ITC_TDR; // Pointer to TDR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a TDR 	
IF  Settings.Telegrams.SendTDR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(TDR_ITC), srcAddr := mpTDR, n := SIZEOF(TDR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
TDR.Position := F_StuffString(
					InputString 	:= TDR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-ID 
TDR.TU_ID := F_StuffString(
				InputString 	:= TDR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);
					
// Get Assignment 
TDR.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(TDR_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get MSG Sequence 
TDR.MsgSequence := 	F_StuffString(
						InputString 	:= INT_TO_STRING(TDR_ITC.MsgSequence), 
						StringLength	:= SIS_6_0.MSG_SEQUENCE_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get return Code 
TDR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(TDR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);



(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('TDR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TDR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(TDR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TDR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(TDR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TDR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(TDR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TDR.MsgSequence), 
	SrcLen:= INT_TO_UDINT(LEN(TDR.MsgSequence)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	
F_AssembleByteStream(
	pSrc:= ADR(TDR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(TDR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

// Add to buffer of Base Driver
M_ProcessTDR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessTTC" Id="{c10207b8-18dc-4275-a798-5d21168bbee0}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessTTC : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send TTC
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpTTC				: POINTER TO ST_ITC_TTC; // Pointer to TTC
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a TTC 	
IF  Settings.Telegrams.SendTTC THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(TTC_ITC), srcAddr := mpTTC, n := SIZEOF(TTC_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
TTC.Position := F_StuffString(
					InputString 	:= TTC_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-DataIndex 
TTC.TU_DataIndex := F_StuffString(
						InputString 	:= DINT_TO_STRING(TTC_ITC.TU_DataIndex), 
						StringLength	:= SIS_6_0.TU_DATAINDEX_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get MSG Sequence 
TTC.MsgSequence := F_StuffString(
						InputString 	:= INT_TO_STRING(TTC_ITC.MsgSequence), 
						StringLength	:= SIS_6_0.MSG_SEQUENCE_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get TU-ID 
TTC.TU_ID := F_StuffString(
				InputString 	:= TTC_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);
				
// Get Assignment 
TTC.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(TTC_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Error Code 
TTC.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(TTC_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('TTC'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTC.Position), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTC.TU_DataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.TU_DataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTC.MsgSequence), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.MsgSequence)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TTC.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TTC.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TTC.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(TTC.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);


// Add to buffer of Base Driver
M_ProcessTTC := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessTTQ" Id="{6bfc89df-0586-48f5-b7ae-34b3e7c1897a}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessTTQ : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send TTQ
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpTTQ				: POINTER TO ST_ITC_TTQ; // Pointer to TTQ
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a TTQ 	
IF  Settings.Telegrams.SendTTQ THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(TTQ_ITC), srcAddr := mpTTQ, n := SIZEOF(TTQ_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
TTQ.Position := F_StuffString(
					InputString 	:= TTQ_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get TU-DataIndex 
TTQ.TU_DataIndex := F_StuffString(
						InputString 	:= DINT_TO_STRING(TTQ_ITC.TU_DataIndex), 
						StringLength	:= SIS_6_0.TU_DATAINDEX_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get TU-ID 
TTQ.TU_ID := F_StuffString(
				InputString 	:= TTQ_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);

// Get Number of TT's 
TTQ.NbrOfTT :=  F_StuffString(
						InputString 	:= INT_TO_STRING(TTQ_ITC.NbrOfTT), 
						StringLength	:= SIS_6_0.TTQ_NUMBER_OF_TT_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);

// Get Label Length						
TTQ.Label := F_StuffString(
				InputString 	:= TTQ_ITC.Label, 
				StringLength	:= Conveyor.LABEL_LENGTH, 
				StuffCharacter 	:= '-',
				LeftAligned		:= FALSE);

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('TTQ'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTQ .Position), 
	SrcLen:= INT_TO_UDINT(LEN(TTQ.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TTQ.TU_DataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(TTQ.TU_DataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTQ.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(TTQ.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTQ.NbrOfTT), 
	SrcLen:= INT_TO_UDINT(LEN(TTQ.NbrOfTT)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TTQ.Label), 
	SrcLen:= INT_TO_UDINT(LEN(TTQ.Label)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	


// Add to buffer of Base Driver
M_ProcessTTQ := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessTUR" Id="{97e715f0-2190-4dfb-be49-12c3536029ae}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessTUR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send TUR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 *************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpTUR				: POINTER TO ST_ITC_TUR; // Pointer to TUR
END_VAR

VAR
	DestinationIdx			: INT; // Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a TUR 	
IF  Settings.Telegrams.SendTUR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF
			

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(TUR_ITC), srcAddr := mpTUR, n := SIZEOF(TUR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)
// Get SIS-Number 
TUR.Position := F_StuffString(
					InputString 	:= TUR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
				
// Get TU-Data index
TUR.TU_DataIndex := F_StuffString(
				InputString 	:= DINT_TO_STRING(TUR_ITC.TU_DataIndex), 
				StringLength	:= SIS_6_0.TU_DATAINDEX_STRINGLENGTH, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);
				
// Get TU-ID 
TUR.TU_ID := F_StuffString(
				InputString 	:= TUR_ITC.TU_ID, 
				StringLength	:= SIS_6_0.TU_ID_STRINGLENGTH, 
				StuffCharacter 	:= ' ',
				LeftAligned		:= FALSE);

// Get TU-Type 
TUR.TU_Type := 	F_StuffString(
					InputString 	:= INT_TO_STRING(TUR_ITC.TU_Type), 
					StringLength	:= SIS_6_0.TU_TYPE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
				
// Get Assignment id
TUR.AssignmentID := F_StuffString(
						InputString 	:= UDINT_TO_STRING(TUR_ITC.AssignmentID), 
						StringLength	:= SIS_6_0.ASSIGNMENT_ID_STRINGLENGTH, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);;

// Get length
TUR.Length := F_StuffString(
				InputString 	:= INT_TO_STRING(TUR_ITC.Length), 
				StringLength	:= SIS_6_0.DIMENSIONS, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get width
TUR.Width := F_StuffString(
				InputString 	:= INT_TO_STRING(TUR_ITC.Width), 
				StringLength	:= SIS_6_0.DIMENSIONS, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);
					
// Get height
TUR.Height := F_StuffString(
				InputString 	:= INT_TO_STRING(TUR_ITC.Height), 
				StringLength	:= SIS_6_0.DIMENSIONS, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get weight
TUR.Weight := F_StuffString(
				InputString 	:= DINT_TO_STRING(TUR_ITC.Weight), 
				StringLength	:= SIS_6_0.TTA_WEIGHT, 
				StuffCharacter 	:= '0',
				LeftAligned		:= FALSE);

// Get weight
TUR.Orientation := F_StuffString(
					InputString 	:= TUR_ITC.Orientation, 
					StringLength	:= SIS_6_0.TTA_ORIENTATION, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);
				
// get TU parameter
TUR.TU_Parameter := F_StuffString(
						InputString 	:= DINT_TO_STRING(TUR_ITC.TU_Parameter), 
						StringLength	:= SIS_6_0.TTA_TU_PARAMETER, 
						StuffCharacter 	:= '0',
						LeftAligned		:= FALSE);
							
// Get I/O Data 
TUR.IO_Data := F_StuffString(
					InputString 	:= INT_TO_STRING(TUR_ITC.IO_Data), 
					StringLength	:= SIS_6_0.TUR_IO_DATA_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Lower Limit 
TUR.LowerLimit := F_StuffString(
					InputString 	:= DINT_TO_STRING(TUR_ITC.LowerLimit), 
					StringLength	:= SIS_6_0.TUR_LOWERLIMIT_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Upper Limit 
TUR.UpperLimit := F_StuffString(
					InputString 	:= DINT_TO_STRING(TUR_ITC.UpperLimit), 
					StringLength	:= SIS_6_0.TUR_UPPERLIMIT_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Group Info 
TUR.GroupInfo := F_StuffString(
					InputString 	:= ULINT_TO_STRING(TUR_ITC.GroupID), 
					StringLength	:= SIS_6_0.TUR_GROUPINFO_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Sequence 
TUR.Sequence := F_StuffString(
					InputString 	:= ULINT_TO_STRING(TUR_ITC.Sequence), 
					StringLength	:= SIS_6_0.TUR_SEQUENCE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Number in Sequence 
TUR.NumberInSequence := F_StuffString(
							InputString 	:= DINT_TO_STRING(TUR_ITC.SubSequence), 
							StringLength	:= SIS_6_0.TUR_NUMBER_IN_SEQUENCE_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);

// Get Error Code 
TUR.ReturnCode := F_StuffString(
					InputString 	:= INT_TO_STRING(TUR_ITC.ReturnCode), 
					StringLength	:= SIS_6_0.ERRORCODE_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Number of Destinations 
TUR.NumberOfDestinations := F_StuffString(
								InputString 	:= INT_TO_STRING(TUR_ITC.NumberOfDestinations), 
								StringLength	:= SIS_6_0.TUR_NUMBER_OF_DESTINATIONS_STRINGLENGTH, 
								StuffCharacter 	:= '0',
								LeftAligned		:= FALSE);

// Get Destinations 
FOR DestinationIdx := 1 TO TUR_ITC.NumberOfDestinations DO
	TUR.Destination[DestinationIdx] := F_StuffString(
										InputString 	:= TUR_ITC.Destination[DestinationIdx], 
										StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
										StuffCharacter 	:= '0',
										LeftAligned		:= FALSE);

END_FOR


(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('TUR'), 
	SrcLen:= 3, 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.TU_DataIndex), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.TU_DataIndex)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.TU_ID), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.TU_ID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.TU_Type), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.TU_Type)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.AssignmentID), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.AssignmentID)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.Length), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Length)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.Width), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Width)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.Height), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Height)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.Weight), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Weight)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.Orientation), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Orientation)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.TU_Parameter), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.TU_Parameter)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.IO_Data), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.IO_Data)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.LowerLimit), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.LowerLimit)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(TUR.UpperLimit), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.UpperLimit)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.GroupInfo), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.GroupInfo)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.Sequence), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.Sequence)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.NumberInSequence), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.NumberInSequence)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	

F_AssembleByteStream(
	pSrc:= ADR(TUR.ReturnCode), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.ReturnCode)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

F_AssembleByteStream(
	pSrc:= ADR(TUR.NumberOfDestinations), 
	SrcLen:= INT_TO_UDINT(LEN(TUR.NumberOfDestinations)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);

// Get Destinations 
FOR DestinationIdx := 1 TO TUR_ITC.NumberOfDestinations DO
	F_AssembleByteStream(
		pSrc:= ADR(TUR.Destination[DestinationIdx]), 
		SrcLen:= INT_TO_UDINT(LEN(TUR.Destination[DestinationIdx])), 
		pDest:= ADR(SendTelegram), 
		DestLen:= SIZEOF(SendTelegram), 
		WritePointer:= WritePointer);
END_FOR

// Add to buffer of Base Driver
M_ProcessTUR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ProcessVIR" Id="{df89ee6e-6363-408e-8642-0f2e84dc8667}">
      <Declaration><![CDATA[METHOD PROTECTED M_ProcessVIR : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send POR
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
 	meChannelSrc		: E_MFCS_Channel; // Source communicaton channel
	mpVIR				: POINTER TO ST_ITC_VIR; // Pointer to POR
END_VAR

VAR
	Idx					: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(**************************************************************************************************************
 	Check if a telegram needs to be send
***************************************************************************************************************)
// If settings allow sending a VIR 	
IF  Settings.Telegrams.SendVIR THEN
	// If the source of the request is this channel or is undefined
	IF meChannelSrc = Settings.MFCS_Channel OR
		meChannelSrc = E_MFCS_Channel.BEGIN_CHANNEL THEN
		;//Proceed
	ELSE // Source is a different MFCS Connection
		// Dont send a telegram		
		RETURN;
	END_IF	
ELSE
	// Dont send a telegram		
	RETURN;
END_IF

(**************************************************************************************************************
 	ITC - Map generic data to type
***************************************************************************************************************)
MEMCPY(destAddr := ADR(VIR_ITC), srcAddr := mpVIR, n := SIZEOF(VIR_ITC));

(**************************************************************************************************************
 	Formatting data
***************************************************************************************************************)

// Get SIS-Number 
VIR.Position := F_StuffString(
					InputString 	:= VIR_ITC.Position, 
					StringLength	:= SIS_6_0.POSITION_STRINGLENGTH, 
					StuffCharacter 	:= '0',
					LeftAligned		:= FALSE);

// Get Number of key value pairs 
VIR.NumberOfKeyValuePairs := F_StuffString(
							InputString 	:= INT_TO_STRING(VIR_ITC.NumOfKeyValuePairs), 
							StringLength	:= SIS_6_0.VIR_NUM_OF_KEYVALUEPAIRS_STRINGLENGTH, 
							StuffCharacter 	:= '0',
							LeftAligned		:= FALSE);

// Get KeyValuePairs 
FOR Idx := 1 TO VIR_ITC.NumOfKeyValuePairs BY 1 DO
	VIR.KeyValuePairs[Idx].Key	:= F_StuffString(
									InputString		:= VIR_ITC.KeyValuePair[Idx].Key,
									StringLength	:= SIS_6_0.VIR_KEY_STRINGLENGTH,
									StuffCharacter	:= ' ',
									LeftAligned		:= FALSE);
	
	VIR.KeyValuePairs[Idx].Value	:= F_StuffString(
										InputString		:= VIR_ITC.KeyValuePair[Idx].Value,
										StringLength	:= SIS_6_0.VIR_VALUE_STRINGLENGTH,
										StuffCharacter	:= ' ',
										LeftAligned		:= FALSE);
END_FOR

(**************************************************************************************************************
 	Build string and add to Base Driver
***************************************************************************************************************)
MEMSET(destAddr := ADR(SendTelegram), 0, SIZEOF(SendTelegram));
WritePointer := 0;

F_AssembleByteStream(
	pSrc:= ADR('VIR'),
	SrcLen:= 3,
	pDest:= ADR(SendTelegram),
	DestLen:= SIZEOF(SendTelegram),
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(VIR.Position), 
	SrcLen:= INT_TO_UDINT(LEN(VIR.Position)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);
	
F_AssembleByteStream(
	pSrc:= ADR(VIR.NumberOfKeyValuePairs), 
	SrcLen:= INT_TO_UDINT(LEN(VIR.NumberOfKeyValuePairs)), 
	pDest:= ADR(SendTelegram), 
	DestLen:= SIZEOF(SendTelegram), 
	WritePointer:= WritePointer);	
	

// Add key value pairs
FOR Idx := 1 TO VIR_ITC.NumOfKeyValuePairs BY 1 DO
	F_AssembleByteStream(
		pSrc:= ADR(VIR.KeyValuePairs[Idx].Key), 
		SrcLen:= INT_TO_UDINT(LEN(VIR.KeyValuePairs[Idx].Key)), 
		pDest:= ADR(SendTelegram), 
		DestLen:= SIZEOF(SendTelegram), 
		WritePointer:= WritePointer);	
	
	F_AssembleByteStream(
		pSrc:= ADR(VIR.KeyValuePairs[Idx].Value), 
		SrcLen:= INT_TO_UDINT(LEN(VIR.KeyValuePairs[Idx].Value)), 
		pDest:= ADR(SendTelegram), 
		DestLen:= SIZEOF(SendTelegram), 
		WritePointer:= WritePointer);	
END_FOR

// Add to buffer of Base Driver
M_ProcessVIR := fbBaseDriver.M_SendAppData(
					mpSendData := ADR(SendTelegram),
					mSendDataLen := WritePointer);

// Forward to mirror channel
M_MirrorData(Data := ADR(SendTelegram), DataLen := WritePointer);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_PutMSG" Id="{99b672aa-1549-4c30-8453-716e9f8a1e8f}">
      <Declaration><![CDATA[METHOD M_PutMSG 
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Handling received MSGs
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
	pData		: PVOID; // Pointer to received stream
	Len			: UDINT; // length of stream
END_VAR

VAR
    pString             : POINTER TO STRING       := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(*
	This method can be overloaded to do customized
	MSG implementations.
	
	Create in project folder an FunctionBlock for
	the SIS extension.
	
	Example:
	
	1.) Create FB - FB_SIS_MsgManager6_Extended;
	2.) Extend from orginal -> Extends FB_SIS_MsgManager6_0
	3.) Copy M_PutMSG from original to your implementation
	4.) Modify M_PutMSg as you want to have it
	5.) Change in Product config the implementation to your
	    new extended SIS driver
		
*)

(*
	Example implementation:
	
	// Clear data structure 
	MEMSET(destAddr := ADR(MyMSGStructure), fillByte := 0, n := SIZEOF(MyMSGStructure));

	// Preset offset
	IdxOffset := SIS_6_0.APP_DATA_OFFSET + 1;
	
	// Get subtype '000' - '999' of MSG
	MEMCPY(destAddr := ADR(MyMSGStructure.subtype), srcAddr := pData + IdxOffset), n := LENGTH_OF_SUBTYPE);
	
	// Do the same for customized content
	.
	.
	.
	.
	.
	
	
	// If no error was happing during processing, inform the driver message was processed and send 
	// it to mirror channel for logging
	IF NoError THEN
		// Message processed
		fbBaseDriver.M_ProcessedMsg();
		
		// Forward to mirror channel
		M_MirrorData(Data := pData, DataLen := Len);
	END_IF
*)



//_______________________________________________________________________________________
// if not overloaded, dump telegram and create a debug message
fbBaseDriver.M_ProcessedMsg();

// example: 'AM TCP/IP Driver,  customized MSG telegram implementation missing,  telegram = MSG987_THE_ANSWER_IS_42_ALWAYS'
DebugMsg:= '';
DebugMsg:= CONCAT(DebugMsg, Settings.BaseDriver.TCP_Driver.ChannelName);
DebugMsg:= CONCAT(DebugMsg, ',  customized MSG telegram implementation missing');
//-- telegram -----------------------------------
pString:= pData;
IF pString <> 0 THEN
    DebugMsg:= CONCAT(DebugMsg, DebugTextBlocks.TELEGRAM);
    DebugMsg:= CONCAT(DebugMsg, pString^);
END_IF

//-- send it ------------------------------------
fbDebugMsg.M_SendErrorMsg(DebugMsg);				  


]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SendAppData" Id="{63991220-7c45-4ec9-b8a4-fb76cd210c55}">
      <Declaration><![CDATA[METHOD M_SendAppData : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send application data to a max length of 255
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
 VAR_INPUT
	 pData		: PVOID;
	 DataLen	: UDINT;
 END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Add to buffer of Base Driver
M_SendAppData := fbBaseDriver.M_SendAppData(
					mpSendData 		:= pData,
					mSendDataLen	:= DataLen);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SendData" Id="{6afa90fd-2549-4374-9173-3e2c2d36c29e}">
      <Declaration><![CDATA[METHOD M_SendData : BOOL
(**************************************************************************************
 * 	Application		:	BoxControl Framework
 *	Revision		:	$Revision: 404529 $
 *	Revision date	:	$Date: 2018-04-23 08:21:38 +0200 (Mo., 23 Apr 2018) $
 *	Last changed by	:	$Author: b7bolm $
 *	URL				:	$URL: http://almscdc.swisslog.com/repo/SWPD/Development/BoxControlFramework/20_Release/trunk/01_Software/BCF/BCF/JumpStart/20_Product/10_App/11_Com/10_Lib/10_Conv/12_MFCS/11_SIS/FB_SIS_MsgManager_6_0.TcPOU $
 *
 *	Purpose			:	Send out
 *
 * ------------------------------------------------------------------------------------
 *	Copyright Swisslog [IP AG], Switzerland. All rights reserved.
 * 
 * ------------------------------------------------------------------------------------
 *	
 * 	Revision History: 
 *
 * 	VERSION			DATE			INITIALS			DESCRIPTION
 *	0.1				01.01.2001		swl					Example
 *
 **************************************************************************************)
VAR_INPUT
	meChannelSrc	: E_MFCS_Channel; // Source communicaton channel	
	mMsgType		: INT;
	mpData			: PVOID;
	mLen			: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Translate type to enumeration
eMsgType := mMsgType;

// Go to corresponding type
CASE eMsgType OF
	
	(**************************************************************************************
   		No message
	***************************************************************************************)
	E_ITC_MsgTypeConv.NO_MESSAGE_TYPE:
		;
		
	(**************************************************************************************
   		Robot command complete 
	***************************************************************************************)
	E_ITC_MsgTypeConv.ROBOT_ACTION_COMPLETE:
		// Process
		M_SendData := M_ProcessRAC(
							meChannelSrc := meChannelSrc,
							mpRAC := mpData);
							
	(**************************************************************************************
   		Robot delete report 
	***************************************************************************************)
	E_ITC_MsgTypeConv.ROBOT_DELETE_REPORT:
		// Process
		M_SendData := M_ProcessRDR(
							meChannelSrc := meChannelSrc,
							mpRDR := mpData);

	(**************************************************************************************
   		Visualization information request 
	***************************************************************************************)	
	E_ITC_MsgTypeConv.VISUALIZATION_INFORMATION_REPORT:
		// Process
		M_SendData := M_ProcessVIR(
							meChannelSrc := meChannelSrc,
							mpVIR := mpData);	
		
	(**************************************************************************************
   		Element control reply
	***************************************************************************************)
	E_ITC_MsgTypeConv.ELEMENT_CONTROL_REPLY:
		// Process
		M_SendData := M_ProcessECR(
						meChannelSrc := meChannelSrc,
						mpECR		 := mpData);
		
	(**************************************************************************************
   		ELEMENT_STATUS_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.ELEMENT_STATUS_REPORT:
		// Process
		M_SendData := M_ProcessESR(
						meChannelSrc := meChannelSrc,
						mpESR		 := mpData);
		
	(**************************************************************************************
   		FUNCTION_CONTROL_REPLY
	***************************************************************************************)
	E_ITC_MsgTypeConv.FUNCTION_CONTROL_REPLY:
		// Process
		M_SendData := M_ProcessFCR(
						meChannelSrc := meChannelSrc,
						mpFCR		 := mpData);
		
	(**************************************************************************************
   		FUNCTION_STATUS_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.FUNCTION_STATUS_REPORT:
		// Process
		M_SendData := M_ProcessFSR(
						meChannelSrc := meChannelSrc,
						mpFSR		 := mpData);
		
	(**************************************************************************************
   		GROUP_CONTROL_REPLY
	***************************************************************************************)
	E_ITC_MsgTypeConv.GROUP_CONTROL_REPLY:
		// Process
		M_SendData := M_ProcessGCR(
						meChannelSrc := meChannelSrc,
						mpGCR		 := mpData);
		
	(**************************************************************************************
   		GROUP_STATUS_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.GROUP_STATUS_REPORT:
		// Process
		M_SendData := M_ProcessGSR(
						meChannelSrc := meChannelSrc,
						mpGSR		 := mpData);
		
	(**************************************************************************************
   		GLOBAL_VARIABLE_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.GLOBAL_VARIABLE_REPORT:
		// Process
		M_SendData := M_ProcessGVR(
						meChannelSrc := meChannelSrc,
						mpGVR		 := mpData);
		
	(**************************************************************************************
   		IDENTIFICATION_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.IDENTIFICATION_REPORT:
		// Process
		M_SendData := M_ProcessIPR(
						meChannelSrc := meChannelSrc,
						mpIPR		 := mpData);
		
	(**************************************************************************************
   		I_O_STATUS_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.I_O_STATUS_REPORT:
		// Process
		M_SendData := M_ProcessISR(
						meChannelSrc := meChannelSrc,
						mpISR		 := mpData);
		
	(**************************************************************************************
   		MANUAL_CONTROL_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.MANUAL_CONTROL_REPORT:
		// Process
		M_SendData := M_ProcessMCR(
						meChannelSrc := meChannelSrc,
						mpMCR		 := mpData);
		
	(**************************************************************************************
   		POSITION_OCCUPIED_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.POSITION_OCCUPIED_REPORT:
		// Process
		M_SendData := M_ProcessPOR(
						meChannelSrc := meChannelSrc,
						mpPOR		 := mpData);
	
	(**************************************************************************************
   		SUBSYSTEM_CONTROL_REPLY
	***************************************************************************************)
	E_ITC_MsgTypeConv.SUBSYSTEM_CONTROL_REPLY:
		// Process
		M_SendData := M_ProcessSCR(
						meChannelSrc := meChannelSrc,
						mpSCR		 := mpData);
		
	(**************************************************************************************
   		SEND_DIGITAL_INPUT
	***************************************************************************************)
	E_ITC_MsgTypeConv.SEND_DIGITAL_INPUT:
		// Process
		M_SendData := M_ProcessSDI(
						meChannelSrc := meChannelSrc,
						mpSDI		 := mpData);
		
	(**************************************************************************************
   		SCANNER_INFORMATION_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.SCANNER_INFORMATION_REPORT:
		// Process
		M_SendData := M_ProcessSIR(
						meChannelSrc := meChannelSrc,
						mpSIR		 := mpData);
		
	(**************************************************************************************
   		SCANNER_NO_READ_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.SCANNER_NO_READ_REPORT:
		// Process
		M_SendData := M_ProcessSNR(
						meChannelSrc := meChannelSrc,
						mpSNR		 := mpData);
		
	(**************************************************************************************
   		SUBSYSTEM_STATUS_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.SUBSYSTEM_STATUS_REPORT:
		// Process
		M_SendData := M_ProcessSSR(
						meChannelSrc := meChannelSrc,
						mpSSR		 := mpData);
		
	(**************************************************************************************
   		TASK_DELETE_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.TASK_DELETE_REPORT:
		// Process
		M_SendData := M_ProcessTDR(
						meChannelSrc := meChannelSrc,
						mpTDR		 := mpData);
		
	(**************************************************************************************
   		TRANSPORT_TASK_COMPLETE
	***************************************************************************************)
	E_ITC_MsgTypeConv.TRANSPORT_TASK_COMPLETE:
		// Process
		M_SendData := M_ProcessTTC(
						meChannelSrc := meChannelSrc,
						mpTTC		 := mpData);
		
	(**************************************************************************************
   		TRANSPORT_TASK_REQUEST
	***************************************************************************************)
	E_ITC_MsgTypeConv.TRANSPORT_TASK_REQUEST:
		// Process
		M_SendData := M_ProcessTTQ(
						meChannelSrc := meChannelSrc,
						mpTTQ		 := mpData);
		
	(**************************************************************************************
   		TRANSPORT_UNIT_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.TRANSPORT_UNIT_REPORT:
		// Process
		M_SendData := M_ProcessTUR(
						meChannelSrc := meChannelSrc,
						mpTUR		 := mpData);
		
	(**************************************************************************************
   		DATA_ACQUISITION_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.DATA_ACQUISITION_REPORT:
		// Process
		M_SendData := M_ProcessDAR(
						meChannelSrc := meChannelSrc,
						mpDAR		 := mpData);
		
	(**************************************************************************************
   		GATHERED_DATA_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.GATHERED_DATA_REPORT:
			// Process
		M_SendData := M_ProcessGDR(
						meChannelSrc := meChannelSrc,
						mpGDR		 := mpData);
		
		
	(**************************************************************************************
   		Emulation ADD TU REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.E_ADD_TU_REPORT:
		// Process
		M_SendData := M_ProcessATR(
						meChannelSrc := meChannelSrc,
						mpATR		 := mpData);
		
	(**************************************************************************************
   		E_REMOVE_TU_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.E_REMOVE_TU_REPORT:
		// Process
		M_SendData := M_ProcessRTR(
						meChannelSrc := meChannelSrc,
						mpRTR		 := mpData);
		
	(**************************************************************************************
   		E_ERROR_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.E_ERROR_REPORT:
		// Process
		M_SendData := M_ProcessERR(
						meChannelSrc := meChannelSrc,
						mpERR		 := mpData);
						
	(**************************************************************************************
   		E_ERROR_REPORT
	***************************************************************************************)
	E_ITC_MsgTypeConv.DATA_MESSAGE:
		// Process
		M_SendData := M_SendAppData(
						pData := mpData,
						DataLen := mLen);
										
ELSE
	// Unknown type
	DebugMsg := 'Unknown message type received';
	fbDebugMsg.M_SendErrorMsg(mMessage := DebugMsg);		
END_CASE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>